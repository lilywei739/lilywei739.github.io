<!DOCTYPE html><html lang="en">
  <head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>JS基础--二叉树 - Weili's blog</title>
<meta name="description" content="二叉树什么是树？特点：  树是计算机科学中经常用到的一种数据结构  树是一种非线性的数据结构，以分层的方式存储数据  树被用来存储具有层级关系的数据，比如文件系统中的文件  树还被用来存储有序列表选择树而不是那些基本的数据结构，是因为在二叉树上进行查找非常快(而在链表上查找则不是这样)，为二叉树添加或删除元素 也...">
<link rel="canonical" href="http://localhost:4000/js/2017/10/30/tree.html"><link rel="alternate" type="application/rss+xml" title="Weili's blog" href="http://localhost:4000/feed.xml">
<!-- for Safari on iOS https://developer.apple.com/ios/human-interface-guidelines/icons-and-images/app-icon/ --><link rel="apple-touch-icon" sizes="180x180" href="/assets/images/logo/icon-180x180.png"><link rel="apple-touch-icon" sizes="167x167" href="/assets/images/logo/icon-167x167.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/images/logo/icon-152x152.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/images/logo/icon-120x120.png"><link rel="shortcut icon" href="/assets/images/logo/icon-120x120.png">
<!-- for Chrome on Android https://developer.chrome.com/multidevice/android/installtohomescreen -->
<meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/assets/images/logo/icon-192x192.png">
<!-- for Edge on Windows 10 https://msdn.microsoft.com/en-us/library/dn255024(v=vs.85).aspx --><meta name="msapplication-TileImage" content="/assets/images/logo/icon-144x144.png"><meta name="msapplication-square310x310logo" content="/assets/images/logo/icon-310x310.png"><meta name="msapplication-wide310x150logo" content="/assets/images/logo/icon-310x150.png"><meta name="msapplication-square150x150logo" content="/assets/images/logo/icon-150x150.png"><meta name="msapplication-square70x70logo" content="/assets/images/logo/icon-70x70.png">
<meta name="msapplication-TileColor" content="#eeeeee"><link rel="stylesheet" href="/assets/css/blog.css">
    <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
  </head>
  <body>
    <div class="m-page-stage js-page-stage"><div class="m-page-content"><header class="m-page-header">
  <div class="main clearfix">
    <div class='site-logo'><a title="WeiLi's Blog
" href="">Weili's blog</a></div>
    <nav>
      <ul><li><a href="/">Home</a></li><li><a href="/all.html">All</a></li><li><a href="/about.html">About</a></li></ul>
    </nav>
  </div>
</header>
<div class="m-page-main"><div class="m-post">
	<div class="main js-main clearfix">
		<div class="col-2 js-col-2">
			<aside class="js-article-aside"><div class="m-toc js-toc"></div></aside>
		</div>
		<div class="col-1">
			<article itemscope itemtype="http://schema.org/BlogPosting">
				<meta itemprop="mainEntityOfPage" itemscope itemType="https://schema.org/WebPage"/>
				<header class="main-header"><h1 itemprop="headline" itemprop="name headline">JS基础--二叉树</h1><div class="m-article-data clearfix"><meta itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Weili"/></meta><div class="other-wrapper"><div class="date-wrapper"><time class="article-meta" datetime="2017-10-30T00:00:00+08:00"
          itemprop="datePublished">Oct 30, 2017
        </time></div>
  </div>
</div>
</header>
				<div class="m-article-content js-article-content" itemprop="articleBody"><h1 id="二叉树">二叉树</h1>

<h5 id="什么是树">什么是树？</h5>

<p><strong>特点：</strong></p>

<ul>
  <li>树是计算机科学中经常用到的一种数据结构</li>
  <li>树是一种非线性的数据结构，以分层的方式存储数据</li>
  <li>树被用来存储具有层级关系的数据，比如文件系统中的文件</li>
  <li>树还被用来存储有序列表</li>
</ul>

<p>选择树而不是那些基本的数据结构，是因为在二叉树上进行查找非常快(而在链表上查找则不是这样)，为二叉树添加或删除元素 也非常快(而对数组执行添加或删除操作则不是这样)。</p>

<p><strong>定义：</strong></p>

<p>树由一组以边连接的节点组成</p>

<p><strong>其它定义：</strong></p>

<p>一棵树最上面的节点称为根节点，如果一个节点下面连接多个节点，那么该节点称为父节点，它下面的节点称为子节点。一个节点可以有 0 个、1 个或多个子节点。没有任何子节点的节点称为叶子节点</p>

<p>如下图所示：</p>

<p><img src="https://lilywei739.github.io/img/20171130/20171130-1.jpg" alt="image01" /></p>

<ul>
  <li>
    <p>沿着一组特定的边，可以从一个节点走到另外一个与它不直接相连的节点。从一个节点到另一个节点的这一组边称为<strong>路径</strong>，在图中用虚线表示。以某种<strong>特定顺序</strong>访问树中所有的节点称为<strong>树的遍历</strong></p>
  </li>
  <li>
    <p>树可以分为几个层次，根节点是第 0 层，它的子节点是第 1 层，子节点的子节点是第 2 层，以此类推。树中任何一层的节点可以都看做是子树的根，该子树包含根节点的子节点，子节点的子节点等。<strong>树的层数就是树的深度</strong></p>
  </li>
  <li>
    <p>每个节点都有一个与之相关的值，该值有时被称为<strong>键</strong></p>
  </li>
</ul>

<h5 id="二叉树是什么">二叉树是什么？</h5>

<p>二叉树是一种特殊的树，它的子节点个数不超过两个,通过将子节点的个数限定为 2，可以写出高效的程序在树中插入、查找和删除数据</p>

<p>一个父节点的两个子节点分别称为<strong>左节点</strong>和<strong>右节点</strong>。在一些二叉树的实现中，左节点包含一组特定的值，右节点包含另一组特定的值</p>

<h5 id="二叉查找树是什么">二叉查找树是什么？</h5>

<p>二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中</p>

<h5 id="实现二叉查找树">实现二叉查找树</h5>

<ul>
  <li>二叉查找树由节点组成，所以我们要定义的第一个对象就是 Node，节点</li>
</ul>

<p>每个节点的键、左节点、右节点定义</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Node(data, left, right) {
    this.data = data;
    this.left = left;
    this.right = right;
    this.show = show;
 }

function show() {
    return this.data;
}
</code></pre></div></div>

<ul>
  <li>再创建一个类，用来表示二叉查找树(BST)</li>
</ul>

<p>让类只包含一个数据成员: 一个表示二叉查找树根节点的 Node 对象。这个类的构造函数将根节点初始化为null，以此创建一个空节点</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function BST() {
    this.root = null;
    this.insert = insert;
    this.inOrder = inOrder;
}
</code></pre></div></div>

<ul>
  <li>insert方法：用来向树中加入新节点</li>
</ul>

<p>原理：</p>

<p>(1) 设根节点为当前节点。<br />
(2) 如果待插入节点保存的数据小于当前节点，则设新的当前节点为原节点的左节点;反之，执行第 4 步。<br />
(3) 如果当前节点的左节点为 null，就将新的节点插入这个位置，退出循环;反之，继续执行下一次循环。<br />
(4) 设新的当前节点为原节点的右节点。<br />
(5) 如果当前节点的右节点为 null，就将新的节点插入这个位置，退出循环;反之，继续执行下一次循环。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function insert(data) {
    var n = new Node(data, null, null);
    if (this.root == null) {
       this.root = n;
    } else {
       var current = this.root;
       var parent;
       while (true) {
          parent = current;
          if (data &lt; current.data) {
            current = current.left;
            if (current == null) {
                parent.left = n;
                break; 
            }
          } else {
             current = current.right;
             if (current == null) {
                parent.right = n;
                break; 
            }
          } 
        }
    }
}
</code></pre></div></div>

<p>有三种遍历 BST 的方式:中序、先序和后序</p>

<ul>
  <li>中序</li>
</ul>

<p>中序遍历以升序访问树中所有节点，先访问左子树，再访问根节点，最后访问右子树</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function inOrder(node) {
    if (!(node == null)) {
       inOrder(node.left);
       document.write(node.show() + " ");
       inOrder(node.right);
    }
}
</code></pre></div></div>

<p>实例化一个例子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var nums = new BST();
nums.insert(56);
nums.insert(81);
nums.insert(22);
nums.insert(30);
nums.insert(77);
nums.insert(92);
nums.insert(10);
document.write("Inorder traversal: ");
inOrder(nums.root);

运行结果： 10 22 30 56 77 81 92
</code></pre></div></div>

<p><img src="https://lilywei739.github.io/img/20171130/20171130-2.jpg" alt="image01" /></p>

<ul>
  <li>先序</li>
</ul>

<p>先序遍历先访问根节点，然后以同样方式访问左子树和右子树</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function preOrder(node) {
    if (!(node == null)) {
       document.write(node.show() + " ");
       preOrder(node.left);
       preOrder(node.right);
    } 
}
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var nums = new BST();
nums.insert(50);
nums.insert(70);
nums.insert(10);
nums.insert(15);
nums.insert(60);
nums.insert(5);
nums.insert(80);
document.write("preOrder traversal: ");
preOrder(nums.root);

运行结果：50 10 5 15 70 60 80
</code></pre></div></div>

<p><img src="https://lilywei739.github.io/img/20171130/20171130-3.jpg" alt="image01" /></p>

<p>inOrder() 和 preOrder() 方法的唯一区别，就是 if 语句中代码的顺序。</p>

<p>(1) 在 inOrder() 方法中，show() 函数像三明治一样夹在两个递归调用之间;<br />
(2) 在 preOrder() 方法中，show() 函数放在两个递归调用之前</p>

<ul>
  <li>后序</li>
</ul>

<p>后序遍历先访问叶子节点，从左子树到右子树，再到根节点</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function postOrder(node) {
    if (!(node == null)) {
       postOrder(node.left);
       postOrder(node.right);
       document.write(node.show() + " ");
    }
}
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var nums = new BST();
nums.insert(23);
nums.insert(45);
nums.insert(16);
nums.insert(37);
nums.insert(3);
nums.insert(99);
nums.insert(22);
document.write("postOrder traversal: ");
preOrder(nums.root);

运行结果： 3 22 16 37 99 45 23
</code></pre></div></div>

<p><img src="https://lilywei739.github.io/img/20171130/20171130-4.jpg" alt="image01" /></p>

<h5 id="在二叉查找树上进行查找">在二叉查找树上进行查找</h5>

<p>对 BST 通常有下列三种类型的查找:
(1) 查找给定值; (2) 查找最小值; (3) 查找最大值。</p>

<p>查找 BST 上的最小值和最大值非常简单。因为较小的值总是在左子节点上，在 BST 上查找最小值，只需要遍历左子树，直到找到最后一个节点</p>

<ul>
  <li>查找最小值</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getMin() {
    var current = this.root;
    while (!(current.left == null)) {
       current = current.left;
    }
    return current.data;
}
</code></pre></div></div>

<ul>
  <li>查找最大值</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getMax() {
    var current = this.root;
    while (!(current.right == null)) {
       current = current.right;
    }
    return current.data;
}

</code></pre></div></div>

<p>初始化个例子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var nums = new BST();
nums.insert(56);
nums.insert(81);
nums.insert(22);
nums.insert(30);
nums.insert(77);
nums.insert(92);
nums.insert(10);

var min = nums.getMin();
document.write("The minimum value of the BST is: " + min);
document.write("--------");
var max = nums.getMax();
document.write("The maximum value of the BST is: " + max);
</code></pre></div></div>

<p>运行结果：</p>

<p><img src="https://lilywei739.github.io/img/20171130/20171130-5.jpg" alt="image01" /></p>

<ul>
  <li>查找给定值</li>
</ul>

<p>在 BST 上查找给定值，需要比较该值和当前节点上的值的大小。通过比较，就能确定如果给定值不在当前节点时，该向左遍历还是向右遍历</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function find(data) {
     var current = this.root;
     while (current != null) {
         if (current.data == data) {
             return current;
         } else if (data &lt; current.data) {
             current = current.left;
         } else {
             current = current.right;
         }
    }
    return null;
}
</code></pre></div></div>

<p>如果找到给定值，该方法返回保存该值的节点;如果没找到，该方法返回 null</p>

<h5 id="从二叉查找树上删除节点">从二叉查找树上删除节点</h5>

<p>从 BST 上删除节点的操作最复杂，其复杂程度取决于删除哪个节点。如果删除没有子节点 的节点，那么非常简单。如果节点只有一个子节点，不管是左子节点还是右子节点，就变 得稍微有点复杂了。删除包含两个子节点的节点最复杂</p>

<p>原理：</p>

<ul>
  <li>从 BST 中删除节点的第一步是判断当前节点是否包含待删除的数据，如果包含，则删除该 节点;如果不包含，则比较当前节点上的数据和待删除的数据。如果待删除数据小于当前 节点上的数据，则移至当前节点的左子节点继续比较;如果删除数据大于当前节点上的数 据，则移至当前节点的右子节点继续比较。</li>
  <li>如果待删除节点是叶子节点(没有子节点的节点)，那么只需要将从父节点指向它的链接 指向 null。</li>
  <li>如果待删除节点只包含一个子节点，那么原本指向它的节点久得做些调整，使其指向它的 子节点。</li>
  <li>如果待删除节点包含两个子节点，正确的做法有两种:要么查找待删除节点左子树 上的最大值，要么查找其右子树上的最小值。这里选择后一种方式</li>
</ul>

<p>整个删除过程由两个方法完成。remove() 方法只是简单地接受待删除数据，调用 removeNode()删除它</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function remove(data) {
    root = removeNode(this.root, data);
}

function removeNode(node, data) {
    if (node == null) {
       return null;
    }

    if (data == node.data) {
        // 没有子节点的节点
        if (node.left == null &amp;&amp; node.right == null) {
           return null;
        }
        // 没有左子节点的节点
        if (node.left == null) {
           return node.right;
        }

        // 没有右子节点的节点
        if (node.right == null) {
           return node.left;
        }

        // 有两个子节点的节点
        var tempNode = getSmallest(node.right);
        node.data = tempNode.data;
        node.right = removeNode(node.right, tempNode.data); return node;
    } else if (data &lt; node.data) {
       node.left = removeNode(node.left, data);
       return node;
    } else {
       node.right = removeNode(node.right, data);
       return node;
    } 
}
</code></pre></div></div>

</div></article>
		</div>
	</div>
</div><script src="//cdn.bootcss.com/toc/0.3.2/toc.min.js"></script>
<script type="text/javascript">
	window.throttle = function(func, wait) {
	  var args, result, thisArg, timeoutId, lastCalled = 0;

	  function trailingCall() {
	    lastCalled = new Date;
	    timeoutId = null;
	    result = func.apply(thisArg, args);
	  }
	  return function() {
	    var now = new Date,
	      remaining = wait - (now - lastCalled);

	    args = arguments;
	    thisArg = this;

	    if (remaining <= 0) {
	      clearTimeout(timeoutId);
	      timeoutId = null;
	      lastCalled = now;
	      result = func.apply(thisArg, args);
	    } else if (!timeoutId) {
	      timeoutId = setTimeout(trailingCall, remaining);
	    }
	    return result;
	  };
	}
	$(function() {
	  var $window = $(window);
	  var $pageStage = $('.js-page-stage');
	  var $pageMain = $('.js-main');
	  var $pageFooter = $('.js-page-footer');
	  var $articleContent = $('.js-article-content');
	  var $articleAside = $('.js-article-aside');
	  var $toc = $('.js-toc');
		var $col2 = $('.js-col-2');
	  var hasTitle = $articleContent.find('h1,h2,h3').length > 0;
	  function asideSticky() {
	    return $col2.css('display') !== 'none' && $pageStage.hasClass('has-toc');
	  }

	  function setTocClass() {
	    if (hasTitle) {
	      !$pageStage.hasClass('has-toc') && $pageStage.addClass('has-toc');
	    }
	  }

	  setTocClass();

	  function setAsideTOC() {
	    var asideTop, asideLeft, scrollBottom, asideBottomTop, lastScrollTop;

	    function init() {
	      var asideOffset = $articleAside.offset();
	      var footerOffset = $pageFooter.offset();
	      var mainOffset = $pageMain.offset();
	      asideTop = mainOffset.top;
	      asideHeight = $toc.outerHeight() + parseInt($articleAside.css('padding-top'), 10) + parseInt($articleAside.css('padding-bottom'), 10);
	      asideLeft = mainOffset.left + $pageMain.outerWidth() - $articleAside.outerWidth() - parseInt($pageMain.css('padding-right'), 10);
	      scrollBottom = footerOffset.top - asideHeight;
	      asideBottomTop = scrollBottom - mainOffset.top;
	    }

	    function setAside(force) {
	      force !== true && (force = false);
	      var scrollTop = $window.scrollTop();
	      if (scrollTop >= asideTop && scrollTop <= scrollBottom) {
	        (!force && lastScrollTop >= asideTop && lastScrollTop <= scrollBottom) ||
	        $articleAside.addClass('fixed').css({
	          left: asideLeft + 'px',
	          top: 0
	        });
	      } else if (scrollTop < asideTop) {
	        (!force && lastScrollTop < asideTop) ||
	        $articleAside.removeClass('fixed').css({
	          left: 0,
	          top: 0
	        });
	      } else {
	        (!force && lastScrollTop > scrollBottom) ||
	        $articleAside.removeClass('fixed').css({
	          left: 0,
	          top: asideBottomTop + 'px'
	        });
	      }
	      lastScrollTop = scrollTop;
	    }
	    asideSticky() && (init(), setAside());
	    $window.on('scroll', function() {
	      asideSticky() && setAside();
	    });
	    $window.on('resize', throttle(function() {
	      setTocClass();
	      asideSticky() && (init(), setAside(true));
	    }, 100));
	    setTimeout(init, 4000);
	  }
	  setTimeout(setAsideTOC, 1000);

	  $toc.toc({
	    'selectors': 'h1,h2,h3',
	    'container': '.js-article-content',
	  });
	});
</script></div>
</div>
</div><div class="m-page-footer js-page-footer">
  <div class="main">
    <aside><div class="follow-me"><ul itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Weili">
    <link itemprop="url" href="http://localhost:4000/"></ul></div>
</aside>
    <footer class="site-info">
      <p>© Weili's blog 2018</p>
      <p><a title="" href="//github.com/lilywei739/lilywei739.github.io">View on GitHub</a></p>
    </footer>
  </div>
</div>
<script>
      $(function() {
        // display coding language
        var $articleContent = $('.m-post, .m-page').find('.m-article-content'), $this;
        $articleContent.children('.highlight').each(function() {
          $this = $(this);
          $this.attr('data-lang', $this.find('code').attr('data-lang'));
        });
        $articleContent.children('h1, h2, h3, h4, h5, h6').each(function() {
          $this = $(this);
          $this.append($('<a class="anchor" aria-hidden="true"></a>').text('#'));
        });
        $articleContent.on('click', '.anchor', function(e) {
          var targetId = $(this).parent().attr('id');
          scrollAnimateTo($('#' + targetId).offset().top, 400, function() {
            console.log(666)
            window.history.replaceState(null, '', window.location.href.split('#')[0] + '#' + targetId);
          });
        });
        function scrollAnimateTo(destination, duration, callback) {
          var $body = $('html, body'), bodyScrollTop = $body.scrollTop();
          if(bodyScrollTop === destination) { return; }
          $body.animate({ scrollTop: destination }, duration, callback);
        }
      });
    </script></body>
</html>
