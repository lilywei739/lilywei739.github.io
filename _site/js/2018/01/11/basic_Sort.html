<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <meta name="robots" content="index,follow"/>
        <meta name="renderer" content="webkit" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui" />
        <meta name="keywords" content="JS基础-- 基本排序">
        <meta name="screen-orientation" content="portrait" />
        <meta name="full-screen" content="yes" />
        <meta name="browsermode" content="application" />
        <meta name="x5-orientation" content="portrait" />
        <meta name="x5-fullscreen" content="true" />
        <meta name="x5-page-mode" content="app" />
        <title>Weili - GitHub.io</title>
        <link rel="shortcut icon" type="image/ico" href="/favicon.ico"/>
        <link rel="stylesheet" href="/css/common/github-gist.min.css">
        <link rel="stylesheet" href="/css/style.css">
        <!--[if lt IE 9]>
        <script src="/js/common/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <!-- HEADER -->
        <div id="header_wrap" class="outer">
            <header class="inner">
                <h1 id="project_title"><a href="/index.html">Weili - GitHub.io</a></h1>
                <h2 id="project_tagline"><a href="https://github.com/lilywei739/lilywei739.github.io" target="_blank">View on GitHub</a></h2>
            </header>
        </div>
            
        <div id="content-wrapper">
            <div class="main clearfix">
                <aside id="sidebar">
                    <ul class="side-nav">
                    </ul>
                </aside>

                <section id="main-cont">
                    <h1 id="基本排序算法">基本排序算法</h1>

<p>这里介绍的基本排序算法其核心思想是指对一组数据按照一定的顺序重新排列。重新排列时用到的技术是一组嵌套的 for 循环。其中外循环会遍历数组的每一项，内循环则用于比较元素。</p>

<p>在讲这几个基本排序之前，先初始化一个类，因为下面所有的排序都是基于这个类实现的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function CArray(numElements) {
    this.dataStore = [];
    this.pos = 0;
    this.numElements = numElements;
    this.insert = insert;
    this.toString = toString;
    this.clear = clear;
    this.setData = setData;
    this.bubbleSort = bubbleSort;
    this.swap = swap;
	for ( var i = 0; i &lt; numElements; ++i ) {
		this.dataStore[i] = i;
	} 
}

function setData() {
    for ( var i = 0; i &lt; this.numElements; ++i ) {
       this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1));
    }
}

function clear() {
	for ( var i = 0; i &lt; this.dataStore.length; ++i ) {
	   this.dataStore[i] = 0;
	}
}


function insert(element) {
    this.dataStore[this.pos++] = element;
}


function toString() {
	var retstr = "";
	for ( var i = 0; i &lt; this.dataStore.length; ++i ) {
	   retstr += this.dataStore[i] + " ";
	   if (i &gt; 0 &amp; i % 10 == 0) {
	      retstr += "\n";
	   }
	}
	return retstr;
}


function swap(arr, index1, index2) {
	var temp = arr[index1];
	arr[index1] = arr[index2];
	arr[index2] = temp;
}
</code></pre>
</div>

<p>上面的类包含下面几个功能</p>

<ul>
  <li>插入新数据</li>
  <li>显示数组数据</li>
  <li>调用不同的排序算法</li>
  <li>交换数组元素</li>
</ul>

<h4 id="冒泡排序">冒泡排序</h4>

<p>冒泡排序算法，它是最慢的排序算法之一，但也是一种最容易实现的排序算法</p>

<p>之所以叫冒泡排序是因为使用这种排序算法排序时，数据值会像气泡一样从数组的一端漂 浮到另一端。假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，而较小 的值则会浮动到数组的左侧。之所以会产生这种现象是因为算法会多次在数组中移动，比 较相邻的数据，当左侧值大于右侧值时将它们进行互换</p>

<p>如下图演示了如何对一个大的数字数据集合进行冒泡排序的过程</p>

<p><img src="http://lilywei739.github.io/img/20180112/20180112-1.jpg" alt="冒泡排序的过程" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>function bubbleSort() {
        var numElements = this.dataStore.length;
        var temp;
        for ( var outer = numElements; outer &gt;= 2; --outer) {
           for ( var inner = 0; inner &lt;= outer - 1; ++inner ) {
              if (this.dataStore[inner] &gt; this.dataStore[inner + 1]) {
                 swap(this.dataStore, inner, inner + 1);
              }
 	   } 
 	}
}
</code></pre>
</div>

<p>初始化个例子：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var numElements = 10;
var mynums = new CArray(numElements);
mynums.setData();
document.write(mynums.toString());
mynums.bubbleSort();
document.write('&lt;br /&gt;');
document.write(mynums.toString());
</code></pre>
</div>

<p>排序结果如下：</p>

<p><img src="http://lilywei739.github.io/img/20180112/20180112-2.jpg" alt="" /></p>

<p>增加一行代码，就可看到这个数组在排序过程中的当前状态</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function bubbleSort() {
    var numElements = this.dataStore.length;
    var temp;
    for (var outer = numElements; outer &gt;= 2; --outer) {
       for (var inner = 0; inner &lt;= outer - 1; ++inner) {

          if (this.dataStore[inner] &gt; this.dataStore[inner + 1]) {
             swap(this.dataStore, inner, inner + 1);
          }
		}
        document.write('&lt;br /&gt;');
        document.write(this.toString());
    }
}
</code></pre>
</div>

<p>排序结果如下：</p>

<p><img src="http://lilywei739.github.io/img/20180112/20180112-3.jpg" alt="" /></p>

<p>通过这个输出结果，我们可以更加容易地看出小的值是如何移到数组开头的，大的值又是 如何移到数组末尾的。</p>

<h4 id="选择排序">选择排序</h4>

<p>选择排序从数组的开头开始，将第一个元素和其他元 素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从 第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便 完成了排序。</p>

<p>选择排序会用到嵌套循环。外循环从数组的第一个元素移动到倒数第二个元素;内循环从第 二个数组元素移动到最后一个元素，查找比当前外循环所指向的元素小的元素。每次内循环 迭代后，数组中最小的值都会被赋值到合适的位置。</p>

<p>选择排序算法的原理：</p>

<p><img src="http://lilywei739.github.io/img/20180112/20180112-4.jpg" alt="" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>function selectionSort() {
    var min, temp;
    for (var outer = 0; outer &lt;= this.dataStore.length-2; ++outer) {
       min = outer;
       for (var inner = outer + 1;
           inner &lt;= this.dataStore.length-1; ++inner) {
          if (this.dataStore[inner] &lt; this.dataStore[min]) {
			  min = inner; 
		  }
          swap(this.dataStore, outer, min);
          document.write('&lt;br /&gt;');
          document.write(this.toString());
       }
    } 
}
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>var numElements = 10;
var mynums = new CArray(numElements);
mynums.setData();
mynums.selectionSort();
</code></pre>
</div>

<p>排序结果如下：</p>

<p><img src="http://lilywei739.github.io/img/20180112/20180112-5.jpg" alt="" /></p>

<h4 id="插入排序">插入排序</h4>

<p>插入排序类似于人类按数字或字母顺序对数据进行排序</p>

<p>举个例子，将卡片带回办公室，清理好书桌，然后拿起第一张卡片。卡片上的姓氏是 Smith。我把 它放到桌子的左上角，然后再拿起第二张卡片。这张卡片上的姓氏是 Brown。我把 Smith 移右，把 Brown 放到 Smith 的前面。下一张卡片是 Williams，可以把它放到桌面最右边， 而不用移动其他任何卡片。下一张卡片是 Acklin。这张卡片必须放在这些卡片的最前面， 因此其他所有卡片必须向右移动一个位置来为 Acklin 这张卡片腾出位置。这就是插入排序 的排序原理。</p>

<p>插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及 它后面的那个元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数 组元素会向右移动，为内循环中的这个元素腾出位置，就像之前介绍的姓氏卡片一样。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function insertionSort() {
        var temp, inner;
        for (var outer = 1; outer &lt;= this.dataStore.length - 1; ++outer) {
           temp = this.dataStore[outer];
           inner = outer;
           while (inner &gt; 0 &amp;&amp; (this.dataStore[inner - 1] &gt;= temp)) {
              this.dataStore[inner] = this.dataStore[inner - 1];
--inner; }
           this.dataStore[inner] = temp;
           document.write('&lt;br /&gt;');
       	   document.write(this.toString());
        }
}

</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>var numElements = 10;
var mynums = new CArray(numElements);
mynums.setData();
mynums.insertionSort();
</code></pre>
</div>

<p>排序结果如下：</p>

<p><img src="http://lilywei739.github.io/img/20180112/20180112-6.jpg" alt="" /></p>

<p>这段输出结果清楚地显示了插入排序的运行并非通过数据交换，而是通过将较大的数组元 素移动到右侧，为数组左侧的较小元素腾出位置。</p>

<h4 id="基本排序算法的计时比较">基本排序算法的计时比较</h4>

<p>这三种排序算法的复杂度非常相似，从理论上来说，它们的执行效率也应该差不多。要确 定这三种算法的性能差异，我们可以使用一个非正式的计时系统来比较它们对数据集合进 行排序所花费的时间。能够对算法进行计时非常重要，因为，对 100 个或 1000 个元素进 行排序时，你看不出这些排序算法的差异。但是如果对上百万个元素进行排序，这些排序 算法之间可能存在巨大的不同。</p>

<p>这个函数的运行方式如下所示:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var start = new Date().getTime();
</code></pre>
</div>

<p>要记录代码执行的时间，首先启动计时器，执行代码，然后在代码执行结束时停止计时 器。计时器停止时记录的时间与计时器启动时记录的时间之差就是排序所花费的时间。</p>

<p>有了度量排序算法效率的工具，那我们就来做一些测试，对它们进行比较</p>

<p>为了比较基本排序算法，我们将在数组大小分别为100、1000和10 000时对这三种排序算 法计时。我们预期在数据大小为 100 和 1000 的情况下看不出这些算法的差异，但是在数 据大小为 10000时可以看到。</p>

<p>测试代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var numElements = 100;    //测试数据100、1000、10000
var nums = new CArray(numElements);
nums.setData();
var start = new Date().getTime();
nums.bubbleSort();
var stop = new Date().getTime();
var elapsed = stop - start;
document.write("对" + numElements + "个元素执行冒泡排序消耗的时间为:" +
elapsed + "毫秒。&lt;br /&gt;");
start = new Date().getTime();
nums.selectionSort();
stop = new Date().getTime();
elapsed = stop - start;
document.write("对" + numElements + "个元素执行选择排序消耗的时间为:" +
elapsed + "毫秒。&lt;br /&gt;");
start = new Date().getTime();
nums.insertionSort();
stop = new Date().getTime();
elapsed = stop - start;
document.write("对" + numElements + "个元素执行插入排序消耗的时间为:" +
elapsed + "毫秒。");
</code></pre>
</div>

<p>测试数据100结果：</p>

<p><img src="http://lilywei739.github.io/img/20180112/20180112-7.jpg" alt="" /></p>

<p>测试数据1000结果：</p>

<p><img src="http://lilywei739.github.io/img/20180112/20180112-8.jpg" alt="" /></p>

<p>测试数据10000结果：</p>

<p><img src="http://lilywei739.github.io/img/20180112/20180112-9.jpg" alt="" /></p>

<p>通过上面的结果，可得出选择排序和插入排序要比冒泡排序快，插入排序是这三种算法中最快的。不过要记住，这些测试必须经过多次的运行， 最后得到的结果才可被视为是有效的统计。</p>

		<div class="PageNavigation">
		  
		    <a class="prev" href="/js/2018/01/05/grap2.html">&laquo; JS基础--图和图算法(二)</a>
		  
		  
		    <a class="next" href="/js/2018/01/25/senior_Sort_1.html">JS基础--高级排序(一) &raquo;</a>
		  
		</div>
		<!-- 多说评论框 start -->
        <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
        <!--
<div id="ds_ele" class="ds-thread" data-thread-key="" data-title="JS基础-- 基本排序" data-url="http://lilywei739.github.io/js/2018/01/11/basic_Sort.html"></div>
		    <script type="text/javascript">
                        var url = window.location.pathname;
                        url = url.substr(1, url.length -6).replace(/\//gi, '_');
                        document.getElementById('ds_ele').dataset.threadKey = url;
                        var duoshuoQuery = {short_name:"github"};
                        (function() {
                            var ds = document.createElement('script');
                            ds.type = 'text/javascript';ds.async = true;
                            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                            ds.charset = 'UTF-8';
                            (document.getElementsByTagName('head')[0] 
                            || document.getElementsByTagName('body')[0]).appendChild(ds);
                        })();

                    </script>
                    -->
		<!-- 多说公共JS代码 end -->
                </section>
            </div>
        </div>
            
        <!-- FOOTER  -->
        <div id="footer_wrap" class="outer">
            <footer class="inner">
                <p>© 2016  by Weili &nbsp;&nbsp;  |  &nbsp;&nbsp;托管在 - <a href="https://pages.github.com">GitHub</a></p>
            </footer>
        </div>
        <script src="/js/common/jquery-2.2.4.min.js"></script>
        <script src="/js/common/highlight.min.js"></script>
        <script src="/js/aside-nav.js"></script>
        <script>
            // baidu 统计
            var _hmt = _hmt || [];
            (function() {
                var hm = document.createElement("script");
                hm.src = "//hm.baidu.com/hm.js?146fe495fee020bf0e4dd701aa73965f";
                var s = document.getElementsByTagName("script")[0]; 
                s.parentNode.insertBefore(hm, s);
            })();
            // highlight
            hljs.initHighlightingOnLoad({useBR: true});
            $(document).ready(function() {
                $('pre code').each(function(i, block) {
                    hljs.highlightBlock(block);
                });
            });
        </script>
    </body>
</html>
