<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <meta name="robots" content="index,follow"/>
        <meta name="renderer" content="webkit" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui" />
        <meta name="keywords" content="React（二）">
        <meta name="screen-orientation" content="portrait" />
        <meta name="full-screen" content="yes" />
        <meta name="browsermode" content="application" />
        <meta name="x5-orientation" content="portrait" />
        <meta name="x5-fullscreen" content="true" />
        <meta name="x5-page-mode" content="app" />
        <title>React（二）</title>
        <link rel="shortcut icon" type="image/ico" href="/favicon.ico"/>
        <link rel="stylesheet" href="/css/common/github-gist.min.css">
        <link rel="stylesheet" href="/css/style.css">
        <!--[if lt IE 9]>
        <script src="/js/common/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <!-- HEADER -->
        <div id="header_wrap" class="outer">
            <header class="inner">
                <h1 id="project_title"><a href="/index.html">Weili - GitHub.io</a></h1>
                <h2 id="project_tagline"><a href="https://github.com/lilywei739/lilywei739.github.io" target="_blank">View on GitHub</a></h2>
            </header>
        </div>
            
        <div id="content-wrapper">
            <div class="main clearfix">
                <aside id="sidebar">
                    <ul class="side-nav">
                    </ul>
                </aside>

                <section id="main-cont">
                    <h1 id="react">React（二）</h1>

<h3 id="react-">React 组件</h3>

<p>创建一个组件</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var HelloMessage = React.createClass({
  render: function() {
    return &lt;h1&gt;Hello World！&lt;/h1&gt;;
  }
});
 
ReactDOM.render(
  &lt;HelloMessage /&gt;,
  document.getElementById('example')
);
</code></pre>
</div>
<p>React.createClass 方法用于生成一个组件类 HelloMessage。<hellomessage></hellomessage> 实例组件类并输出信息。</p>

<blockquote>
  <p>注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。</p>
</blockquote>

<h4 id="props">向组件中传参，props</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>var HelloMessage = React.createClass({
  render: function() {
    return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;
  }
});
 
ReactDOM.render(
  &lt;HelloMessage name="Runoob" /&gt;,
  document.getElementById('example')
);
</code></pre>
</div>

<p>给组件传参数，通过props 属性，与传的参数名字一一对应，实例中 name 属性通过 this.props.name 来获取, <strong>在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字</strong></p>

<h4 id="section">组合组件</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>var WebSite = React.createClass({        //组件WebSite 包含两个小的组件
  render: function() {
    return (
      &lt;div&gt;
        &lt;Name name={this.props.name} /&gt;  //组件 Name，因为 name 值是在父组件中传过来的，这里用 this.props 去取
        &lt;Link site={this.props.site} /&gt;  //组件 Link，同理，用 this.props 去取传过来的属性
      &lt;/div&gt;
    );
  }
});
 
var Name = React.createClass({
  render: function() {
    return (
      &lt;h1&gt;{this.props.name}&lt;/h1&gt;
    );
  }
});
 
var Link = React.createClass({
  render: function() {
    return (
      &lt;a href={this.props.site}&gt;
        {this.props.site}
      &lt;/a&gt;
    );
  }
});
 
ReactDOM.render(
  &lt;WebSite name="宝宝树" site="http://www.babytree.com" /&gt;,
  document.getElementById('example')
);
</code></pre>
</div>

<h4 id="react-state">React State(状态)</h4>

<p>React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。</p>

<p>React 里，只需<strong>更新组件的 state，</strong>然后根据<strong>新的 state</strong> 重新<strong>渲染用户界面</strong>（不要操作 DOM）。</p>

<p><strong>getInitialState</strong>方法用于定义初始状态</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var LikeButton = React.createClass({
getInitialState: function() {                //getInitialState 方法用于定义初始状态，用了一个对象，这个对象只能用 this.state 来读取属性
  return {liked: false};
}, 

handleClick: function(event) {
  this.setState({liked: !this.state.liked}); //当用户点击组件，导致状态变化，this.setState 方法就修改状态值
},

render: function() {                        //每次修改以后，自动调用 this.render 方法，再次渲染组件
  var text = this.state.liked ? '喜欢' : '不喜欢';
  return (
    &lt;p onClick={this.handleClick}&gt;
      你&lt;b&gt;{text}&lt;/b&gt;我。点我切换状态。
    &lt;/p&gt;
  );
}
});

ReactDOM.render(
  &lt;LikeButton /&gt;,
  document.getElementById('example')
);
</code></pre>
</div>

<h4 id="props-1">props</h4>

<p>state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据。</p>

<p>props举个简单的例子，实例中 name 属性通过 this.props.name 来获取</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var HelloMessage = React.createClass({
  render: function() {
    return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;
  }
});

ReactDOM.render(
  &lt;HelloMessage name="Runoob" /&gt;,
  document.getElementById('example')
);
</code></pre>
</div>

<h4 id="props-2">默认 Props</h4>

<p><strong>getDefaultProps()</strong> 方法为 props 设置默认值</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var HelloMessage = React.createClass({
    getDefaultProps: function () {
    	return {name: 'Runoob'}
    },
    render: function () {
        return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;
    }
})

ReactDOM.render(&lt;HelloMessage /&gt;, document.getElementById('example'));
</code></pre>
</div>

<p>这个例子和上面的例子完全一样，区别是参数一个直接写在组件里面，另一个用 getDefaultProps 方法来设置。</p>

<h4 id="state--props">State 和 Props</h4>

<p>还是以上面组合组件的示例，更改一下</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var WebSite = React.createClass({
    getInitialState: function () {
        return {
            name: "宝宝树",            //设置了 name 属性，只能用 this.state 来取
            src: "www.babytree.com"    //同理
        }
    },
    render: function () {
        return (
            &lt;div&gt;
                &lt;Name name={this.state.name} /&gt;   //Name组件，用this.name取初始化中的name值，但是这处也是一个参数,会在初始化 Name 组件时用 this.props 取值
                &lt;Link src={this.state.src} /&gt;
            &lt;/div&gt;
        );
    }
});

var Name = React.createClass({
    render: function () {
        return &lt;h1&gt;{this.props.name}&lt;/h1&gt;
    }
});

var Link = React.createClass({
    render: function () {
        return &lt;p&gt;&lt;a href={this.props.src}&gt;{this.props.src}&lt;/a&gt;&lt;/p&gt;
    }
});


ReactDOM.render(&lt;WebSite /&gt;, document.getElementById('box'));      //WebSite 父组件
</code></pre>
</div>

<h4 id="props-">Props 验证</h4>

<p>Props 验证使用 <strong>propTypes</strong>，它可以保证我们的应用组件被正确使用，<strong>React.PropTypes</strong> 提供很多验证器 (validator) 来验证传入数据是否有效。当向 props 传入无效数据时，JavaScript 控制台会抛出警告。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    var title = "宝宝树";
    //var title = 123;
    var MyTitle = React.createClass({
      propTypes: {
        title: React.PropTypes.string.isRequired,
      },

      render: function() {
         return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;
       }
    });
    ReactDOM.render(
        &lt;MyTitle title={title} /&gt;,
        document.getElementById('example')
    );

</code></pre>
</div>

<p>React.PropTypes.string.isRequired  必须是字符串，如果是数字会报错。</p>

<p>更多的检验器：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>React.createClass({
  propTypes: {
    // 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的
   optionalArray: React.PropTypes.array,
    optionalBool: React.PropTypes.bool,
    optionalFunc: React.PropTypes.func,
    optionalNumber: React.PropTypes.number,
    optionalObject: React.PropTypes.object,
    optionalString: React.PropTypes.string,
 
    // 可以被渲染的对象 numbers, strings, elements 或 array
    optionalNode: React.PropTypes.node,
 
    //  React 元素
    optionalElement: React.PropTypes.element,
 
    // 用 JS 的 instanceof 操作符声明 prop 为类的实例。
    optionalMessage: React.PropTypes.instanceOf(Message),
 
    // 用 enum 来限制 prop 只接受指定的值。
    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),
 
    // 可以是多个对象类型中的一个
    optionalUnion: React.PropTypes.oneOfType([
      React.PropTypes.string,
      React.PropTypes.number,
      React.PropTypes.instanceOf(Message)
    ]),
 
    // 指定类型组成的数组
    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),
 
    // 指定类型的属性构成的对象
    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),
 
    // 特定 shape 参数的对象
    optionalObjectWithShape: React.PropTypes.shape({
      color: React.PropTypes.string,
      fontSize: React.PropTypes.number
    }),
 
    // 任意类型加上 `isRequired` 来使 prop 不可空。
    requiredFunc: React.PropTypes.func.isRequired,
 
    // 不可空的任意类型
    requiredAny: React.PropTypes.any.isRequired,
 
    // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。
    customProp: function(props, propName, componentName) {
      if (!/matchme/.test(props[propName])) {
        return new Error('Validation failed!');
      }
    }
  },
  /* ... */
});

</code></pre>
</div>

		<div class="PageNavigation">
		  
		    <a class="prev" href="/2017/02/22/React_1.html">&laquo; React（一）</a>
		  
		  
		</div>
		<!-- 多说评论框 start -->
<div id="ds_ele" class="ds-thread" data-thread-key="" data-title="React（二）" data-url="http://lilywei739.github.io/2017/03/02/React_2.html"></div>
                    <!-- 多说评论框 end -->
                    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		    <script type="text/javascript">
                        var url = window.location.pathname;
                        url = url.substr(1, url.length -6).replace(/\//gi, '_');
                        document.getElementById('ds_ele').dataset.threadKey = url;
                        var duoshuoQuery = {short_name:"github"};
                        (function() {
                            var ds = document.createElement('script');
                            ds.type = 'text/javascript';ds.async = true;
                            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                            ds.charset = 'UTF-8';
                            (document.getElementsByTagName('head')[0] 
                            || document.getElementsByTagName('body')[0]).appendChild(ds);
                        })();
                    </script>
		<!-- 多说公共JS代码 end -->
                </section>
            </div>
        </div>
            
        <!-- FOOTER  -->
        <div id="footer_wrap" class="outer">
            <footer class="inner">
                <p>© 2016  by Weili &nbsp;&nbsp;  |  &nbsp;&nbsp;托管在 - <a href="https://pages.github.com">GitHub</a></p>
            </footer>
        </div>
        <script src="/js/common/jquery-2.2.4.min.js"></script>
        <script src="/js/common/highlight.min.js"></script>
        <script src="/js/aside-nav.js"></script>
        <script>
            // baidu 统计
            var _hmt = _hmt || [];
            (function() {
                var hm = document.createElement("script");
                hm.src = "//hm.baidu.com/hm.js?146fe495fee020bf0e4dd701aa73965f";
                var s = document.getElementsByTagName("script")[0]; 
                s.parentNode.insertBefore(hm, s);
            })();
            // highlight
            hljs.initHighlightingOnLoad({useBR: true});
            $(document).ready(function() {
                $('pre code').each(function(i, block) {
                    hljs.highlightBlock(block);
                });

                // http2
                var img = new Image();
                img.src = 'https://www.h2statistics.ml/';
            });
        </script>
    </body>
</html>
