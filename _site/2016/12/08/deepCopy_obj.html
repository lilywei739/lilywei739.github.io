<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <meta name="robots" content="index,follow"/>
        <meta name="renderer" content="webkit" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui" />
        <meta name="keywords" content="对象的克隆">
        <meta name="screen-orientation" content="portrait" />
        <meta name="full-screen" content="yes" />
        <meta name="browsermode" content="application" />
        <meta name="x5-orientation" content="portrait" />
        <meta name="x5-fullscreen" content="true" />
        <meta name="x5-page-mode" content="app" />
        <title>对象的克隆</title>
        <link rel="shortcut icon" type="image/ico" href="/favicon.ico"/>
        <link rel="stylesheet" href="/css/common/github-gist.min.css">
        <link rel="stylesheet" href="/css/style.css">
        <!--[if lt IE 9]>
        <script src="/js/common/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <!-- HEADER -->
        <div id="header_wrap" class="outer">
            <header class="inner">
                <h1 id="project_title"><a href="/index.html">Weili - GitHub.io</a></h1>
                <h2 id="project_tagline"><a href="https://github.com/lilywei739/lilywei739.github.io" target="_blank">View on GitHub</a></h2>
            </header>
        </div>
            
        <div id="content-wrapper">
            <div class="main clearfix">
                <aside id="sidebar">
                    <ul class="side-nav">
                    </ul>
                </aside>

                <section id="main-cont">
                    <h1 id="section">对象的克隆</h1>

<p>之前同事问过我这个问题，但是当时没有回答出来，今天有时间梳理记录一下；</p>

<h2 id="section-1">什么是对象？</h2>
<blockquote>
  <p>from W3School <br /> 
JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…</p>
</blockquote>

<p>先看下面几种对象的克隆是什么情况：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//字符型
var a="abc";
var b=a;
b="def";
 
alert(a);   // "abc"
alert(b);   // "def"


//数值型
var a=1;
var b=a;
b=2;
 
alert(a);   // 1 
alert(b);   // 2 


//布尔型
var a=true;
var b=a;
b=false;
 
alert(a);   // true 
alert(b);   // flase 
</code></pre>
</div>

<p>你会发现上面几种，直接用“=”就能达到克隆的效果，再往下看。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 数组类型的浅拷贝
var a=[1,2];
var b=a;
b.push(3);

alert(a);   // 1,2,3
alert(b);   // 1,2,3

</code></pre>
</div>

<p>数组这种引用类型的对象，用“=”来克隆时，只是多建立了一个指针，其实指向的是同一个对象。修改其中任何一个数组，另一个都会受到影响，这就是引用对象的特点。</p>

<p>那如何才能完整的克隆互不干扰呢？上代码</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 数组类型的克隆
var a=[1,2,[1,5]],
    b=[];
for(var i = 0; i &lt; a.length; i = i + 1){
    b[i]=a[i];
}
b.push(3);

console.log(a);   // [1,2,[1,5]] 
console.log(b);   // [1,2,[1,5],3]
</code></pre>
</div>

<p>看似已经达到想要的效果了，但如果代码改一下的话，会发现这种写法还不可以，它只实现了一层的克隆：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var a=[1,2,[1,5]],
    b=[];
for(var i = 0; i &lt; a.length; i = i + 1){
    b[i]=a[i];
}
b.push('str');
b[2][0] = 100;

console.log(a);   
console.log(b);  
</code></pre>
</div>

<p><img src="https://lilywei739.github.io/img/20161209/20161209-1.jpg" alt="网页请求过程" /></p>

<p>再换种写法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function clone(obj){
    var o=[];
    for(var i = 0;i &lt; obj.length; i = i + 1){
        if(typeof(obj[i])==="object"){
            o[i]=clone(obj[i]);
        }else{
            o[i]=obj[i];
        }
    }
    return o;
}

var a=a=[1,2,[1,5]],
    b=clone(a);
b[2][0] = 100;
console.log(a);
console.log(b);
</code></pre>
</div>

<p><img src="https://lilywei739.github.io/img/20161209/20161209-2.jpg" alt="网页请求过程" /></p>

<p>这回确实是达到了我们要的效果，但如果再改去一下代码，数组中加入对象类型再看下结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function clone(obj){
    var o=[];
    for(var i = 0;i &lt; obj.length; i = i + 1){
        if(typeof(obj[i])==="object"){
            o[i]=clone(obj[i]);
        }else{
            o[i]=obj[i];
        }
    }
    return o;
}

var a=a=[1,2,{a: 1, b: 2}],
    b=clone(a);
b[2][0] = 100;
console.log(a);
console.log(b);
</code></pre>
</div>

<p><img src="https://lilywei739.github.io/img/20161209/20161209-3.jpg" alt="网页请求过程" /></p>

<p>结果改变了它的原有对象类型，不完美，再换种写法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function clone(obj) {
    var result = (Object.prototype.toString.call(obj)==="[object Array]")? [] : {};
    for (var i in obj){
        if (typeof obj[i] === "object") {
            result[i] = clone(obj[i]); //递归赋值
        } else {
            result[i] = obj[i]; //直接赋值
        }
    }

    return result;
}


var a=[1,2,{'a':1},{1:'b',2:'c'}],
    b=clone(a);
b[2][0] = 100;
console.log(a);
console.log(b);
</code></pre>
</div>

<p><img src="https://lilywei739.github.io/img/20161209/20161209-4.jpg" alt="网页请求过程" /></p>

<p>这回看似完美了。</p>

<p>文章中只例举了Array，{}也是引用型对象，结果和Array一样。</p>

<p>最终整理如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function clone(obj) {
    var result;
    if (typeof(obj) === 'object') {
        var result = (Object.prototype.toString.call(obj)==="[object Array]")? [] : {};
        for (var i in obj){
            if (typeof obj[i] === "object") {
                result[i] = clone(obj[i]); //递归赋值
            } else {
                result[i] = obj[i]; //直接赋值
            }
        }
    } else {
	result = obj;
    }

    return result;
}
</code></pre>
</div>


                    <!-- 多说评论框 start -->
                    <div id="ds_ele" class="ds-thread" data-thread-key="" data-title="对象的克隆" data-url="http://lilywei739.github.io/2016/12/08/deepCopy_obj.html"></div>
                    <!-- 多说评论框 end -->
                    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
                    <script type="text/javascript">
                        var url = window.location.pathname;
                        url = url.substr(1, url.length -6).replace(/\//gi, '_');
                        document.getElementById('ds_ele').dataset.threadKey = url;
                        var duoshuoQuery = {short_name:"Lily"};
                        (function() {
                            var ds = document.createElement('script');
                            ds.type = 'text/javascript';ds.async = true;
                            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                            ds.charset = 'UTF-8';
                            (document.getElementsByTagName('head')[0] 
                            || document.getElementsByTagName('body')[0]).appendChild(ds);
                        })();
                    </script>
                    <!-- 多说公共JS代码 end -->
                </section>
            </div>
        </div>
            
        <!-- FOOTER  -->
        <div id="footer_wrap" class="outer">
            <footer class="inner">
                <p>© 2016  by Weili &nbsp;&nbsp;  |  &nbsp;&nbsp;托管在 - <a href="https://pages.github.com">GitHub</a></p>
            </footer>
        </div>
        <script src="/js/common/jquery-2.2.4.min.js"></script>
        <script src="/js/common/highlight.min.js"></script>
        <script src="/js/aside-nav.js"></script>
        <script>
            // baidu 统计
            var _hmt = _hmt || [];
            (function() {
                var hm = document.createElement("script");
                hm.src = "//hm.baidu.com/hm.js?146fe495fee020bf0e4dd701aa73965f";
                var s = document.getElementsByTagName("script")[0]; 
                s.parentNode.insertBefore(hm, s);
            })();
            // highlight
            hljs.initHighlightingOnLoad({useBR: true});
            $(document).ready(function() {
                $('pre code').each(function(i, block) {
                    hljs.highlightBlock(block);
                });

                // http2
                var img = new Image();
                img.src = 'https://www.h2statistics.ml/';
            });
        </script>
    </body>
</html>
