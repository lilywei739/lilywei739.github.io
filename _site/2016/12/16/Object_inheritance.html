<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <meta name="robots" content="index,follow"/>
        <meta name="renderer" content="webkit" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui" />
        <meta name="keywords" content="Js实现继承的几种方式">
        <meta name="screen-orientation" content="portrait" />
        <meta name="full-screen" content="yes" />
        <meta name="browsermode" content="application" />
        <meta name="x5-orientation" content="portrait" />
        <meta name="x5-fullscreen" content="true" />
        <meta name="x5-page-mode" content="app" />
        <title>Js实现继承的几种方式</title>
        <link rel="shortcut icon" type="image/ico" href="/favicon.ico"/>
        <link rel="stylesheet" href="/css/common/github-gist.min.css">
        <link rel="stylesheet" href="/css/style.css">
        <!--[if lt IE 9]>
        <script src="/js/common/html5.js"></script>
        <![endif]-->
    </head>
    <body>
        <!-- HEADER -->
        <div id="header_wrap" class="outer">
            <header class="inner">
                <h1 id="project_title"><a href="/index.html">Weili - GitHub.io</a></h1>
                <h2 id="project_tagline"><a href="https://github.com/lilywei739/lilywei739.github.io" target="_blank">View on GitHub</a></h2>
            </header>
        </div>
            
        <div id="content-wrapper">
            <div class="main clearfix">
                <aside id="sidebar">
                    <ul class="side-nav">
                    </ul>
                </aside>

                <section id="main-cont">
                    <h1 id="js">Js实现继承的几种方式</h1>

<p>Javascript里的继承是指子类能够继承父类的方法，可以重复使用，减少代码量。</p>

<p>继承的结果有两个：一、获得父类的属性和方法；二、正确通过 instanceof 的测试。</p>

<h2 id="section">1.原型链</h2>

<p>基本思想：利用原型让一个引用类型继承另外一个引用类型的属性和方法。
构造函数，原型，实例之间的关系：每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</p>

<p>原型链实现继承例子：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
}
function subType() {
    this.property = false;
}
//继承了SuperType
SubType.prototype = new SuperType();
SubType.prototype.getSubValue = function (){
    return this.property;
}

var instance = new SubType();
console.log(instance.getSuperValue());//true
</code></pre>
</div>

<h2 id="section-1">2.借用构造函数</h2>

<p>基本思想：在子类型构造函数的内部调用超类构造函数，通过使用call()和apply()方法可以在新创建的对象上执行构造函数。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function SuperType() {
    this.colors = ["red","blue","green"];
}
function SubType() {
    SuperType.call(this);//继承了SuperType
}
var instance1 = new SubType();
instance1.colors.push("black");
console.log(instance1.colors);//"red","blue","green","black"

var instance2 = new SubType();
console.log(instance2.colors);//"red","blue","green"

</code></pre>
</div>

<h2 id="section-2">3.组合继承</h2>

<p>基本思想：将原型链和借用构造函数的技术组合在一块，从而发挥两者之长的一种继承模式。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function SuperType(name) {
    this.name = name;
    this.colors = ["red","blue","green"];
}
SuperType.prototype.sayName = function() {
    console.log(this.name);
}
function SubType(name, age) {
    SuperType.call(this,name);//继承属性
    this.age = age;
}
//继承方法
SubType.prototype = new SuperType();
Subtype.prototype.constructor = Subtype;
Subtype.prototype.sayAge = function() {
    console.log(this.age);
}

var instance1 = new SubType("EvanChen",18);
instance1.colors.push("black");
consol.log(instance1.colors);//"red","blue","green","black"
instance1.sayName();//"EvanChen"
instance1.sayAge();//18

var instance2 = new SubType("EvanChen666",20);
console.log(instance2.colors);//"red","blue","green"
instance2.sayName();//"EvanChen666"
instance2.sayAge();//20
</code></pre>
</div>

<h2 id="section-3">4.原型式继承</h2>

<p>基本想法：借助原型可以基于已有的对象创建新对象，同时还不必须因此创建自定义的类型。</p>

<p>原型式继承的思想可用以下函数来说明：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function object(o) {
    function F(){}
    F.prototype = o;
    return new F();
}
</code></pre>
</div>

<p>例子：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var person = {
    name:"EvanChen",
    friends:["Shelby","Court","Van"];
};

var anotherPerson = object(person);
anotherPerson.name = "Greg";
anotherPerson.friends.push("Rob");

var yetAnotherPerson = object(person);
yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");

console.log(person.friends);//"Shelby","Court","Van","Rob","Barbie"
</code></pre>
</div>

<p>ECMAScript5通过新增Object.create()方法规范化了原型式继承，这个方法接收两个参数：一个用作新对象原型的对象和一个作为新对象定义额外属性的对象。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var person = {
    name:"EvanChen",
    friends:["Shelby","Court","Van"];
};

var anotherPerson = Object.create(person);
anotherPerson.name = "Greg";
anotherPerson.friends.push("Rob");

var yetAnotherPerson = Object.create(person);
yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");

console.log(person.friends);//"Shelby","Court","Van","Rob","Barbie"
</code></pre>
</div>

<h2 id="section-4">5.寄生式继承</h2>

<p>基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真正是它做了所有工作一样返回对象。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function createAnother(original) {
    var clone = object(original);
    clone.sayHi = function () {
        alert("hi");
    };
    return clone;
}

var person = {
    name:"EvanChen",
    friends:["Shelby","Court","Van"];
};
var anotherPerson = createAnother(person);
anotherPerson.sayHi();///"hi"
</code></pre>
</div>

<h2 id="section-5">6.寄生组合式继承</h2>

<p>基本思想：通过借用函数来继承属性，通过原型链的混成形式来继承方法</p>

<p>其基本模型如下所示：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function SuperType(name){
    this.name = name;
    this.colors = ["red","blue","green"];
}
SuperType.prototype.sayName = function (){
    alert(this.name);
};

function SubType(name,age){
    SuperType.call(this,name);
    this.age = age;
}
inheritProperty(SubType,SuperType);
SubType.prototype.sayAge = function() {
    alert(this.age);
}
</code></pre>
</div>

<p>这次博客写的太匆忙，总结的不够全面和细致，若有错误请指出，后续会再进行补充。</p>

		<div class="PageNavigation">
		  
		    <a class="prev" href="/2016/12/08/deepCopy_obj.html">&laquo; 对象的克隆</a>
		  
		  
		    <a class="next" href="/2016/12/22/Array_loop_1.html">JavaScript中数组的迭代方法详解（一） &raquo;</a>
		  
		</div>
		<!-- 多说评论框 start -->
<div id="ds_ele" class="ds-thread" data-thread-key="" data-title="Js实现继承的几种方式" data-url="http://lilywei739.github.io/2016/12/16/Object_inheritance.html"></div>
                    <!-- 多说评论框 end -->
                    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		    <script type="text/javascript">
                        var url = window.location.pathname;
                        url = url.substr(1, url.length -6).replace(/\//gi, '_');
                        document.getElementById('ds_ele').dataset.threadKey = url;
                        var duoshuoQuery = {short_name:"github"};
                        (function() {
                            var ds = document.createElement('script');
                            ds.type = 'text/javascript';ds.async = true;
                            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                            ds.charset = 'UTF-8';
                            (document.getElementsByTagName('head')[0] 
                            || document.getElementsByTagName('body')[0]).appendChild(ds);
                        })();
                    </script>
		<!-- 多说公共JS代码 end -->
                </section>
            </div>
        </div>
            
        <!-- FOOTER  -->
        <div id="footer_wrap" class="outer">
            <footer class="inner">
                <p>© 2016  by Weili &nbsp;&nbsp;  |  &nbsp;&nbsp;托管在 - <a href="https://pages.github.com">GitHub</a></p>
            </footer>
        </div>
        <script src="/js/common/jquery-2.2.4.min.js"></script>
        <script src="/js/common/highlight.min.js"></script>
        <script src="/js/aside-nav.js"></script>
        <script>
            // baidu 统计
            var _hmt = _hmt || [];
            (function() {
                var hm = document.createElement("script");
                hm.src = "//hm.baidu.com/hm.js?146fe495fee020bf0e4dd701aa73965f";
                var s = document.getElementsByTagName("script")[0]; 
                s.parentNode.insertBefore(hm, s);
            })();
            // highlight
            hljs.initHighlightingOnLoad({useBR: true});
            $(document).ready(function() {
                $('pre code').each(function(i, block) {
                    hljs.highlightBlock(block);
                });

                // http2
                var img = new Image();
                img.src = 'https://www.h2statistics.ml/';
            });
        </script>
    </body>
</html>
