<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.7.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2018-03-21T17:12:32+08:00</updated><id>http://localhost:4000/</id><title type="html">Weili’s Blog</title><subtitle>Weili's blog
</subtitle><author><name>weili</name></author><entry><title type="html">JS基础–高级算法–贪心算法</title><link href="http://localhost:4000/js/2018/03/16/AdvancedAlgorithms-2.html" rel="alternate" type="text/html" title="JS基础--高级算法--贪心算法" /><published>2018-03-16T00:00:00+08:00</published><updated>2018-03-16T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/03/16/AdvancedAlgorithms-2</id><content type="html" xml:base="http://localhost:4000/js/2018/03/16/AdvancedAlgorithms-2.html">&lt;h1 id=&quot;高级算法贪心算法&quot;&gt;高级算法–贪心算法&lt;/h1&gt;

&lt;p&gt;贪心算法总是会选择当下的最优解，而不去考虑这一次的选择会不会对未来的选择造成影响，目的是得到当前最优解。&lt;/p&gt;

&lt;h2 id=&quot;使用贪心算法的经典案例&quot;&gt;使用贪心算法的经典案例&lt;/h2&gt;

&lt;h3 id=&quot;找零问题&quot;&gt;找零问题&lt;/h3&gt;

&lt;p&gt;从商店购买了一些商品，找零 63 美分，店员要 怎样给你这些零钱呢?如果店员根据贪心算法来找零的话，他会给你两个 25 美分、一个 10 美分和三个 1 美分。在没有使用 50 美分的情况下这是最少的硬币数量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function makeChange(origAmt, coins) {
    var remainAmt = 0;

    if (origAmt % .25 &amp;lt; origAmt) {
       coins[3] = parseInt(origAmt / .25);
       remainAmt = origAmt % .25;
       origAmt = remainAmt;
    }

    if (origAmt % .1 &amp;lt; origAmt) {
       coins[2] = parseInt(origAmt / .1);
       remainAmt = origAmt % .1;
       origAmt = remainAmt;
    }

    if (origAmt % .05 &amp;lt; origAmt) {
       coins[1] = parseInt(origAmt / .05);
       remainAmt = origAmt % .05;
       origAmt = remainAmt;
    }

    coins[0] = parseInt(origAmt / .01);
}


function showChange(coins) {
    if (coins[3] &amp;gt; 0) {
        document.write(&quot;25 美分的数量 - &quot; + coins[3] + &quot; - &quot; + coins[3] * .25); 
    }

    if (coins[2] &amp;gt; 0) {
        document.write(&quot;10 美分的数量 - &quot; + coins[2] + &quot; - &quot; + coins[2] * .10);
    }

    if (coins[1] &amp;gt; 0) {
        document.write(&quot;5 美分的数量 - &quot; + coins[1] + &quot; - &quot; + coins[1] * .05);
    }

    if (coins[0] &amp;gt; 0) {
        document.write(&quot;1 美分的数量 - &quot; + coins[0] + &quot; - &quot; + coins[0] * .01);
    } 
}

var origAmt = .63;
var coins = [];
makeChange(origAmt, coins);
showChange(coins);

========================
结果如下：

25美分的数量 - 2 - 0.5 
10美分的数量 - 1 - 0.1 
1美分的数量 - 3 - 0.03
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;makeChange() 函数从面值最高的 25 美分硬币开始，一直尝试使用这个面值去找零。总共 用到的 25 美分硬币数量会存储在 coins 数组中。如果剩余金额不到 25 美分，算法将会尝 试使用 10 美分硬币去找零，用到的 10 美分硬币总总数也会存储在 coins 数组里。接下来 算法会以相同的方式使用 5 美分和 1 美分来找零。&lt;/p&gt;

&lt;p&gt;在所有面额都可用且数量不限的情况下，这种方案总能找到最优解。如果某种面额不可用，比如 5 美分，则会得到一个次优解。&lt;/p&gt;

&lt;h3 id=&quot;背包问题之贪心算法解决方案&quot;&gt;背包问题之贪心算法解决方案&lt;/h3&gt;

&lt;p&gt;如果用贪心算法处理背包问题，它有一个前提放入背包的物品从本质上说是连续的，那 么可以简单地通过物品的单价除以单位体积来确定物品的价值，先装价值最高的物品直到该物品装完或者将背包装满，接着装价值次高的物品，直到 这种物品也装完或将背包装满，以此类推。&lt;/p&gt;

&lt;p&gt;思路是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(1) 背包的容量为 W，物品的价格为 v，重量为 w。&lt;/li&gt;
  &lt;li&gt;(2) 根据 v/w 的比率对物品排序。&lt;/li&gt;
  &lt;li&gt;(3) 按比率的降序方式来考虑物品。&lt;/li&gt;
  &lt;li&gt;(4) 尽可能多地放入每个物品。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如给出了四个物品的重量、价格和比率&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;物品&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;B&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
      &lt;th&gt;D&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;价格&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;50&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;140&lt;/td&gt;
      &lt;td&gt;60&lt;/td&gt;
      &lt;td&gt;60&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;尺寸&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;20&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;比率&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function ksack(values, weights, capacity) {
    var load = 0;
    var i = 0;
    var w = 0;
    while (load &amp;lt; capacity &amp;amp;&amp;amp; i &amp;lt; 4) {
       if (weights[i] &amp;lt;= (capacity-load)) {
          w += values[i];
          load += weights[i];
       } else {
       
          var r = (capacity-load)/weights[i];
          w += r * values[i];
          load += weights[i];
       } 
       ++i;
    }
    return w;
}

var items = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;];
var values = [50, 140, 60, 60];
var weights = [5, 20, 10, 12];
var capacity = 30;

document.write(ksack(values, weights, capacity)); // 显示 220
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">高级算法–贪心算法 贪心算法总是会选择当下的最优解，而不去考虑这一次的选择会不会对未来的选择造成影响，目的是得到当前最优解。 使用贪心算法的经典案例 找零问题 从商店购买了一些商品，找零 63 美分，店员要 怎样给你这些零钱呢?如果店员根据贪心算法来找零的话，他会给你两个 25 美分、一个 10 美分和三个 1 美分。在没有使用 50 美分的情况下这是最少的硬币数量。 function makeChange(origAmt, coins) { var remainAmt = 0; if (origAmt % .25 &amp;lt; origAmt) { coins[3] = parseInt(origAmt / .25); remainAmt = origAmt % .25; origAmt = remainAmt; } if (origAmt % .1 &amp;lt; origAmt) { coins[2] = parseInt(origAmt / .1); remainAmt = origAmt % .1; origAmt = remainAmt; } if (origAmt % .05 &amp;lt; origAmt) { coins[1] = parseInt(origAmt / .05); remainAmt = origAmt % .05; origAmt = remainAmt; } coins[0] = parseInt(origAmt / .01); } function showChange(coins) { if (coins[3] &amp;gt; 0) { document.write(&quot;25 美分的数量 - &quot; + coins[3] + &quot; - &quot; + coins[3] * .25); } if (coins[2] &amp;gt; 0) { document.write(&quot;10 美分的数量 - &quot; + coins[2] + &quot; - &quot; + coins[2] * .10); } if (coins[1] &amp;gt; 0) { document.write(&quot;5 美分的数量 - &quot; + coins[1] + &quot; - &quot; + coins[1] * .05); } if (coins[0] &amp;gt; 0) { document.write(&quot;1 美分的数量 - &quot; + coins[0] + &quot; - &quot; + coins[0] * .01); } } var origAmt = .63; var coins = []; makeChange(origAmt, coins); showChange(coins); ======================== 结果如下： 25美分的数量 - 2 - 0.5 10美分的数量 - 1 - 0.1 1美分的数量 - 3 - 0.03 makeChange() 函数从面值最高的 25 美分硬币开始，一直尝试使用这个面值去找零。总共 用到的 25 美分硬币数量会存储在 coins 数组中。如果剩余金额不到 25 美分，算法将会尝 试使用 10 美分硬币去找零，用到的 10 美分硬币总总数也会存储在 coins 数组里。接下来 算法会以相同的方式使用 5 美分和 1 美分来找零。 在所有面额都可用且数量不限的情况下，这种方案总能找到最优解。如果某种面额不可用，比如 5 美分，则会得到一个次优解。 背包问题之贪心算法解决方案 如果用贪心算法处理背包问题，它有一个前提放入背包的物品从本质上说是连续的，那 么可以简单地通过物品的单价除以单位体积来确定物品的价值，先装价值最高的物品直到该物品装完或者将背包装满，接着装价值次高的物品，直到 这种物品也装完或将背包装满，以此类推。 思路是 (1) 背包的容量为 W，物品的价格为 v，重量为 w。 (2) 根据 v/w 的比率对物品排序。 (3) 按比率的降序方式来考虑物品。 (4) 尽可能多地放入每个物品。 如给出了四个物品的重量、价格和比率 物品 A B C D 价格 50 140 60 60 尺寸 5 20 10 12 比率 10 7 6 5 function ksack(values, weights, capacity) { var load = 0; var i = 0; var w = 0; while (load &amp;lt; capacity &amp;amp;&amp;amp; i &amp;lt; 4) { if (weights[i] &amp;lt;= (capacity-load)) { w += values[i]; load += weights[i]; } else { var r = (capacity-load)/weights[i]; w += r * values[i]; load += weights[i]; } ++i; } return w; } var items = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]; var values = [50, 140, 60, 60]; var weights = [5, 20, 10, 12]; var capacity = 30; document.write(ksack(values, weights, capacity)); // 显示 220</summary></entry><entry><title type="html">JS基础–高级算法–动态规划</title><link href="http://localhost:4000/js/2018/03/09/AdvancedAlgorithms-1.html" rel="alternate" type="text/html" title="JS基础--高级算法--动态规划" /><published>2018-03-09T00:00:00+08:00</published><updated>2018-03-09T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/03/09/AdvancedAlgorithms-1</id><content type="html" xml:base="http://localhost:4000/js/2018/03/09/AdvancedAlgorithms-1.html">&lt;h1 id=&quot;高级算法动态规划&quot;&gt;高级算法–动态规划&lt;/h1&gt;

&lt;h2 id=&quot;动态规则与递归的关系与区别&quot;&gt;动态规则与递归的关系与区别&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;动态规划有时被认为是一种与递归相反的技术。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整 个问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个 整体解决方案，从而解决掉整个大问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;递归去解决问题虽然简洁，但效率不高,许多使用递归去解决的编程问题，可以重写为使用动态规划的技巧去解决&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;动态规划方案&quot;&gt;动态规划方案&lt;/h2&gt;

&lt;p&gt;动态规划方案通常会使用一个数组来建立一张表，用于存放被分解成众多子问题的解。当算法执行完 毕，最终的解将会在这个表中很明显的地方被找到&lt;/p&gt;

&lt;h2 id=&quot;使用动态规划方案能做点什么&quot;&gt;使用动态规划方案能做点什么？&lt;/h2&gt;

&lt;h3 id=&quot;计算斐波那契数列&quot;&gt;计算斐波那契数列&lt;/h3&gt;

&lt;p&gt;斐波那契数列可以定义为以下序列:&lt;/p&gt;

&lt;p&gt;0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …&lt;/p&gt;

&lt;p&gt;该序列是由前两项数值相加而成的&lt;/p&gt;

&lt;p&gt;递归的实现方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function recurFib(n) {
    if (n &amp;lt; 2) {
        return n; 
    } else {
        
        return recurFib(n-1) + recurFib(n-2);
    } 
}
document.write(recurFib(10)); // 显示 55
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个计算过程当中，有太多值在递归调用中被重新计算,这也是递归方法效率低下的原因。&lt;/p&gt;

&lt;p&gt;再看下动态规则的实现方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function dynFib(n) {
    var val = [];
    for (var i = 0; i &amp;lt;= n; ++i) {
        val[i] = 0; 
    }
    if (n == 1 || n == 2) {
        return 1;
    } else {
        val[1] = 1;
        val[2] = 2;
        for (var i = 3; i &amp;lt;= n; ++i) {
            val[i] = val[i-1] + val[i-2];
        }
        return val[n-1];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个数组 val 中保存了中间结果。如果要计算的斐波那契数是 1 或者 2，那么 if 语 句会返回 1。否则，数值 1 和 2 将被保存在 val 数组中 1 和 2 的位置。循环将会从 3 到输 入的参数之间进行遍历，将数组的每个元素赋值为前两个元素之和，循环结束，数组的最 后一个元素值即为最终计算得到的斐波那契数值，这个数值也将作为函数的返回值。&lt;/p&gt;

&lt;p&gt;斐波那契数列在数组 val 中的排列顺序如下:&lt;/p&gt;

&lt;p&gt;val[0] = 0 val[1] = 1 val[2] = 2 val[3] = 3 val[4] = 5 val[5] = 8 val[6] = 13&lt;/p&gt;

&lt;h3 id=&quot;寻找最长公共子串&quot;&gt;寻找最长公共子串&lt;/h3&gt;

&lt;p&gt;用动态规划去寻找两个字符串的最长公共子串。例如，在单词 “raven”和“havoc”中，最长的公共子串是“av”。&lt;/p&gt;

&lt;p&gt;原理：&lt;/p&gt;

&lt;p&gt;使用一个二维数组存储两个字符串相同 位置的字符比较结果。初始化时，该数组的每一个元素被设置为 0。每次在这两个数组的 相同位置发现了匹配，就将数组对应行和列的元素加 1，否则保持为 0。按照这种方式，一个变量会持续记录下找到了多少个匹配项。当算法执行完毕时，这个变 量会结合一个索引变量来获得最长公共子串。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function lcs(word1, word2) {
     var max = 0;
     var index = 0;
     var lcsarr = new Array(word1.length + 1);
     for (var i = 0; i &amp;lt;= word1.length + 1; ++i) {
         lcsarr[i] = new Array(word2.length + 1);
         for (var j = 0; j &amp;lt;= word2.length + 1; ++j) {
            lcsarr[i][j] = 0;
        }
    }

    //上面这一部分初始化了两个变量以及一个二维数组。多数语言对二维数组的声明都很 简单，但在 JavaScript 中需要很费劲地在一个数组中定义另一个数组，这样才能声明一个 二维数组。以下代码片段中的最后一个 for 循环会对这个数组进行初始化，


    for (var i = 0; i &amp;lt;= word1.length; ++i) {
       for (var j = 0; j &amp;lt;= word2.length; ++j) {
          if (i == 0 || j == 0) {
             lcsarr[i][j] = 0;
          } else {
              if (word1[i - 1] == word2[j - 1]) {
                lcsarr[i][j] = lcsarr[i - 1][j - 1] + 1;
              } else {
                lcsarr[i][j] = 0;
              } 
          }
          if (max &amp;lt; lcsarr[i][j]) {
             max = lcsarr[i][j];
             index = i;
          } 
        }
    }

    //这一部分构建了用于保存字符匹配记录的表。数组的第一个元素总是被设置为 0。如果两 个字符串相应位置的字符进行了匹配，当前数组元素的值将被设置为前一次循环中数组元 素保存的值加 1。比如，如果两个字符串 &quot;back&quot; 和 &quot;cace&quot;，当算法运行到第二个字符处 时，那么数值 1 将被保存到当前元素中，因为前一个元素并不匹配，0 被保存在那个元素 中(0+1)。接下来算法移动到下一个位置，由于此时两个字符仍被匹配，当前数组元素将 被设置为 2(1+1)。由于两个字符串的最后一个字符不匹配，所以最长公共子串的长度是 2。最后，如果变量 max 的值比现在存储在数组中的当前元素要小，max 的值将被赋值给这 个元素，变量 index 的值将被设置为 i 的当前值。这两个变量将在函数的最后一部分用于 确定从哪里开始获取最长公共子串。

    var str = &quot;&quot;;
    if (max == 0) {
       return &quot;&quot;;
    } else {
        for (var i = index - max; i &amp;lt;= max; ++i) {
          str += word2[i];
        }
        return str; 
    }

    //这一部分代码用于确认从哪里开始构建这个最长公共子串。以变量 index 减去变量 max 的差值作为起始点，以变量 max 的值作为终点:
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;背包问题递归解决方案&quot;&gt;背包问题:递归解决方案&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function max(a, b) {
    return (a &amp;gt; b) ? a : b;
}

function knapsack(capacity, size, value, n) {
    if (n == 0 || capacity == 0) {
        return 0; 
    }
    if (size[n - 1] &amp;gt; capacity) {
       return knapsack(capacity, size, value, n - 1);
    } else {
       return max(value[n - 1] +
          knapsack(capacity - size[n - 1], size, value, n - 1),
          knapsack(capacity, size, value, n - 1));
    } 
}

var value = [4, 5, 10, 11, 13];
var size = [3, 4, 7, 8, 9];
var capacity = 16;
var n = 5;
document.write(knapsack(capacity, size, value, n));

//结果：23
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;背包问题动态规划方案&quot;&gt;背包问题:动态规划方案&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function max(a, b) {
    return (a &amp;gt; b) ? a : b;
}
function dKnapsack(capacity, size, value, n) {
  var K = [];
  for (var i = 0; i &amp;lt;= capacity + 1; i++) {
      K[i] = [];
  }
  for (var i = 0; i &amp;lt;= n; i++) {
     for (var w = 0; w &amp;lt;= capacity; w++) {
        if (i == 0 || w == 0) {
            K[i][w] = 0; 
        } else if (size[i - 1] &amp;lt;= w) {
           K[i][w] = max(value[i - 1] + K[i-1][w-size[i-1]], K[i-1][w]);
        } else {
           K[i][w] = K[i - 1][w];
        }
        document.write(K[i][w] + &quot; &quot;);
     }
  }
  return K[n][capacity];
}
var value = [4, 5, 10, 11, 13];
var size = [3, 4, 7, 8, 9];
var capacity = 16;
var n = 5;
document.write(dKnapsack(capacity, size, value, n));

结果：

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 
0 0 0 4 5 5 5 9 9 9 9 9 9 9 9 9 9
0 0 0 4 5 5 5 10 10 10 14 15 15 15 19 19 19 
0 0 0 4 5 5 5 10 11 11 14 15 16 16 19 21 21 
0 0 0 4 5 5 5 10 11 13 14 15 17 18 19 21 23 
23
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">高级算法–动态规划 动态规则与递归的关系与区别 动态规划有时被认为是一种与递归相反的技术。 递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整 个问题。 动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个 整体解决方案，从而解决掉整个大问题。 递归去解决问题虽然简洁，但效率不高,许多使用递归去解决的编程问题，可以重写为使用动态规划的技巧去解决 动态规划方案 动态规划方案通常会使用一个数组来建立一张表，用于存放被分解成众多子问题的解。当算法执行完 毕，最终的解将会在这个表中很明显的地方被找到 使用动态规划方案能做点什么？ 计算斐波那契数列 斐波那契数列可以定义为以下序列: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, … 该序列是由前两项数值相加而成的 递归的实现方式： function recurFib(n) { if (n &amp;lt; 2) { return n; } else { return recurFib(n-1) + recurFib(n-2); } } document.write(recurFib(10)); // 显示 55 在这个计算过程当中，有太多值在递归调用中被重新计算,这也是递归方法效率低下的原因。 再看下动态规则的实现方法： function dynFib(n) { var val = []; for (var i = 0; i &amp;lt;= n; ++i) { val[i] = 0; } if (n == 1 || n == 2) { return 1; } else { val[1] = 1; val[2] = 2; for (var i = 3; i &amp;lt;= n; ++i) { val[i] = val[i-1] + val[i-2]; } return val[n-1]; } } 在这个数组 val 中保存了中间结果。如果要计算的斐波那契数是 1 或者 2，那么 if 语 句会返回 1。否则，数值 1 和 2 将被保存在 val 数组中 1 和 2 的位置。循环将会从 3 到输 入的参数之间进行遍历，将数组的每个元素赋值为前两个元素之和，循环结束，数组的最 后一个元素值即为最终计算得到的斐波那契数值，这个数值也将作为函数的返回值。 斐波那契数列在数组 val 中的排列顺序如下: val[0] = 0 val[1] = 1 val[2] = 2 val[3] = 3 val[4] = 5 val[5] = 8 val[6] = 13 寻找最长公共子串 用动态规划去寻找两个字符串的最长公共子串。例如，在单词 “raven”和“havoc”中，最长的公共子串是“av”。 原理： 使用一个二维数组存储两个字符串相同 位置的字符比较结果。初始化时，该数组的每一个元素被设置为 0。每次在这两个数组的 相同位置发现了匹配，就将数组对应行和列的元素加 1，否则保持为 0。按照这种方式，一个变量会持续记录下找到了多少个匹配项。当算法执行完毕时，这个变 量会结合一个索引变量来获得最长公共子串。 function lcs(word1, word2) { var max = 0; var index = 0; var lcsarr = new Array(word1.length + 1); for (var i = 0; i &amp;lt;= word1.length + 1; ++i) { lcsarr[i] = new Array(word2.length + 1); for (var j = 0; j &amp;lt;= word2.length + 1; ++j) { lcsarr[i][j] = 0; } } //上面这一部分初始化了两个变量以及一个二维数组。多数语言对二维数组的声明都很 简单，但在 JavaScript 中需要很费劲地在一个数组中定义另一个数组，这样才能声明一个 二维数组。以下代码片段中的最后一个 for 循环会对这个数组进行初始化， for (var i = 0; i &amp;lt;= word1.length; ++i) { for (var j = 0; j &amp;lt;= word2.length; ++j) { if (i == 0 || j == 0) { lcsarr[i][j] = 0; } else { if (word1[i - 1] == word2[j - 1]) { lcsarr[i][j] = lcsarr[i - 1][j - 1] + 1; } else { lcsarr[i][j] = 0; } } if (max &amp;lt; lcsarr[i][j]) { max = lcsarr[i][j]; index = i; } } } //这一部分构建了用于保存字符匹配记录的表。数组的第一个元素总是被设置为 0。如果两 个字符串相应位置的字符进行了匹配，当前数组元素的值将被设置为前一次循环中数组元 素保存的值加 1。比如，如果两个字符串 &quot;back&quot; 和 &quot;cace&quot;，当算法运行到第二个字符处 时，那么数值 1 将被保存到当前元素中，因为前一个元素并不匹配，0 被保存在那个元素 中(0+1)。接下来算法移动到下一个位置，由于此时两个字符仍被匹配，当前数组元素将 被设置为 2(1+1)。由于两个字符串的最后一个字符不匹配，所以最长公共子串的长度是 2。最后，如果变量 max 的值比现在存储在数组中的当前元素要小，max 的值将被赋值给这 个元素，变量 index 的值将被设置为 i 的当前值。这两个变量将在函数的最后一部分用于 确定从哪里开始获取最长公共子串。 var str = &quot;&quot;; if (max == 0) { return &quot;&quot;; } else { for (var i = index - max; i &amp;lt;= max; ++i) { str += word2[i]; } return str; } //这一部分代码用于确认从哪里开始构建这个最长公共子串。以变量 index 减去变量 max 的差值作为起始点，以变量 max 的值作为终点: } 背包问题:递归解决方案 function max(a, b) { return (a &amp;gt; b) ? a : b; } function knapsack(capacity, size, value, n) { if (n == 0 || capacity == 0) { return 0; } if (size[n - 1] &amp;gt; capacity) { return knapsack(capacity, size, value, n - 1); } else { return max(value[n - 1] + knapsack(capacity - size[n - 1], size, value, n - 1), knapsack(capacity, size, value, n - 1)); } } var value = [4, 5, 10, 11, 13]; var size = [3, 4, 7, 8, 9]; var capacity = 16; var n = 5; document.write(knapsack(capacity, size, value, n)); //结果：23 背包问题:动态规划方案 function max(a, b) { return (a &amp;gt; b) ? a : b; } function dKnapsack(capacity, size, value, n) { var K = []; for (var i = 0; i &amp;lt;= capacity + 1; i++) { K[i] = []; } for (var i = 0; i &amp;lt;= n; i++) { for (var w = 0; w &amp;lt;= capacity; w++) { if (i == 0 || w == 0) { K[i][w] = 0; } else if (size[i - 1] &amp;lt;= w) { K[i][w] = max(value[i - 1] + K[i-1][w-size[i-1]], K[i-1][w]); } else { K[i][w] = K[i - 1][w]; } document.write(K[i][w] + &quot; &quot;); } } return K[n][capacity]; } var value = [4, 5, 10, 11, 13]; var size = [3, 4, 7, 8, 9]; var capacity = 16; var n = 5; document.write(dKnapsack(capacity, size, value, n)); 结果： 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 4 5 5 5 9 9 9 9 9 9 9 9 9 9 0 0 0 4 5 5 5 10 10 10 14 15 15 15 19 19 19 0 0 0 4 5 5 5 10 11 11 14 15 16 16 19 21 21 0 0 0 4 5 5 5 10 11 13 14 15 17 18 19 21 23 23</summary></entry><entry><title type="html">JS基础–检索算法</title><link href="http://localhost:4000/js/2018/03/02/jiansuo-1.html" rel="alternate" type="text/html" title="JS基础--检索算法" /><published>2018-03-02T00:00:00+08:00</published><updated>2018-03-02T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/03/02/jiansuo-1</id><content type="html" xml:base="http://localhost:4000/js/2018/03/02/jiansuo-1.html">&lt;h1 id=&quot;检索算法&quot;&gt;检索算法&lt;/h1&gt;

&lt;p&gt;本章介绍了数据检索的一个方面: 如何在列表中查找特定的值。&lt;/p&gt;

&lt;p&gt;在列表中查找数据有两种方式: &lt;strong&gt;顺序查找&lt;/strong&gt;和&lt;strong&gt;二分查找&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;顺序查找适用于元素随机排列的列表;&lt;/li&gt;
  &lt;li&gt;二分查找适用于元素已排序的列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;二分查找效率更高，但是你必须在进行查找之前 花费额外的时间将列表中的元素排序。&lt;/p&gt;

&lt;h2 id=&quot;顺序查找&quot;&gt;顺序查找&lt;/h2&gt;

&lt;p&gt;对于查找数据来说，最简单的方法就是从列表的第一个元素开始对列表元素逐个进行判 断，直到找到了想要的结果，或者直到列表结尾也没有找到。这种方法称为顺序查找，有 时也被称为线性查找。它属于暴力查找技巧的一种，在执行查找时可能会访问到数据结构 里的所有元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;顺序查找的实现：&lt;/strong&gt;
只要从列表的第一个元素开始循环，然后逐个与要查找的数据进 行比较。如果匹配到了，则结束查找。如果到了列表的结尾也没有匹配到，那么这个数据 就不存在于这个列表中。&lt;/p&gt;

&lt;p&gt;代码实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function seqSearch(arr, data) {
    for (var i = 0; i &amp;lt; arr.length; ++i) {
        if (arr[i] == data) {
            return i;
        }
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果在数组中找到了参数 data，返回所在的位置，如果没有找到要查找的数据，函数返回-1。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;seqSearch() 函数的执行速度比内置的 Array.indexof() 方法慢，这里仅用来演示 顺序查找是如何运行的。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;查找最小值和最大值&quot;&gt;查找最小值和最大值&lt;/h3&gt;

&lt;h4 id=&quot;查找最小值&quot;&gt;查找最小值&lt;/h4&gt;

&lt;p&gt;首先看看如何在数组中查找最小值，算法如下。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将数组第一个元素赋值给一个变量，把这个变量作为最小值。&lt;/li&gt;
  &lt;li&gt;开始遍历数组，从第二个元素开始依次同当前最小值进行比较。&lt;/li&gt;
  &lt;li&gt;如果当前元素数值小于当前最小值，则将当前元素设为新的最小值。&lt;/li&gt;
  &lt;li&gt;移动到下一个元素，并且重复步骤 3。&lt;/li&gt;
  &lt;li&gt;当程序结束时，这个变量中存储的就是最小值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码实现如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function findMin(arr) {
  var min = arr[0];
  for (var i = 1; i &amp;lt; arr.length; ++i) {
     if (arr[i] &amp;lt; min) {
        min = arr[i];
     } 
  }
  return min; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的关键部分，由于我们假设数组的第一个元素就是当前的最小值，所以这个函数 会从数组的第二个元素开始进行处理。&lt;/p&gt;

&lt;h4 id=&quot;查找最大值&quot;&gt;查找最大值&lt;/h4&gt;

&lt;p&gt;查找最大值和查找最小值的原理是一样的，只不过是先把数组的第一个元素设置为最大值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function findMax(arr) {
    var max = arr[0];
    for (var i = 1; i &amp;lt; arr.length; ++i) {
       if (arr[i] &amp;gt; max) {
          max = arr[i];
       } 
    }
    return max; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实例化个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var nums = [];
for (var i = 0; i &amp;lt; 100; ++i) {
  nums[i] = Math.floor(Math.random() * 101);
}

document.getElementById('box').innerHTML = nums;

var minValue = this.findMin(nums); 
var maxValue = this.findMax(nums); 

document.write(&quot;最小值是:&quot; + minValue + '&amp;lt;br /&amp;gt;');
document.write(&quot;最小值是:&quot; + maxValue);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://127.0.0.1:4000/img/20180222/20180222-1.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用自组织数据&quot;&gt;使用自组织数据&lt;/h3&gt;

&lt;p&gt;对于未排序的数据集来说，当被查找的数据位于数据集的起始位置时，查找是最快、最成功的。通过将成功找到的元素置于数据集的起始位置，可以保证在以后的操作中该元素能被更快地查找到。&lt;/p&gt;

&lt;p&gt;通过将频繁查找到的元素置于数据集的起始位置来最小化查找次数，这就叫做自组织数据。&lt;/p&gt;

&lt;p&gt;由于对数据的查找遵循“80-20 原则”，因此将你的数据转化为自组织的形式是很有意义 的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“80-20 原则”是指对某一数据集执行的 80% 的查找操作都是对其中 20% 的数据元素 进行查找。自组织的方式最终会把这 20% 的数据置于数据集的起始位置，这样便可以通过 一个简单的顺序查找快速找到它们。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举个例子，理解对 seqSearch() 函数进行改动以加入自组织方式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numbers = [5,1,7,4,2,10,9,3,6,8];

//改动后的seqSearch() 函数
function seqSearch(arr,data) {
    for(var i = 0; i &amp;lt; arr.length; ++i) {
        if(arr[i] === data) {
            if( i &amp;gt; 0) {
                swap(arr,i,i-1);
            }
            return true;
        }
    }
    return false;
}
 
//swap() 函数来对这次找到的数据与当前存储在上一个位置的数据进行互换。
function swap(arr,index,index1) {
    temp = arr[index];
    arr[index] = arr[index1];
    arr[index1] = temp;
}

for (var i = 0; i &amp;lt;= 5; i++) {
  seqSearch(numbers, 4);
  console.log(numbers);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://127.0.0.1:4000/img/20180222/20180222-2.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种写法同时可以保证已经在数据集前面的元素不会被越移越远。&lt;/p&gt;

&lt;h2 id=&quot;二分查找&quot;&gt;二分查找&lt;/h2&gt;

&lt;p&gt;如果你要查找的数据是有序的，二分查找算法比顺序查找算法更高效。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var nums = [0,5,46,85,102,212,503];  //必须先排序好
 
function binSearch(arr,data) {
    var upperBound = arr.length - 1;
        lowerBound = 0;
    while(lowerBound &amp;lt;= upperBound) {
        var mid = Math.floor((upperBound + lowerBound) / 2);
        console.log('此时的中点：' + mid);
        if(arr[mid] &amp;lt; data) {
            lowerBound = mid + 1;
        } else if(arr[mid] &amp;gt; data) {
            upperBound = mid - 1;
        } else {
            return mid;
        }
    }
    return -1;
}

console.log(binSearch(nums,46));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://127.0.0.1:4000/img/20180222/20180222-3.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;计算重复次数&quot;&gt;计算重复次数&lt;/h3&gt;

&lt;p&gt;count函数一开始调用 binSearch() 函数来查找指定的值。如果在数据集中能找到这个值， 那么这个函数将开始通过两个循环来统计这个值出现的次数。第一个循环向下遍历数组， 统计找到的值出现的次数，当下一个值与要查找的值不匹配时则停止计数。第二个循环向 上遍历数组，统计找到的值出现的次数，当下一个值与要查找的值不匹配时则停止计数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function count(arr,data) {
    var count = 0,
        position = binSearch(arr,data);
        if(position &amp;gt; -1) {
            ++count;
            for(var i = position-1; i &amp;gt; 0; --i) {
                if(arr[i] === data) {
                    ++count;
                } else {
                    break;
                }
            }
            for(var i = position + 1; i &amp;lt; arr.length; ++i) {
                if(arr[i] === data) {
                    ++count;
                } else {
                    break;
                }
            }
        }
        return count;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">检索算法 本章介绍了数据检索的一个方面: 如何在列表中查找特定的值。 在列表中查找数据有两种方式: 顺序查找和二分查找。 顺序查找适用于元素随机排列的列表; 二分查找适用于元素已排序的列表。 二分查找效率更高，但是你必须在进行查找之前 花费额外的时间将列表中的元素排序。 顺序查找 对于查找数据来说，最简单的方法就是从列表的第一个元素开始对列表元素逐个进行判 断，直到找到了想要的结果，或者直到列表结尾也没有找到。这种方法称为顺序查找，有 时也被称为线性查找。它属于暴力查找技巧的一种，在执行查找时可能会访问到数据结构 里的所有元素。 顺序查找的实现： 只要从列表的第一个元素开始循环，然后逐个与要查找的数据进 行比较。如果匹配到了，则结束查找。如果到了列表的结尾也没有匹配到，那么这个数据 就不存在于这个列表中。 代码实现： function seqSearch(arr, data) { for (var i = 0; i &amp;lt; arr.length; ++i) { if (arr[i] == data) { return i; } } return -1; } 如果在数组中找到了参数 data，返回所在的位置，如果没有找到要查找的数据，函数返回-1。 seqSearch() 函数的执行速度比内置的 Array.indexof() 方法慢，这里仅用来演示 顺序查找是如何运行的。 查找最小值和最大值 查找最小值 首先看看如何在数组中查找最小值，算法如下。 将数组第一个元素赋值给一个变量，把这个变量作为最小值。 开始遍历数组，从第二个元素开始依次同当前最小值进行比较。 如果当前元素数值小于当前最小值，则将当前元素设为新的最小值。 移动到下一个元素，并且重复步骤 3。 当程序结束时，这个变量中存储的就是最小值。 代码实现如下： function findMin(arr) { var min = arr[0]; for (var i = 1; i &amp;lt; arr.length; ++i) { if (arr[i] &amp;lt; min) { min = arr[i]; } } return min; } 需要注意的关键部分，由于我们假设数组的第一个元素就是当前的最小值，所以这个函数 会从数组的第二个元素开始进行处理。 查找最大值 查找最大值和查找最小值的原理是一样的，只不过是先把数组的第一个元素设置为最大值。 function findMax(arr) { var max = arr[0]; for (var i = 1; i &amp;lt; arr.length; ++i) { if (arr[i] &amp;gt; max) { max = arr[i]; } } return max; } 实例化个例子： var nums = []; for (var i = 0; i &amp;lt; 100; ++i) { nums[i] = Math.floor(Math.random() * 101); } document.getElementById('box').innerHTML = nums; var minValue = this.findMin(nums); var maxValue = this.findMax(nums); document.write(&quot;最小值是:&quot; + minValue + '&amp;lt;br /&amp;gt;'); document.write(&quot;最小值是:&quot; + maxValue); 使用自组织数据 对于未排序的数据集来说，当被查找的数据位于数据集的起始位置时，查找是最快、最成功的。通过将成功找到的元素置于数据集的起始位置，可以保证在以后的操作中该元素能被更快地查找到。 通过将频繁查找到的元素置于数据集的起始位置来最小化查找次数，这就叫做自组织数据。 由于对数据的查找遵循“80-20 原则”，因此将你的数据转化为自组织的形式是很有意义 的。 “80-20 原则”是指对某一数据集执行的 80% 的查找操作都是对其中 20% 的数据元素 进行查找。自组织的方式最终会把这 20% 的数据置于数据集的起始位置，这样便可以通过 一个简单的顺序查找快速找到它们。 举个例子，理解对 seqSearch() 函数进行改动以加入自组织方式 var numbers = [5,1,7,4,2,10,9,3,6,8]; //改动后的seqSearch() 函数 function seqSearch(arr,data) { for(var i = 0; i &amp;lt; arr.length; ++i) { if(arr[i] === data) { if( i &amp;gt; 0) { swap(arr,i,i-1); } return true; } } return false; } //swap() 函数来对这次找到的数据与当前存储在上一个位置的数据进行互换。 function swap(arr,index,index1) { temp = arr[index]; arr[index] = arr[index1]; arr[index1] = temp; } for (var i = 0; i &amp;lt;= 5; i++) { seqSearch(numbers, 4); console.log(numbers); } 这种写法同时可以保证已经在数据集前面的元素不会被越移越远。 二分查找 如果你要查找的数据是有序的，二分查找算法比顺序查找算法更高效。 var nums = [0,5,46,85,102,212,503]; //必须先排序好 function binSearch(arr,data) { var upperBound = arr.length - 1; lowerBound = 0; while(lowerBound &amp;lt;= upperBound) { var mid = Math.floor((upperBound + lowerBound) / 2); console.log('此时的中点：' + mid); if(arr[mid] &amp;lt; data) { lowerBound = mid + 1; } else if(arr[mid] &amp;gt; data) { upperBound = mid - 1; } else { return mid; } } return -1; } console.log(binSearch(nums,46)); 计算重复次数 count函数一开始调用 binSearch() 函数来查找指定的值。如果在数据集中能找到这个值， 那么这个函数将开始通过两个循环来统计这个值出现的次数。第一个循环向下遍历数组， 统计找到的值出现的次数，当下一个值与要查找的值不匹配时则停止计数。第二个循环向 上遍历数组，统计找到的值出现的次数，当下一个值与要查找的值不匹配时则停止计数。 function count(arr,data) { var count = 0, position = binSearch(arr,data); if(position &amp;gt; -1) { ++count; for(var i = position-1; i &amp;gt; 0; --i) { if(arr[i] === data) { ++count; } else { break; } } for(var i = position + 1; i &amp;lt; arr.length; ++i) { if(arr[i] === data) { ++count; } else { break; } } } return count; }</summary></entry><entry><title type="html">JS基础–高级排序(三)</title><link href="http://localhost:4000/js/2018/02/11/senior_Sort_3.html" rel="alternate" type="text/html" title="JS基础--高级排序(三)" /><published>2018-02-11T00:00:00+08:00</published><updated>2018-02-11T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/02/11/senior_Sort_3</id><content type="html" xml:base="http://localhost:4000/js/2018/02/11/senior_Sort_3.html">&lt;h1 id=&quot;高级排序快速排序&quot;&gt;高级排序—快速排序&lt;/h1&gt;

&lt;p&gt;快速排序是处理大数据集最快的排序算法之一。&lt;/p&gt;

&lt;p&gt;它是一种分而治之的算法，通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。&lt;/p&gt;

&lt;h3 id=&quot;快速排序&quot;&gt;快速排序&lt;/h3&gt;

&lt;p&gt;这个算法首先要在列表中选择一个元素作为基准值(pivot)。数据排序围绕基准值进行， 将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。&lt;/p&gt;

&lt;h4 id=&quot;自底向上的归并排序&quot;&gt;自底向上的归并排序&lt;/h4&gt;

&lt;p&gt;采用非递归或者迭代版本的归并排序是一个自底向上的过程。这个算法首先将数据集分解 为一组只有一个元素的数组。然后通过创建一组左右子数组将它们慢慢合并起来，每次合 并都保存一部分排好序的数据，直到最后剩下的这个数组所有的数据都已完美排序。&lt;/p&gt;

&lt;p&gt;下图演示了自底向上的归并排序算法是如何运行的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://0.0.0.0:4000/img/20180201/20180201-1.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JavaScript 实现的自底向上归并排序算法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function mergeSort() {
    if (this.dataStore.length &amp;lt; 2) {
        return; 
    }
    var step = 1;
    var left, right;
    while (step &amp;lt; this.dataStore.length) {
       left = 0;
       right = step;
       while (right + step &amp;lt;= this.dataStore.length) {
          mergeArrays(this.dataStore, left, left+step, right, right+step);
          left = right + step;
          right = left + step;
       }
       if (right &amp;lt; this.dataStore.length) {
            mergeArrays(this.dataStore, left, left+step, right, this.dataStore.length); 
        }
        step *= 2;
    }
}

function mergeArrays(arr,startLeft, stopLeft, startRight, stopRight) {
   var rightArr = new Array(stopRight - startRight + 1);
   var leftArr = new Array(stopLeft - startLeft + 1);
   k = startRight;
   for (var i = 0; i &amp;lt; (rightArr.length-1); ++i) {
      rightArr[i] = arr[k];
      ++k;
   } 
   k = startLeft;
   for (var i = 0; i &amp;lt; (leftArr.length-1); ++i) {
        leftArr[i] = arr[k];
        ++k; 
   }

    rightArr[rightArr.length-1] = Infinity; // 哨兵值 
    leftArr[leftArr.length-1] = Infinity; // 哨兵值 
    var m = 0;
    var n = 0;
   for (var k = startLeft; k &amp;lt; stopRight; ++k) {
        if (leftArr[m] &amp;lt;= rightArr[n]) {
            arr[k] = leftArr[m];
            m++; 
        } else {
            arr[k] = rightArr[n];
            n++;
        } 
    }
    document.write(&quot;left array - &quot;, leftArr + '&amp;lt;br /&amp;gt;');
    document.write(&quot;right array - &quot;, rightArr + '&amp;lt;br /&amp;gt;');
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;mergeSort() 函数中的关键点就是 step 这个变量，它用来控制 mergeArrays() 函数生成的 leftArr 和 rightArr 这两个子序列的大小。通过控制子序列的大小，处理排序是比较高效 的，因为它在对小数组进行排序时不需要花费太多时间。合并之所以高效，还有一个原 因，由于未合并的数据已经是排好序的，将它们合并到一个有序数组的过程非常容易。&lt;/p&gt;

&lt;p&gt;初始化10数的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var nums = new CArray(10);
nums.setData();
document.write(nums.toString() + '&amp;lt;br /&amp;gt;');
nums.mergeSort();
document.write(nums.toString() + '&amp;lt;br /&amp;gt;');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://0.0.0.0:4000/img/20180201/20180201-2.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一开始每个元素都在左子序列或右子序列中。然后将左右子序列合并，首先每次合并成两 个元素的子序列，然后合并成四个元素的子序列，3 和 5 除外，它们会一直保留到最后一次 迭代，那时会把它们合并成右子序列，然后再与最后的左子序列合并成最终的有序数组。&lt;/p&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">高级排序—快速排序 快速排序是处理大数据集最快的排序算法之一。 它是一种分而治之的算法，通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。 快速排序 这个算法首先要在列表中选择一个元素作为基准值(pivot)。数据排序围绕基准值进行， 将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。 自底向上的归并排序 采用非递归或者迭代版本的归并排序是一个自底向上的过程。这个算法首先将数据集分解 为一组只有一个元素的数组。然后通过创建一组左右子数组将它们慢慢合并起来，每次合 并都保存一部分排好序的数据，直到最后剩下的这个数组所有的数据都已完美排序。 下图演示了自底向上的归并排序算法是如何运行的 JavaScript 实现的自底向上归并排序算法: function mergeSort() { if (this.dataStore.length &amp;lt; 2) { return; } var step = 1; var left, right; while (step &amp;lt; this.dataStore.length) { left = 0; right = step; while (right + step &amp;lt;= this.dataStore.length) { mergeArrays(this.dataStore, left, left+step, right, right+step); left = right + step; right = left + step; } if (right &amp;lt; this.dataStore.length) { mergeArrays(this.dataStore, left, left+step, right, this.dataStore.length); } step *= 2; } } function mergeArrays(arr,startLeft, stopLeft, startRight, stopRight) { var rightArr = new Array(stopRight - startRight + 1); var leftArr = new Array(stopLeft - startLeft + 1); k = startRight; for (var i = 0; i &amp;lt; (rightArr.length-1); ++i) { rightArr[i] = arr[k]; ++k; } k = startLeft; for (var i = 0; i &amp;lt; (leftArr.length-1); ++i) { leftArr[i] = arr[k]; ++k; } rightArr[rightArr.length-1] = Infinity; // 哨兵值 leftArr[leftArr.length-1] = Infinity; // 哨兵值 var m = 0; var n = 0; for (var k = startLeft; k &amp;lt; stopRight; ++k) { if (leftArr[m] &amp;lt;= rightArr[n]) { arr[k] = leftArr[m]; m++; } else { arr[k] = rightArr[n]; n++; } } document.write(&quot;left array - &quot;, leftArr + '&amp;lt;br /&amp;gt;'); document.write(&quot;right array - &quot;, rightArr + '&amp;lt;br /&amp;gt;'); } mergeSort() 函数中的关键点就是 step 这个变量，它用来控制 mergeArrays() 函数生成的 leftArr 和 rightArr 这两个子序列的大小。通过控制子序列的大小，处理排序是比较高效 的，因为它在对小数组进行排序时不需要花费太多时间。合并之所以高效，还有一个原 因，由于未合并的数据已经是排好序的，将它们合并到一个有序数组的过程非常容易。 初始化10数的结果： var nums = new CArray(10); nums.setData(); document.write(nums.toString() + '&amp;lt;br /&amp;gt;'); nums.mergeSort(); document.write(nums.toString() + '&amp;lt;br /&amp;gt;'); 一开始每个元素都在左子序列或右子序列中。然后将左右子序列合并，首先每次合并成两 个元素的子序列，然后合并成四个元素的子序列，3 和 5 除外，它们会一直保留到最后一次 迭代，那时会把它们合并成右子序列，然后再与最后的左子序列合并成最终的有序数组。</summary></entry><entry><title type="html">JS基础–高级排序(二)</title><link href="http://localhost:4000/js/2018/02/01/senior_Sort_2.html" rel="alternate" type="text/html" title="JS基础--高级排序(二)" /><published>2018-02-01T00:00:00+08:00</published><updated>2018-02-01T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/02/01/senior_Sort_2</id><content type="html" xml:base="http://localhost:4000/js/2018/02/01/senior_Sort_2.html">&lt;h1 id=&quot;高级排序归并排序&quot;&gt;高级排序—归并排序&lt;/h1&gt;

&lt;p&gt;实现原理:把一系列排好序的子序列合并成一个大的完整有序序列。&lt;/p&gt;

&lt;h3 id=&quot;归并排序&quot;&gt;归并排序&lt;/h3&gt;

&lt;p&gt;从理论上讲，这个算法很容易实现。我们需要两个排好序的子数组，然后通过比较数据大小，先从最小的数据开始插入，最后合并得到第三个数组。&lt;/p&gt;

&lt;p&gt;然而，在实际情况中，归并排序还有一些问题，当用这个算法对一个很大的数据集进行排序时，需要相当大的空间来合并存储两个子数组。就现在来讲，内存不那么昂贵，空间不是问题，因此值得我们去实现一下归并排序，比较它和其他排序算法的执行效率。&lt;/p&gt;

&lt;h4 id=&quot;自底向上的归并排序&quot;&gt;自底向上的归并排序&lt;/h4&gt;

&lt;p&gt;采用非递归或者迭代版本的归并排序是一个自底向上的过程。这个算法首先将数据集分解 为一组只有一个元素的数组。然后通过创建一组左右子数组将它们慢慢合并起来，每次合 并都保存一部分排好序的数据，直到最后剩下的这个数组所有的数据都已完美排序。&lt;/p&gt;

&lt;p&gt;下图演示了自底向上的归并排序算法是如何运行的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://0.0.0.0:4000/img/20180201/20180201-1.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JavaScript 实现的自底向上归并排序算法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function mergeSort() {
    if (this.dataStore.length &amp;lt; 2) {
        return; 
    }
    var step = 1;
    var left, right;
    while (step &amp;lt; this.dataStore.length) {
       left = 0;
       right = step;
       while (right + step &amp;lt;= this.dataStore.length) {
          mergeArrays(this.dataStore, left, left+step, right, right+step);
          left = right + step;
          right = left + step;
       }
       if (right &amp;lt; this.dataStore.length) {
            mergeArrays(this.dataStore, left, left+step, right, this.dataStore.length); 
        }
        step *= 2;
    }
}

function mergeArrays(arr,startLeft, stopLeft, startRight, stopRight) {
   var rightArr = new Array(stopRight - startRight + 1);
   var leftArr = new Array(stopLeft - startLeft + 1);
   k = startRight;
   for (var i = 0; i &amp;lt; (rightArr.length-1); ++i) {
      rightArr[i] = arr[k];
      ++k;
   } 
   k = startLeft;
   for (var i = 0; i &amp;lt; (leftArr.length-1); ++i) {
        leftArr[i] = arr[k];
        ++k; 
   }

    rightArr[rightArr.length-1] = Infinity; // 哨兵值 
    leftArr[leftArr.length-1] = Infinity; // 哨兵值 
    var m = 0;
    var n = 0;
   for (var k = startLeft; k &amp;lt; stopRight; ++k) {
        if (leftArr[m] &amp;lt;= rightArr[n]) {
            arr[k] = leftArr[m];
            m++; 
        } else {
            arr[k] = rightArr[n];
            n++;
        } 
    }
    document.write(&quot;left array - &quot;, leftArr + '&amp;lt;br /&amp;gt;');
    document.write(&quot;right array - &quot;, rightArr + '&amp;lt;br /&amp;gt;');
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;mergeSort() 函数中的关键点就是 step 这个变量，它用来控制 mergeArrays() 函数生成的 leftArr 和 rightArr 这两个子序列的大小。通过控制子序列的大小，处理排序是比较高效 的，因为它在对小数组进行排序时不需要花费太多时间。合并之所以高效，还有一个原 因，由于未合并的数据已经是排好序的，将它们合并到一个有序数组的过程非常容易。&lt;/p&gt;

&lt;p&gt;初始化10数的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var nums = new CArray(10);
nums.setData();
document.write(nums.toString() + '&amp;lt;br /&amp;gt;');
nums.mergeSort();
document.write(nums.toString() + '&amp;lt;br /&amp;gt;');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://0.0.0.0:4000/img/20180201/20180201-2.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一开始每个元素都在左子序列或右子序列中。然后将左右子序列合并，首先每次合并成两 个元素的子序列，然后合并成四个元素的子序列，3 和 5 除外，它们会一直保留到最后一次 迭代，那时会把它们合并成右子序列，然后再与最后的左子序列合并成最终的有序数组。&lt;/p&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">高级排序—归并排序 实现原理:把一系列排好序的子序列合并成一个大的完整有序序列。 归并排序 从理论上讲，这个算法很容易实现。我们需要两个排好序的子数组，然后通过比较数据大小，先从最小的数据开始插入，最后合并得到第三个数组。 然而，在实际情况中，归并排序还有一些问题，当用这个算法对一个很大的数据集进行排序时，需要相当大的空间来合并存储两个子数组。就现在来讲，内存不那么昂贵，空间不是问题，因此值得我们去实现一下归并排序，比较它和其他排序算法的执行效率。 自底向上的归并排序 采用非递归或者迭代版本的归并排序是一个自底向上的过程。这个算法首先将数据集分解 为一组只有一个元素的数组。然后通过创建一组左右子数组将它们慢慢合并起来，每次合 并都保存一部分排好序的数据，直到最后剩下的这个数组所有的数据都已完美排序。 下图演示了自底向上的归并排序算法是如何运行的 JavaScript 实现的自底向上归并排序算法: function mergeSort() { if (this.dataStore.length &amp;lt; 2) { return; } var step = 1; var left, right; while (step &amp;lt; this.dataStore.length) { left = 0; right = step; while (right + step &amp;lt;= this.dataStore.length) { mergeArrays(this.dataStore, left, left+step, right, right+step); left = right + step; right = left + step; } if (right &amp;lt; this.dataStore.length) { mergeArrays(this.dataStore, left, left+step, right, this.dataStore.length); } step *= 2; } } function mergeArrays(arr,startLeft, stopLeft, startRight, stopRight) { var rightArr = new Array(stopRight - startRight + 1); var leftArr = new Array(stopLeft - startLeft + 1); k = startRight; for (var i = 0; i &amp;lt; (rightArr.length-1); ++i) { rightArr[i] = arr[k]; ++k; } k = startLeft; for (var i = 0; i &amp;lt; (leftArr.length-1); ++i) { leftArr[i] = arr[k]; ++k; } rightArr[rightArr.length-1] = Infinity; // 哨兵值 leftArr[leftArr.length-1] = Infinity; // 哨兵值 var m = 0; var n = 0; for (var k = startLeft; k &amp;lt; stopRight; ++k) { if (leftArr[m] &amp;lt;= rightArr[n]) { arr[k] = leftArr[m]; m++; } else { arr[k] = rightArr[n]; n++; } } document.write(&quot;left array - &quot;, leftArr + '&amp;lt;br /&amp;gt;'); document.write(&quot;right array - &quot;, rightArr + '&amp;lt;br /&amp;gt;'); } mergeSort() 函数中的关键点就是 step 这个变量，它用来控制 mergeArrays() 函数生成的 leftArr 和 rightArr 这两个子序列的大小。通过控制子序列的大小，处理排序是比较高效 的，因为它在对小数组进行排序时不需要花费太多时间。合并之所以高效，还有一个原 因，由于未合并的数据已经是排好序的，将它们合并到一个有序数组的过程非常容易。 初始化10数的结果： var nums = new CArray(10); nums.setData(); document.write(nums.toString() + '&amp;lt;br /&amp;gt;'); nums.mergeSort(); document.write(nums.toString() + '&amp;lt;br /&amp;gt;'); 一开始每个元素都在左子序列或右子序列中。然后将左右子序列合并，首先每次合并成两 个元素的子序列，然后合并成四个元素的子序列，3 和 5 除外，它们会一直保留到最后一次 迭代，那时会把它们合并成右子序列，然后再与最后的左子序列合并成最终的有序数组。</summary></entry><entry><title type="html">JS基础–高级排序(一)</title><link href="http://localhost:4000/js/2018/01/25/senior_Sort_1.html" rel="alternate" type="text/html" title="JS基础--高级排序(一)" /><published>2018-01-25T00:00:00+08:00</published><updated>2018-01-25T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/01/25/senior_Sort_1</id><content type="html" xml:base="http://localhost:4000/js/2018/01/25/senior_Sort_1.html">&lt;h1 id=&quot;高级排序-希尔排序&quot;&gt;高级排序— 希尔排序&lt;/h1&gt;

&lt;p&gt;本章讲解的高级排序算法，通常被认为是处理大型数据集的最高效排序算法，它们处理的数据集可以达到上百万个元素，而不仅仅是几百个或者几千个。&lt;/p&gt;

&lt;h3 id=&quot;希尔排序&quot;&gt;希尔排序&lt;/h3&gt;

&lt;p&gt;这个算法在插入排序的基础上做了很大的改善。希尔排序的核心理念与插入排序 不同，它会首先比较距离较远的元素，而非相邻的元素。和简单地比较相邻元素相比，使 用这种方案可以使离正确位置很远的元素更快地回到合适的位置。当开始用这个算法遍历 数据集时，所有元素之间的距离会不断减小，直到处理到数据集的末尾，这时算法比较的 就是相邻元素了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//希尔排序
function shellsort() {
    for (var g = 0; g &amp;lt; this.gaps.length; ++g) {
       for (var i = this.gaps[g]; i &amp;lt; this.dataStore.length; ++i) {
          var temp = this.dataStore[i];
          for (var j = i; j &amp;gt;= this.gaps[g] &amp;amp;&amp;amp;
                this.dataStore[j-this.gaps[g]] &amp;gt; temp;
               j -= this.gaps[g]) {
             this.dataStore[j] = this.dataStore[j - this.gaps[g]];
          }
          this.dataStore[j] = temp;
       }
        document.write('&amp;lt;br /&amp;gt;');
        document.write(this.toString());
        document.write('&amp;lt;br /&amp;gt;');
    } 
}

function setGaps(arr) {
    this.gaps = arr;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了能让这个程序在 CArray 类测试平台中运行，我们需要在这个类的定义里增加一个对间 隔序列的定义。请将下面代码添加到 CArray 的构造函数中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;this.gaps = [5,3,1];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;外循环控制间隔序列的移动。也就是说，算法在第一次处理数据集时，会检查所有间隔为 5 的元素。下一次遍历会检查所有间隔为 3 的元素。最后一次则会对间隔为 1 的元素，也 就是相邻元素执行标准插入排序。在开始做最后一次处理时，大部分元素都将在正确的位 置，算法就不必对很多元素进行交换。这就是希尔排序比插入排序更高效的地方。下图演示了如何使用间隔序列为5, 3, 1的希尔排序算法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;希尔排序原理图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180125/20180125-1.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;初始化一个例子，对10个数字进行希尔排序，跟踪这个算法的执行过程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    var nums = new CArray(100);
    nums.setData();
    document.write(&quot;希尔排序前:&amp;lt;br /&amp;gt;&quot;); 
    document.write(nums.toString()); 
    document.write(&quot;&amp;lt;br /&amp;gt;希尔排序中:&amp;lt;br /&amp;gt;&quot;); 
    nums.shellsort();
    document.write(&quot;&amp;lt;br /&amp;gt;希尔排序后:&amp;lt;br /&amp;gt;&quot;); 
    document.write(nums.toString());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180125/20180125-2.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;要理解希尔排序是如何运行的，可以对比数组的初始状态和执行完间隔序列为 5 的排序后的状态。初始状态时的第一个元素 6，和它后面的第 5 个元素 5，进行了互换，因为 5 &amp;lt; 6。&lt;/p&gt;

&lt;p&gt;再来比较 gap 5 和 gap 3 这两行。在 gap 5 这行中的数字 3 和数字 2 进行了互换， 因为 2 &amp;lt; 3，并且 2 是 3 后面的第 3 个元素。从循环中当前元素所在位置往后数，简单地数到第 gap 个数的位置，然后比较这个位置和当前元素所在位置上的两个数字，就可以对希 尔排序过程中的任何步骤进行跟踪。&lt;/p&gt;

&lt;h3 id=&quot;动态计算间隔序列的希尔排序&quot;&gt;动态计算间隔序列的希尔排序&lt;/h3&gt;

&lt;p&gt;《算法(第4版)》(人民邮电出版社)的合著者Robert Sedgewick定义了一个shellsort() 函数，在这个函数中可以通过一个公式来对希尔排序用到的间隔序列进行动态计算。 Sedgewick 的算法是通过下面的代码片段来决定初始间隔值的:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    var N = this.dataStore.length;
    var h = 1;
    while (h &amp;lt; N/3) {
        h = 3 * h + 1; 
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;间隔值确定好后，这个函数就可以像之前定义的 shellsort() 函数一样运行了，唯一的区 别是，回到外循环之前的最后一条语句会计算一个新的间隔值:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;h = (h-1)/3;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;修改后的shellsort1函数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function shellsort1() {
    var N = this.dataStore.length;
    var h = 1;
    while (h &amp;lt; N/3) {
      h = 3 * h + 1; 
    }
    while (h &amp;gt;= 1) {
       for (var i = h; i &amp;lt; N; i++) {
          for (var j = i; j &amp;gt;= h &amp;amp;&amp;amp; this.dataStore[j] &amp;lt; this.dataStore[j-h];
               j -= h) {
             swap(this.dataStore, j, j-h);
          }
      }
      h = (h-1)/3; 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样初始化10个数，shellsort1后的结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180125/20180125-3.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;比较-shellsort-算法&quot;&gt;比较 shellsort() 算法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    var nums = new CArray(100000);
    nums.setData();
    var start = new Date().getTime();
    nums.shellsort();
    var stop = new Date().getTime();
    var elapsed = stop - start;
    document.write(&quot; 硬编码间隔序列的希尔排序消耗的时间为:&quot; + elapsed + &quot; 毫秒。&quot;); 
    nums.clear();

    nums.setData();
    start = new Date().getTime();
    nums.shellsort1();
    stop = new Date().getTime();
    document.write(&quot; 动态间隔序列的希尔排序消耗的时间为:&quot; + elapsed + &quot; 毫秒。&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180125/20180125-4.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很明显，这两个希尔排序算法的效率是一样的，因此你可以根据需要随意使用&lt;/p&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">高级排序— 希尔排序 本章讲解的高级排序算法，通常被认为是处理大型数据集的最高效排序算法，它们处理的数据集可以达到上百万个元素，而不仅仅是几百个或者几千个。 希尔排序 这个算法在插入排序的基础上做了很大的改善。希尔排序的核心理念与插入排序 不同，它会首先比较距离较远的元素，而非相邻的元素。和简单地比较相邻元素相比，使 用这种方案可以使离正确位置很远的元素更快地回到合适的位置。当开始用这个算法遍历 数据集时，所有元素之间的距离会不断减小，直到处理到数据集的末尾，这时算法比较的 就是相邻元素了。 //希尔排序 function shellsort() { for (var g = 0; g &amp;lt; this.gaps.length; ++g) { for (var i = this.gaps[g]; i &amp;lt; this.dataStore.length; ++i) { var temp = this.dataStore[i]; for (var j = i; j &amp;gt;= this.gaps[g] &amp;amp;&amp;amp; this.dataStore[j-this.gaps[g]] &amp;gt; temp; j -= this.gaps[g]) { this.dataStore[j] = this.dataStore[j - this.gaps[g]]; } this.dataStore[j] = temp; } document.write('&amp;lt;br /&amp;gt;'); document.write(this.toString()); document.write('&amp;lt;br /&amp;gt;'); } } function setGaps(arr) { this.gaps = arr; } 为了能让这个程序在 CArray 类测试平台中运行，我们需要在这个类的定义里增加一个对间 隔序列的定义。请将下面代码添加到 CArray 的构造函数中 this.gaps = [5,3,1]; 外循环控制间隔序列的移动。也就是说，算法在第一次处理数据集时，会检查所有间隔为 5 的元素。下一次遍历会检查所有间隔为 3 的元素。最后一次则会对间隔为 1 的元素，也 就是相邻元素执行标准插入排序。在开始做最后一次处理时，大部分元素都将在正确的位 置，算法就不必对很多元素进行交换。这就是希尔排序比插入排序更高效的地方。下图演示了如何使用间隔序列为5, 3, 1的希尔排序算法。 希尔排序原理图： 初始化一个例子，对10个数字进行希尔排序，跟踪这个算法的执行过程 var nums = new CArray(100); nums.setData(); document.write(&quot;希尔排序前:&amp;lt;br /&amp;gt;&quot;); document.write(nums.toString()); document.write(&quot;&amp;lt;br /&amp;gt;希尔排序中:&amp;lt;br /&amp;gt;&quot;); nums.shellsort(); document.write(&quot;&amp;lt;br /&amp;gt;希尔排序后:&amp;lt;br /&amp;gt;&quot;); document.write(nums.toString()); 要理解希尔排序是如何运行的，可以对比数组的初始状态和执行完间隔序列为 5 的排序后的状态。初始状态时的第一个元素 6，和它后面的第 5 个元素 5，进行了互换，因为 5 &amp;lt; 6。 再来比较 gap 5 和 gap 3 这两行。在 gap 5 这行中的数字 3 和数字 2 进行了互换， 因为 2 &amp;lt; 3，并且 2 是 3 后面的第 3 个元素。从循环中当前元素所在位置往后数，简单地数到第 gap 个数的位置，然后比较这个位置和当前元素所在位置上的两个数字，就可以对希 尔排序过程中的任何步骤进行跟踪。 动态计算间隔序列的希尔排序 《算法(第4版)》(人民邮电出版社)的合著者Robert Sedgewick定义了一个shellsort() 函数，在这个函数中可以通过一个公式来对希尔排序用到的间隔序列进行动态计算。 Sedgewick 的算法是通过下面的代码片段来决定初始间隔值的: var N = this.dataStore.length; var h = 1; while (h &amp;lt; N/3) { h = 3 * h + 1; } 间隔值确定好后，这个函数就可以像之前定义的 shellsort() 函数一样运行了，唯一的区 别是，回到外循环之前的最后一条语句会计算一个新的间隔值: h = (h-1)/3; 修改后的shellsort1函数如下： function shellsort1() { var N = this.dataStore.length; var h = 1; while (h &amp;lt; N/3) { h = 3 * h + 1; } while (h &amp;gt;= 1) { for (var i = h; i &amp;lt; N; i++) { for (var j = i; j &amp;gt;= h &amp;amp;&amp;amp; this.dataStore[j] &amp;lt; this.dataStore[j-h]; j -= h) { swap(this.dataStore, j, j-h); } } h = (h-1)/3; } } 同样初始化10个数，shellsort1后的结果： 比较 shellsort() 算法 var nums = new CArray(100000); nums.setData(); var start = new Date().getTime(); nums.shellsort(); var stop = new Date().getTime(); var elapsed = stop - start; document.write(&quot; 硬编码间隔序列的希尔排序消耗的时间为:&quot; + elapsed + &quot; 毫秒。&quot;); nums.clear(); nums.setData(); start = new Date().getTime(); nums.shellsort1(); stop = new Date().getTime(); document.write(&quot; 动态间隔序列的希尔排序消耗的时间为:&quot; + elapsed + &quot; 毫秒。&quot;); 很明显，这两个希尔排序算法的效率是一样的，因此你可以根据需要随意使用</summary></entry><entry><title type="html">JS基础– 基本排序</title><link href="http://localhost:4000/js/2018/01/11/basic_Sort.html" rel="alternate" type="text/html" title="JS基础-- 基本排序" /><published>2018-01-11T00:00:00+08:00</published><updated>2018-01-11T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/01/11/basic_Sort</id><content type="html" xml:base="http://localhost:4000/js/2018/01/11/basic_Sort.html">&lt;h1 id=&quot;基本排序算法&quot;&gt;基本排序算法&lt;/h1&gt;

&lt;p&gt;这里介绍的基本排序算法其核心思想是指对一组数据按照一定的顺序重新排列。重新排列时用到的技术是一组嵌套的 for 循环。其中外循环会遍历数组的每一项，内循环则用于比较元素。&lt;/p&gt;

&lt;p&gt;在讲这几个基本排序之前，先初始化一个类，因为下面所有的排序都是基于这个类实现的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function CArray(numElements) {
    this.dataStore = [];
    this.pos = 0;
    this.numElements = numElements;
    this.insert = insert;
    this.toString = toString;
    this.clear = clear;
    this.setData = setData;
    this.bubbleSort = bubbleSort;
    this.swap = swap;
	for ( var i = 0; i &amp;lt; numElements; ++i ) {
		this.dataStore[i] = i;
	} 
}

function setData() {
    for ( var i = 0; i &amp;lt; this.numElements; ++i ) {
       this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1));
    }
}

function clear() {
	for ( var i = 0; i &amp;lt; this.dataStore.length; ++i ) {
	   this.dataStore[i] = 0;
	}
}


function insert(element) {
    this.dataStore[this.pos++] = element;
}


function toString() {
	var retstr = &quot;&quot;;
	for ( var i = 0; i &amp;lt; this.dataStore.length; ++i ) {
	   retstr += this.dataStore[i] + &quot; &quot;;
	   if (i &amp;gt; 0 &amp;amp; i % 10 == 0) {
	      retstr += &quot;\n&quot;;
	   }
	}
	return retstr;
}


function swap(arr, index1, index2) {
	var temp = arr[index1];
	arr[index1] = arr[index2];
	arr[index2] = temp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的类包含下面几个功能&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;插入新数据&lt;/li&gt;
  &lt;li&gt;显示数组数据&lt;/li&gt;
  &lt;li&gt;调用不同的排序算法&lt;/li&gt;
  &lt;li&gt;交换数组元素&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h4&gt;

&lt;p&gt;冒泡排序算法，它是最慢的排序算法之一，但也是一种最容易实现的排序算法&lt;/p&gt;

&lt;p&gt;之所以叫冒泡排序是因为使用这种排序算法排序时，数据值会像气泡一样从数组的一端漂 浮到另一端。假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，而较小 的值则会浮动到数组的左侧。之所以会产生这种现象是因为算法会多次在数组中移动，比 较相邻的数据，当左侧值大于右侧值时将它们进行互换&lt;/p&gt;

&lt;p&gt;如下图演示了如何对一个大的数字数据集合进行冒泡排序的过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-1.jpg&quot; alt=&quot;冒泡排序的过程&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function bubbleSort() {
        var numElements = this.dataStore.length;
        var temp;
        for ( var outer = numElements; outer &amp;gt;= 2; --outer) {
           for ( var inner = 0; inner &amp;lt;= outer - 1; ++inner ) {
              if (this.dataStore[inner] &amp;gt; this.dataStore[inner + 1]) {
                 swap(this.dataStore, inner, inner + 1);
              }
 	   } 
 	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;初始化个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numElements = 10;
var mynums = new CArray(numElements);
mynums.setData();
document.write(mynums.toString());
mynums.bubbleSort();
document.write('&amp;lt;br /&amp;gt;');
document.write(mynums.toString());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;排序结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;增加一行代码，就可看到这个数组在排序过程中的当前状态&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function bubbleSort() {
    var numElements = this.dataStore.length;
    var temp;
    for (var outer = numElements; outer &amp;gt;= 2; --outer) {
       for (var inner = 0; inner &amp;lt;= outer - 1; ++inner) {

          if (this.dataStore[inner] &amp;gt; this.dataStore[inner + 1]) {
             swap(this.dataStore, inner, inner + 1);
          }
		}
        document.write('&amp;lt;br /&amp;gt;');
        document.write(this.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;排序结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过这个输出结果，我们可以更加容易地看出小的值是如何移到数组开头的，大的值又是 如何移到数组末尾的。&lt;/p&gt;

&lt;h4 id=&quot;选择排序&quot;&gt;选择排序&lt;/h4&gt;

&lt;p&gt;选择排序从数组的开头开始，将第一个元素和其他元 素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从 第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便 完成了排序。&lt;/p&gt;

&lt;p&gt;选择排序会用到嵌套循环。外循环从数组的第一个元素移动到倒数第二个元素;内循环从第 二个数组元素移动到最后一个元素，查找比当前外循环所指向的元素小的元素。每次内循环 迭代后，数组中最小的值都会被赋值到合适的位置。&lt;/p&gt;

&lt;p&gt;选择排序算法的原理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function selectionSort() {
    var min, temp;
    for (var outer = 0; outer &amp;lt;= this.dataStore.length-2; ++outer) {
       min = outer;
       for (var inner = outer + 1;
           inner &amp;lt;= this.dataStore.length-1; ++inner) {
          if (this.dataStore[inner] &amp;lt; this.dataStore[min]) {
			  min = inner; 
		  }
          swap(this.dataStore, outer, min);
          document.write('&amp;lt;br /&amp;gt;');
          document.write(this.toString());
       }
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numElements = 10;
var mynums = new CArray(numElements);
mynums.setData();
mynums.selectionSort();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;排序结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;插入排序&quot;&gt;插入排序&lt;/h4&gt;

&lt;p&gt;插入排序类似于人类按数字或字母顺序对数据进行排序&lt;/p&gt;

&lt;p&gt;举个例子，将卡片带回办公室，清理好书桌，然后拿起第一张卡片。卡片上的姓氏是 Smith。我把 它放到桌子的左上角，然后再拿起第二张卡片。这张卡片上的姓氏是 Brown。我把 Smith 移右，把 Brown 放到 Smith 的前面。下一张卡片是 Williams，可以把它放到桌面最右边， 而不用移动其他任何卡片。下一张卡片是 Acklin。这张卡片必须放在这些卡片的最前面， 因此其他所有卡片必须向右移动一个位置来为 Acklin 这张卡片腾出位置。这就是插入排序 的排序原理。&lt;/p&gt;

&lt;p&gt;插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及 它后面的那个元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数 组元素会向右移动，为内循环中的这个元素腾出位置，就像之前介绍的姓氏卡片一样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function insertionSort() {
        var temp, inner;
        for (var outer = 1; outer &amp;lt;= this.dataStore.length - 1; ++outer) {
           temp = this.dataStore[outer];
           inner = outer;
           while (inner &amp;gt; 0 &amp;amp;&amp;amp; (this.dataStore[inner - 1] &amp;gt;= temp)) {
              this.dataStore[inner] = this.dataStore[inner - 1];
--inner; }
           this.dataStore[inner] = temp;
           document.write('&amp;lt;br /&amp;gt;');
       	   document.write(this.toString());
        }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numElements = 10;
var mynums = new CArray(numElements);
mynums.setData();
mynums.insertionSort();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;排序结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这段输出结果清楚地显示了插入排序的运行并非通过数据交换，而是通过将较大的数组元 素移动到右侧，为数组左侧的较小元素腾出位置。&lt;/p&gt;

&lt;h4 id=&quot;基本排序算法的计时比较&quot;&gt;基本排序算法的计时比较&lt;/h4&gt;

&lt;p&gt;这三种排序算法的复杂度非常相似，从理论上来说，它们的执行效率也应该差不多。要确 定这三种算法的性能差异，我们可以使用一个非正式的计时系统来比较它们对数据集合进 行排序所花费的时间。能够对算法进行计时非常重要，因为，对 100 个或 1000 个元素进 行排序时，你看不出这些排序算法的差异。但是如果对上百万个元素进行排序，这些排序 算法之间可能存在巨大的不同。&lt;/p&gt;

&lt;p&gt;这个函数的运行方式如下所示:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var start = new Date().getTime();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要记录代码执行的时间，首先启动计时器，执行代码，然后在代码执行结束时停止计时 器。计时器停止时记录的时间与计时器启动时记录的时间之差就是排序所花费的时间。&lt;/p&gt;

&lt;p&gt;有了度量排序算法效率的工具，那我们就来做一些测试，对它们进行比较&lt;/p&gt;

&lt;p&gt;为了比较基本排序算法，我们将在数组大小分别为100、1000和10 000时对这三种排序算 法计时。我们预期在数据大小为 100 和 1000 的情况下看不出这些算法的差异，但是在数 据大小为 10000时可以看到。&lt;/p&gt;

&lt;p&gt;测试代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numElements = 100;    //测试数据100、1000、10000
var nums = new CArray(numElements);
nums.setData();
var start = new Date().getTime();
nums.bubbleSort();
var stop = new Date().getTime();
var elapsed = stop - start;
document.write(&quot;对&quot; + numElements + &quot;个元素执行冒泡排序消耗的时间为:&quot; +
elapsed + &quot;毫秒。&amp;lt;br /&amp;gt;&quot;);
start = new Date().getTime();
nums.selectionSort();
stop = new Date().getTime();
elapsed = stop - start;
document.write(&quot;对&quot; + numElements + &quot;个元素执行选择排序消耗的时间为:&quot; +
elapsed + &quot;毫秒。&amp;lt;br /&amp;gt;&quot;);
start = new Date().getTime();
nums.insertionSort();
stop = new Date().getTime();
elapsed = stop - start;
document.write(&quot;对&quot; + numElements + &quot;个元素执行插入排序消耗的时间为:&quot; +
elapsed + &quot;毫秒。&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;测试数据100结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;测试数据1000结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;测试数据10000结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过上面的结果，可得出选择排序和插入排序要比冒泡排序快，插入排序是这三种算法中最快的。不过要记住，这些测试必须经过多次的运行， 最后得到的结果才可被视为是有效的统计。&lt;/p&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">基本排序算法 这里介绍的基本排序算法其核心思想是指对一组数据按照一定的顺序重新排列。重新排列时用到的技术是一组嵌套的 for 循环。其中外循环会遍历数组的每一项，内循环则用于比较元素。 在讲这几个基本排序之前，先初始化一个类，因为下面所有的排序都是基于这个类实现的。 function CArray(numElements) { this.dataStore = []; this.pos = 0; this.numElements = numElements; this.insert = insert; this.toString = toString; this.clear = clear; this.setData = setData; this.bubbleSort = bubbleSort; this.swap = swap; for ( var i = 0; i &amp;lt; numElements; ++i ) { this.dataStore[i] = i; } } function setData() { for ( var i = 0; i &amp;lt; this.numElements; ++i ) { this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1)); } } function clear() { for ( var i = 0; i &amp;lt; this.dataStore.length; ++i ) { this.dataStore[i] = 0; } } function insert(element) { this.dataStore[this.pos++] = element; } function toString() { var retstr = &quot;&quot;; for ( var i = 0; i &amp;lt; this.dataStore.length; ++i ) { retstr += this.dataStore[i] + &quot; &quot;; if (i &amp;gt; 0 &amp;amp; i % 10 == 0) { retstr += &quot;\n&quot;; } } return retstr; } function swap(arr, index1, index2) { var temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; } 上面的类包含下面几个功能 插入新数据 显示数组数据 调用不同的排序算法 交换数组元素 冒泡排序 冒泡排序算法，它是最慢的排序算法之一，但也是一种最容易实现的排序算法 之所以叫冒泡排序是因为使用这种排序算法排序时，数据值会像气泡一样从数组的一端漂 浮到另一端。假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，而较小 的值则会浮动到数组的左侧。之所以会产生这种现象是因为算法会多次在数组中移动，比 较相邻的数据，当左侧值大于右侧值时将它们进行互换 如下图演示了如何对一个大的数字数据集合进行冒泡排序的过程 function bubbleSort() { var numElements = this.dataStore.length; var temp; for ( var outer = numElements; outer &amp;gt;= 2; --outer) { for ( var inner = 0; inner &amp;lt;= outer - 1; ++inner ) { if (this.dataStore[inner] &amp;gt; this.dataStore[inner + 1]) { swap(this.dataStore, inner, inner + 1); } } } } 初始化个例子： var numElements = 10; var mynums = new CArray(numElements); mynums.setData(); document.write(mynums.toString()); mynums.bubbleSort(); document.write('&amp;lt;br /&amp;gt;'); document.write(mynums.toString()); 排序结果如下： 增加一行代码，就可看到这个数组在排序过程中的当前状态 function bubbleSort() { var numElements = this.dataStore.length; var temp; for (var outer = numElements; outer &amp;gt;= 2; --outer) { for (var inner = 0; inner &amp;lt;= outer - 1; ++inner) { if (this.dataStore[inner] &amp;gt; this.dataStore[inner + 1]) { swap(this.dataStore, inner, inner + 1); } } document.write('&amp;lt;br /&amp;gt;'); document.write(this.toString()); } } 排序结果如下： 通过这个输出结果，我们可以更加容易地看出小的值是如何移到数组开头的，大的值又是 如何移到数组末尾的。 选择排序 选择排序从数组的开头开始，将第一个元素和其他元 素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从 第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便 完成了排序。 选择排序会用到嵌套循环。外循环从数组的第一个元素移动到倒数第二个元素;内循环从第 二个数组元素移动到最后一个元素，查找比当前外循环所指向的元素小的元素。每次内循环 迭代后，数组中最小的值都会被赋值到合适的位置。 选择排序算法的原理： function selectionSort() { var min, temp; for (var outer = 0; outer &amp;lt;= this.dataStore.length-2; ++outer) { min = outer; for (var inner = outer + 1; inner &amp;lt;= this.dataStore.length-1; ++inner) { if (this.dataStore[inner] &amp;lt; this.dataStore[min]) { min = inner; } swap(this.dataStore, outer, min); document.write('&amp;lt;br /&amp;gt;'); document.write(this.toString()); } } } var numElements = 10; var mynums = new CArray(numElements); mynums.setData(); mynums.selectionSort(); 排序结果如下： 插入排序 插入排序类似于人类按数字或字母顺序对数据进行排序 举个例子，将卡片带回办公室，清理好书桌，然后拿起第一张卡片。卡片上的姓氏是 Smith。我把 它放到桌子的左上角，然后再拿起第二张卡片。这张卡片上的姓氏是 Brown。我把 Smith 移右，把 Brown 放到 Smith 的前面。下一张卡片是 Williams，可以把它放到桌面最右边， 而不用移动其他任何卡片。下一张卡片是 Acklin。这张卡片必须放在这些卡片的最前面， 因此其他所有卡片必须向右移动一个位置来为 Acklin 这张卡片腾出位置。这就是插入排序 的排序原理。 插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及 它后面的那个元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数 组元素会向右移动，为内循环中的这个元素腾出位置，就像之前介绍的姓氏卡片一样。 function insertionSort() { var temp, inner; for (var outer = 1; outer &amp;lt;= this.dataStore.length - 1; ++outer) { temp = this.dataStore[outer]; inner = outer; while (inner &amp;gt; 0 &amp;amp;&amp;amp; (this.dataStore[inner - 1] &amp;gt;= temp)) { this.dataStore[inner] = this.dataStore[inner - 1]; --inner; } this.dataStore[inner] = temp; document.write('&amp;lt;br /&amp;gt;'); document.write(this.toString()); } } var numElements = 10; var mynums = new CArray(numElements); mynums.setData(); mynums.insertionSort(); 排序结果如下： 这段输出结果清楚地显示了插入排序的运行并非通过数据交换，而是通过将较大的数组元 素移动到右侧，为数组左侧的较小元素腾出位置。 基本排序算法的计时比较 这三种排序算法的复杂度非常相似，从理论上来说，它们的执行效率也应该差不多。要确 定这三种算法的性能差异，我们可以使用一个非正式的计时系统来比较它们对数据集合进 行排序所花费的时间。能够对算法进行计时非常重要，因为，对 100 个或 1000 个元素进 行排序时，你看不出这些排序算法的差异。但是如果对上百万个元素进行排序，这些排序 算法之间可能存在巨大的不同。 这个函数的运行方式如下所示: var start = new Date().getTime(); 要记录代码执行的时间，首先启动计时器，执行代码，然后在代码执行结束时停止计时 器。计时器停止时记录的时间与计时器启动时记录的时间之差就是排序所花费的时间。 有了度量排序算法效率的工具，那我们就来做一些测试，对它们进行比较 为了比较基本排序算法，我们将在数组大小分别为100、1000和10 000时对这三种排序算 法计时。我们预期在数据大小为 100 和 1000 的情况下看不出这些算法的差异，但是在数 据大小为 10000时可以看到。 测试代码如下： var numElements = 100; //测试数据100、1000、10000 var nums = new CArray(numElements); nums.setData(); var start = new Date().getTime(); nums.bubbleSort(); var stop = new Date().getTime(); var elapsed = stop - start; document.write(&quot;对&quot; + numElements + &quot;个元素执行冒泡排序消耗的时间为:&quot; + elapsed + &quot;毫秒。&amp;lt;br /&amp;gt;&quot;); start = new Date().getTime(); nums.selectionSort(); stop = new Date().getTime(); elapsed = stop - start; document.write(&quot;对&quot; + numElements + &quot;个元素执行选择排序消耗的时间为:&quot; + elapsed + &quot;毫秒。&amp;lt;br /&amp;gt;&quot;); start = new Date().getTime(); nums.insertionSort(); stop = new Date().getTime(); elapsed = stop - start; document.write(&quot;对&quot; + numElements + &quot;个元素执行插入排序消耗的时间为:&quot; + elapsed + &quot;毫秒。&quot;); 测试数据100结果： 测试数据1000结果： 测试数据10000结果： 通过上面的结果，可得出选择排序和插入排序要比冒泡排序快，插入排序是这三种算法中最快的。不过要记住，这些测试必须经过多次的运行， 最后得到的结果才可被视为是有效的统计。</summary></entry><entry><title type="html">JS基础–图和图算法(二)</title><link href="http://localhost:4000/js/2018/01/05/grap2.html" rel="alternate" type="text/html" title="JS基础--图和图算法(二)" /><published>2018-01-05T00:00:00+08:00</published><updated>2018-01-05T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/01/05/grap2</id><content type="html" xml:base="http://localhost:4000/js/2018/01/05/grap2.html">&lt;h1 id=&quot;图和图算法二&quot;&gt;图和图算法(二)&lt;/h1&gt;

&lt;h2 id=&quot;查找最短路径&quot;&gt;查找最短路径&lt;/h2&gt;

&lt;p&gt;图最常见的操作之一就是寻找从一个顶点到另一个顶点的最短路径。&lt;/p&gt;

&lt;h3 id=&quot;广度优先搜索对应的最短路径&quot;&gt;广度优先搜索对应的最短路径&lt;/h3&gt;

&lt;p&gt;在执行广度优先搜索时，会自动查找从一个顶点到另一个相连顶点的最短路径。例如，要查找从顶点 A 到顶点 D 的最短路径，我们首先会查找从 A 到 D 是否有任何一条单边路径，接着查找两条边的路径，以此类推。这正是广度优先搜索的搜索过程，因此我们可以轻松地修改广度优先搜索算法，找出最短路径。&lt;/p&gt;

&lt;h3 id=&quot;确定路径&quot;&gt;确定路径&lt;/h3&gt;

&lt;p&gt;要查找最短路径，需要修改广度优先搜索算法来记录从一个顶点到另一个顶点的路径。这需要对 Graph 类做一些修改。&lt;/p&gt;

&lt;p&gt;首先，需要一个数组来保存从一个顶点到下一个顶点的所有边。将这个数组命名为edgeTo 。因为从始至终使用的都是广度优先搜索函数，所以每次都会遇到一个没有标记的顶点，除了对它进行标记外，还会从邻接列表中我们正在探索的那个顶点添加一条边到这个顶点。这是新的 bfs()函数，以及需要添加到 Graph 类的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 将这行添加到 Graph 类
this.edgeTo = [];

function bfs(s) {
	var queue = [];
	this.marked[s] = true;
	queue.push(s); // 添加到队尾
	while (queue.length &amp;gt; 0) {
	var v = queue.shift(); // 从队首移除
	if (v == undefined) {
		document.write(&quot;Visisted vertex: &quot; + v);
	}
		for each(var w in this.adj[v]) {
			if (!this.marked[w]) {
				this.edgeTo[w] = v;
				this.marked[w] = true;
				queue.push(w);
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其次，现在需要一个函数，用于展示图中连接到不同顶点的路径。函数 pathTo() 创建了一个栈，用来存储与指定顶点有共同边的所有顶点。以下是 pathTo() 函数的代码，以及一个简单的辅助函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 将这两行添加到 Graph 类
this.pathTo = pathTo;
this.hasPathTo = hashPathTo;

function pathTo(v) {
	var source = 0;
	if (!this.hasPathTo(v)) {
		return undefined;
	}

	var path = [];
	for (var i = v; i != source; i = this.edgeTo[i]) {
		path.push(i);
	}

	path.push(s);
	return path;
}

function hashPathTo(v) {
	return this.marked[v];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;拓扑排序&quot;&gt;拓扑排序&lt;/h2&gt;

&lt;p&gt;拓扑排序会对有向图的所有顶点进行排序，使有向边从前面的顶点指向后面的顶点。&lt;/p&gt;

&lt;h3 id=&quot;拓扑排序算法&quot;&gt;拓扑排序算法&lt;/h3&gt;

&lt;p&gt;拓扑排序算法与深度优先搜索类似。不同的是，拓扑排序算法不会立即输出已访问的顶点，而是访问当前顶点邻接表中的所有相邻顶点，直到这个列表穷尽时，才将当前顶点压入栈中。&lt;/p&gt;

&lt;p&gt;拓扑排序算法被拆分为两个函数。第一个函数 topSort() ，会设置排序进程并调用一个辅助函数 topSortHelper() ，然后显示排序好的顶点列表。&lt;/p&gt;

&lt;p&gt;主要工作是在递归函数 topSortHelper() 中完成的。这个函数会将当前顶点标记为已访问，然后递归访问当前顶点邻接表中的每个相邻顶点，标记这些顶点为已访问。最后，将当前顶点压入栈。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function topSort() {
	var stack = [];
	var visited = [];
	for (var i = 0; i &amp;lt; this.vertices; i++) {
		visited[i] = false;
	}
	for (var i = 0; i &amp;lt; this.vertices; i++) {
		if (visited[i] == false) {
			this.topSortHelper(i, visited, stack);
		}
	}
	for (var i = 0; i &amp;lt; stack.length; i++) {
		if (stack[i] != undefined &amp;amp;&amp;amp; stack[i] != false) {
			document.write(this.vertexList[stack[i]]);
		}
	}
}

function topSortHelper(v, visited, stack) {
	visited[v] = true;
	for each(var w in this.adj[v]) {
		if (!visited[w]) {
			this.topSortHelper(visited[w], visited, stack);
		}
	}
	stack.push(v);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最终的Graph类&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Graph(v) {
	this.vertices = v;
	this.vertexList = [];
	this.edges = 0;
	this.adj = [];
	for (var i = 0; i &amp;lt; this.vertices; ++i) {
		this.adj[i] = [];
		this.ajd[i].push(&quot;&quot;);
	}
	this.addEdge = addEdge;
	this.showGraph = showGraph;
	this.dfs = dfs;
	this.marked = [];
	for (var i = 0; i &amp;lt; this.vertices; ++i) {
		this.marked[i] = false;
	}
	this.bfs = bfs;
	this.edgeTo = [];
	this.hasPathTo = hasPathTo;
	this.topSortHelper = topSortHelper;
	this.topSort = topSort;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">图和图算法(二) 查找最短路径 图最常见的操作之一就是寻找从一个顶点到另一个顶点的最短路径。 广度优先搜索对应的最短路径 在执行广度优先搜索时，会自动查找从一个顶点到另一个相连顶点的最短路径。例如，要查找从顶点 A 到顶点 D 的最短路径，我们首先会查找从 A 到 D 是否有任何一条单边路径，接着查找两条边的路径，以此类推。这正是广度优先搜索的搜索过程，因此我们可以轻松地修改广度优先搜索算法，找出最短路径。 确定路径 要查找最短路径，需要修改广度优先搜索算法来记录从一个顶点到另一个顶点的路径。这需要对 Graph 类做一些修改。 首先，需要一个数组来保存从一个顶点到下一个顶点的所有边。将这个数组命名为edgeTo 。因为从始至终使用的都是广度优先搜索函数，所以每次都会遇到一个没有标记的顶点，除了对它进行标记外，还会从邻接列表中我们正在探索的那个顶点添加一条边到这个顶点。这是新的 bfs()函数，以及需要添加到 Graph 类的代码： // 将这行添加到 Graph 类 this.edgeTo = []; function bfs(s) { var queue = []; this.marked[s] = true; queue.push(s); // 添加到队尾 while (queue.length &amp;gt; 0) { var v = queue.shift(); // 从队首移除 if (v == undefined) { document.write(&quot;Visisted vertex: &quot; + v); } for each(var w in this.adj[v]) { if (!this.marked[w]) { this.edgeTo[w] = v; this.marked[w] = true; queue.push(w); } } } } 其次，现在需要一个函数，用于展示图中连接到不同顶点的路径。函数 pathTo() 创建了一个栈，用来存储与指定顶点有共同边的所有顶点。以下是 pathTo() 函数的代码，以及一个简单的辅助函数： // 将这两行添加到 Graph 类 this.pathTo = pathTo; this.hasPathTo = hashPathTo; function pathTo(v) { var source = 0; if (!this.hasPathTo(v)) { return undefined; } var path = []; for (var i = v; i != source; i = this.edgeTo[i]) { path.push(i); } path.push(s); return path; } function hashPathTo(v) { return this.marked[v]; } 拓扑排序 拓扑排序会对有向图的所有顶点进行排序，使有向边从前面的顶点指向后面的顶点。 拓扑排序算法 拓扑排序算法与深度优先搜索类似。不同的是，拓扑排序算法不会立即输出已访问的顶点，而是访问当前顶点邻接表中的所有相邻顶点，直到这个列表穷尽时，才将当前顶点压入栈中。 拓扑排序算法被拆分为两个函数。第一个函数 topSort() ，会设置排序进程并调用一个辅助函数 topSortHelper() ，然后显示排序好的顶点列表。 主要工作是在递归函数 topSortHelper() 中完成的。这个函数会将当前顶点标记为已访问，然后递归访问当前顶点邻接表中的每个相邻顶点，标记这些顶点为已访问。最后，将当前顶点压入栈。 function topSort() { var stack = []; var visited = []; for (var i = 0; i &amp;lt; this.vertices; i++) { visited[i] = false; } for (var i = 0; i &amp;lt; this.vertices; i++) { if (visited[i] == false) { this.topSortHelper(i, visited, stack); } } for (var i = 0; i &amp;lt; stack.length; i++) { if (stack[i] != undefined &amp;amp;&amp;amp; stack[i] != false) { document.write(this.vertexList[stack[i]]); } } } function topSortHelper(v, visited, stack) { visited[v] = true; for each(var w in this.adj[v]) { if (!visited[w]) { this.topSortHelper(visited[w], visited, stack); } } stack.push(v); } 最终的Graph类 function Graph(v) { this.vertices = v; this.vertexList = []; this.edges = 0; this.adj = []; for (var i = 0; i &amp;lt; this.vertices; ++i) { this.adj[i] = []; this.ajd[i].push(&quot;&quot;); } this.addEdge = addEdge; this.showGraph = showGraph; this.dfs = dfs; this.marked = []; for (var i = 0; i &amp;lt; this.vertices; ++i) { this.marked[i] = false; } this.bfs = bfs; this.edgeTo = []; this.hasPathTo = hasPathTo; this.topSortHelper = topSortHelper; this.topSort = topSort; }</summary></entry><entry><title type="html">JS基础–图和图算法(一)</title><link href="http://localhost:4000/js/2017/12/28/grap1.html" rel="alternate" type="text/html" title="JS基础--图和图算法(一)" /><published>2017-12-28T00:00:00+08:00</published><updated>2017-12-28T00:00:00+08:00</updated><id>http://localhost:4000/js/2017/12/28/grap1</id><content type="html" xml:base="http://localhost:4000/js/2017/12/28/grap1.html">&lt;h1 id=&quot;图和图算法一&quot;&gt;图和图算法(一)&lt;/h1&gt;

&lt;p&gt;这一章不好理解，所以分为两期来做。&lt;/p&gt;

&lt;p&gt;如何用图给网络建模? 如何用 JavaScript 表示图? 如何实现重要的图算法?&lt;/p&gt;

&lt;p&gt;带着这几个问题开始今天的学习&lt;/p&gt;

&lt;h3 id=&quot;相关概念&quot;&gt;相关概念&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;图: 图由边的集合及顶点的集合组成&lt;/li&gt;
  &lt;li&gt;有向图: 如果一个图的顶点对是有序的，则可以称之为有向图，有向图表明了顶点的流向&lt;/li&gt;
  &lt;li&gt;无向图: 如果图是无序的，则称之为无序图，或无向图&lt;/li&gt;
  &lt;li&gt;路径: 图中的一系列顶点构成路径,&lt;/li&gt;
  &lt;li&gt;路径的长度: 用路径中第一个顶点到最后一个顶点之间边的数量表示&lt;/li&gt;
  &lt;li&gt;环: 由指向自身的顶点组成的路径称, 环的长度为0&lt;/li&gt;
  &lt;li&gt;圈: 是至少有一条边的路径，且路径的第一个顶点和最后一个顶点相同&lt;/li&gt;
  &lt;li&gt;简单圈: 无论是有向图还是 无向图，只要是没有重复边或重复顶点的圈&lt;/li&gt;
  &lt;li&gt;平凡圈: 除了第一个和最后一个顶点以外，路径的其他顶点有重复的圈&lt;/li&gt;
  &lt;li&gt;如果两个顶点之间有路径，那么这两个顶点就是强连通的，反之亦然。如果有向图的所有 的顶点都是强连通的，那么这个有向图也是强连通的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;有向图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20171229/20171229-1.jpg&quot; alt=&quot;有向图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;无向图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20171229/20171229-2.jpg&quot; alt=&quot;无向图&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;表示顶点&quot;&gt;表示顶点&lt;/h4&gt;

&lt;p&gt;创建图类的第一步就是要创建一个 Vertex 类来保存顶点和边。这个类的作用与链表和二叉搜索树的 Node 类一样。&lt;/p&gt;

&lt;p&gt;Vertex 类有两个数据成员:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;用于标识顶点，被命名为 label&lt;/li&gt;
  &lt;li&gt;表明这个顶点是否被访问过的布尔值, 被命名为wasVisited&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Vertex(label) {
    this.label = label;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;表示边&quot;&gt;表示边&lt;/h4&gt;

&lt;p&gt;图的实际信息都保存在边上面，因为它们描述了图的结构&lt;/p&gt;

&lt;p&gt;表示边两种方法实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将表示图的边的方法称为邻接表或者邻接表数组，这种方法将边存储为由顶点的相邻顶点列表构成的数组，并以此顶点作为索引。使用这种方案，当在程序中引用一个顶点时，可以高效地访问与这个顶点相连的所有顶点的列表, 本节将选用这种表示方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;邻接表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20171229/20171229-3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看上图，如果顶点 2 与顶点 0、1、3、4 相连，并且它存储在数组中索引为 2 的位置，那么，访问这个元素，我们可以访问到索引为 2 的位置处由顶点 0、1、3、4 组成的数组&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;另一种表示图边的方法被称为邻接矩阵。它是一个二维数组，其中的元素表示两个顶点之间是否有一条边&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;构建图&quot;&gt;构建图&lt;/h4&gt;

&lt;p&gt;确定了如何在代码中表示图之后，构建一个表示图的类就很容易了。下面是第一个Graph类的定义&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Graph(v) {
    this.vertices = v;
    this.edges = 0;
    this.adj = [];
    for (var i = 0; i &amp;lt; this.vertices; ++i) {
       this.adj[i] = [];
       this.adj[i].push(&quot;&quot;);
    }
    this.addEdge = addEdge;
    this.showGraph = showGraph;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个类会记录一个图表示了多少条边，并使用一个长度与图的顶点数相同的数组来记录顶点的数量。通过 for 循环为数组中的每个元素添加一个子数组来存储所有的相邻顶点，并 将所有元素初始化为空字符串。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;addEdge() 函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function addEdge(v, w) {
    this.adj[v].push(w);
    this.adj[w].push(v);
    this.edges++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当调用这个函数并传入顶点 A 和 B 时，函数会先查找顶点 A 的邻接表，将顶点 B 添加到列 表中，然后再查找顶点 B 的邻接表，将顶点 A 加入列表。最后，这个函数会将边数加 1。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;showGraph() 函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;showGraph() 函数会通过打印所有顶点及其相邻顶点列表的方式来显示图:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function showGraph() {
    for (var i = 0; i &amp;lt; this.vertices; ++i) {
       document.write(i + &quot;-&amp;gt;&quot;);
       for (var j = 0; j &amp;lt; this.vertices; ++j) {
           if (this.adj[i][j] != undefined) {
               document.write(this.adj[i][j] + ' ');
           }
       }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;初始化一个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g = new Graph(5);
g.addEdge(0,1);
g.addEdge(0,2);
g.addEdge(1,3);
g.addEdge(2,4);
g.showGraph();

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20171229/20171229-4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还是这样看更直观些：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20171229/20171229-5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;顶点 0 有到顶点 1 和顶点 2 的边;&lt;/li&gt;
  &lt;li&gt;顶点 1 有到顶点 0 和顶点 3 的边;&lt;/li&gt;
  &lt;li&gt;顶 点2有到顶点0和4的边;&lt;/li&gt;
  &lt;li&gt;顶点3有到顶点1的边;&lt;/li&gt;
  &lt;li&gt;顶点4有到顶点2的边。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，这种显示存在冗余，例如，顶点 0 和 1 之间的边和顶点 1 到 0 之间的边相同。如果只是为了显示，这样是不错的，但是在开始探索图的路径之前，需要调整一下输出。&lt;/p&gt;

&lt;h4 id=&quot;搜索图及对图的操作&quot;&gt;搜索图及对图的操作&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;确定从一个指定的顶点可以到达其他哪些顶点，这是经常对图执行的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可能想通过地图了解到从一个城镇到另一个城镇有哪些路，或者从一个机场到其他机场有哪些航班。 图上的这些操作是用搜索算法执行的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在图上可以执行两种基础搜索: 深度优先搜索和广度优先搜索。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;深度优先搜索&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;深度优先搜索包括从一条路径的起始顶点开始追溯，直到到达最后一个顶点，然后回溯， 继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止。这不是在搜 索特定的路径，而是通过搜索来查看在图中有哪些路径可以选择。&lt;/p&gt;

&lt;p&gt;如下图演示了深度优先&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20171229/20171229-6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;深度优先搜索算法比较简单:访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在初始顶点的邻接表中其他没有访问过的顶点。&lt;/p&gt;

&lt;p&gt;要让该算法运行，需要为 Graph 类添加一个数组，用来存储已访问过的顶点，将它所有元 素的值全部初始化为 false。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Graph(v) {
    this.vertices = v;
    this.edges = 0;
    this.adj = [];
    for (var i = 0; i &amp;lt; this.vertices; ++i) {
       this.adj[i] = [];
       this.adj[i].push(&quot;&quot;);
    }
    this.addEdge = addEdge;
    this.showGraph = showGraph;
    this.dfs = dfs;

    this.marked = [];
    for (var i = 0; i &amp;lt; this.vertices; ++i) {
       this.marked[i] = false;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;深度优先搜索函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function dfs(v) {
    this.marked[v] = true;
    document.write(&quot;Visited vertex:  &quot; + v);
    for each(var w in this.adj[v]) {
       if (!this.marked[w]) {
          this.dfs(w);
       } 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;广度优先搜索&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;广度优先搜索从第一个顶点开始，尝试访问尽可能靠近它的顶点。本质上，这种搜索在图 上是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的 层。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20171229/20171229-7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;广度优先搜索算法使用了抽象的队列而不是数组来对已访问过的顶点进行排序。其算法的 工作原理如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中;&lt;/li&gt;
  &lt;li&gt;从图中取出下一个顶点 v，添加到已访问的顶点列表;&lt;/li&gt;
  &lt;li&gt;将所有与 v 相邻的未访问顶点添加到队列。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function bfs(s) {
    var queue = []; 
    this.marked[s] = true; 
    queue.push(s); //添加到队尾
    while (queue.length &amp;gt; 0) {
	var v = queue.shift(); //从队首移除 
	   if (v == undefined) {
              document.write(&quot;Visisted vertex:  &quot; + v);
           }
           for each(var w in this.adj[v]) {
              if (!this.marked[w]) {
                 this.edgeTo[w] = v;
                 this.marked[w] = true;
                 queue.push(w);
	      } 
	   }
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">图和图算法(一) 这一章不好理解，所以分为两期来做。 如何用图给网络建模? 如何用 JavaScript 表示图? 如何实现重要的图算法? 带着这几个问题开始今天的学习 相关概念 图: 图由边的集合及顶点的集合组成 有向图: 如果一个图的顶点对是有序的，则可以称之为有向图，有向图表明了顶点的流向 无向图: 如果图是无序的，则称之为无序图，或无向图 路径: 图中的一系列顶点构成路径, 路径的长度: 用路径中第一个顶点到最后一个顶点之间边的数量表示 环: 由指向自身的顶点组成的路径称, 环的长度为0 圈: 是至少有一条边的路径，且路径的第一个顶点和最后一个顶点相同 简单圈: 无论是有向图还是 无向图，只要是没有重复边或重复顶点的圈 平凡圈: 除了第一个和最后一个顶点以外，路径的其他顶点有重复的圈 如果两个顶点之间有路径，那么这两个顶点就是强连通的，反之亦然。如果有向图的所有 的顶点都是强连通的，那么这个有向图也是强连通的 有向图 无向图 表示顶点 创建图类的第一步就是要创建一个 Vertex 类来保存顶点和边。这个类的作用与链表和二叉搜索树的 Node 类一样。 Vertex 类有两个数据成员: 用于标识顶点，被命名为 label 表明这个顶点是否被访问过的布尔值, 被命名为wasVisited function Vertex(label) { this.label = label; } 表示边 图的实际信息都保存在边上面，因为它们描述了图的结构 表示边两种方法实现： 将表示图的边的方法称为邻接表或者邻接表数组，这种方法将边存储为由顶点的相邻顶点列表构成的数组，并以此顶点作为索引。使用这种方案，当在程序中引用一个顶点时，可以高效地访问与这个顶点相连的所有顶点的列表, 本节将选用这种表示方法。 邻接表 看上图，如果顶点 2 与顶点 0、1、3、4 相连，并且它存储在数组中索引为 2 的位置，那么，访问这个元素，我们可以访问到索引为 2 的位置处由顶点 0、1、3、4 组成的数组 另一种表示图边的方法被称为邻接矩阵。它是一个二维数组，其中的元素表示两个顶点之间是否有一条边 构建图 确定了如何在代码中表示图之后，构建一个表示图的类就很容易了。下面是第一个Graph类的定义 function Graph(v) { this.vertices = v; this.edges = 0; this.adj = []; for (var i = 0; i &amp;lt; this.vertices; ++i) { this.adj[i] = []; this.adj[i].push(&quot;&quot;); } this.addEdge = addEdge; this.showGraph = showGraph; } 这个类会记录一个图表示了多少条边，并使用一个长度与图的顶点数相同的数组来记录顶点的数量。通过 for 循环为数组中的每个元素添加一个子数组来存储所有的相邻顶点，并 将所有元素初始化为空字符串。 addEdge() 函数 function addEdge(v, w) { this.adj[v].push(w); this.adj[w].push(v); this.edges++; } 当调用这个函数并传入顶点 A 和 B 时，函数会先查找顶点 A 的邻接表，将顶点 B 添加到列 表中，然后再查找顶点 B 的邻接表，将顶点 A 加入列表。最后，这个函数会将边数加 1。 showGraph() 函数 showGraph() 函数会通过打印所有顶点及其相邻顶点列表的方式来显示图: function showGraph() { for (var i = 0; i &amp;lt; this.vertices; ++i) { document.write(i + &quot;-&amp;gt;&quot;); for (var j = 0; j &amp;lt; this.vertices; ++j) { if (this.adj[i][j] != undefined) { document.write(this.adj[i][j] + ' '); } } } } 初始化一个例子： g = new Graph(5); g.addEdge(0,1); g.addEdge(0,2); g.addEdge(1,3); g.addEdge(2,4); g.showGraph(); 输出结果： 还是这样看更直观些： 顶点 0 有到顶点 1 和顶点 2 的边; 顶点 1 有到顶点 0 和顶点 3 的边; 顶 点2有到顶点0和4的边; 顶点3有到顶点1的边; 顶点4有到顶点2的边。 当然，这种显示存在冗余，例如，顶点 0 和 1 之间的边和顶点 1 到 0 之间的边相同。如果只是为了显示，这样是不错的，但是在开始探索图的路径之前，需要调整一下输出。 搜索图及对图的操作 确定从一个指定的顶点可以到达其他哪些顶点，这是经常对图执行的操作。 可能想通过地图了解到从一个城镇到另一个城镇有哪些路，或者从一个机场到其他机场有哪些航班。 图上的这些操作是用搜索算法执行的。 在图上可以执行两种基础搜索: 深度优先搜索和广度优先搜索。 深度优先搜索 深度优先搜索包括从一条路径的起始顶点开始追溯，直到到达最后一个顶点，然后回溯， 继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止。这不是在搜 索特定的路径，而是通过搜索来查看在图中有哪些路径可以选择。 如下图演示了深度优先 深度优先搜索算法比较简单:访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在初始顶点的邻接表中其他没有访问过的顶点。 要让该算法运行，需要为 Graph 类添加一个数组，用来存储已访问过的顶点，将它所有元 素的值全部初始化为 false。 function Graph(v) { this.vertices = v; this.edges = 0; this.adj = []; for (var i = 0; i &amp;lt; this.vertices; ++i) { this.adj[i] = []; this.adj[i].push(&quot;&quot;); } this.addEdge = addEdge; this.showGraph = showGraph; this.dfs = dfs; this.marked = []; for (var i = 0; i &amp;lt; this.vertices; ++i) { this.marked[i] = false; } } 深度优先搜索函数 function dfs(v) { this.marked[v] = true; document.write(&quot;Visited vertex: &quot; + v); for each(var w in this.adj[v]) { if (!this.marked[w]) { this.dfs(w); } } } 广度优先搜索 广度优先搜索从第一个顶点开始，尝试访问尽可能靠近它的顶点。本质上，这种搜索在图 上是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的 层。 广度优先搜索算法使用了抽象的队列而不是数组来对已访问过的顶点进行排序。其算法的 工作原理如下: 查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中; 从图中取出下一个顶点 v，添加到已访问的顶点列表; 将所有与 v 相邻的未访问顶点添加到队列。 function bfs(s) { var queue = []; this.marked[s] = true; queue.push(s); //添加到队尾 while (queue.length &amp;gt; 0) { var v = queue.shift(); //从队首移除 if (v == undefined) { document.write(&quot;Visisted vertex: &quot; + v); } for each(var w in this.adj[v]) { if (!this.marked[w]) { this.edgeTo[w] = v; this.marked[w] = true; queue.push(w); } } } }</summary></entry><entry><title type="html">JS基础–集合</title><link href="http://localhost:4000/js/2017/12/22/set.html" rel="alternate" type="text/html" title="JS基础--集合" /><published>2017-12-22T00:00:00+08:00</published><updated>2017-12-22T00:00:00+08:00</updated><id>http://localhost:4000/js/2017/12/22/set</id><content type="html" xml:base="http://localhost:4000/js/2017/12/22/set.html">&lt;h1 id=&quot;集合&quot;&gt;集合&lt;/h1&gt;

&lt;p&gt;集合(set)是一种包含不同元素的数据结构&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;集合特性&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;集合中的成员是无序的&lt;/li&gt;
  &lt;li&gt;集合中不允许相同成员存在&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在很多编程语言中，并不把集合当成一种数据类型。当你想要创建一个数据结构，用来保存一些独一无二的元素时，比如一段文本中用到 的单词，集合就变得非常有用&lt;/p&gt;

&lt;h5 id=&quot;相关概念&quot;&gt;相关概念&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;空集: 不包含任何成员的集合称为空集&lt;/li&gt;
  &lt;li&gt;全集: 则是包含一切可能成员的集合&lt;/li&gt;
  &lt;li&gt;集合相等: 如果两个集合的成员完全相同，则称两个集合相等&lt;/li&gt;
  &lt;li&gt;子集: 如果一个集合中所有的成员都属于另外一个集合，则前一集合称为后一集合的子集&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;对集合的操作&quot;&gt;对集合的操作&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;并集: 将两个集合中的成员进行合并，得到一个新集合&lt;/li&gt;
  &lt;li&gt;交集: 两个集合中共同存在的成员组成一个新的集合&lt;/li&gt;
  &lt;li&gt;补集: 属于一个集合而不属于另一个集合的成员组成的集合&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;set类&quot;&gt;Set类&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Set() {
    this.dataStore = [];
    this.add = add;
    this.remove = remove;
    this.size = size;
    this.union = union;
    this.intersect = intersect;
    this.subset = subset;
    this.difference = difference;
    this.show = show;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;show（）&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function show() {
    return this.dataStore;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;add 方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function add(data) {
    if (this.dataStore.indexOf(data) &amp;lt; 0) {
           this.dataStore.push(data);
           return true;
        } else {
           return false;
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：先要确保数 组中不存在该数据。我们使用 indexOf() 检查新加入的元素在数组中是否存在。如果找到， 该方法返回该元素在数组中的位置;如果没有找到，该方法返回 -1。如果数组中还未包含该 元素，add() 方法会将新加元素保存到数组中并返回 true;否则，返回 false。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;remove 方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function remove(data) {
    var pos = this.dataStore.indexOf(data);
        if (pos &amp;gt; -1) {
           this.dataStore.splice(pos,1);
           return true;
        } else {
           return false;
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;union() 并集操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思路：首先将第一个集合里的成员悉数加入一个临时集合，然后检 查第二个集合中的成员，看它们是否也同时属于第一个集合。如果属于，则跳过该成员， 否则就将该成员加入临时集合&lt;/p&gt;

&lt;p&gt;在定义 union() 方法前，先需要定义一个辅助方法 contains()，该方法检查一个成员是否 属于该集合&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function contains(data) {
    if (this.dataStore.indexOf(data) &amp;gt; -1) {
       return true;
        } else {
       return false;
    } 
}


function union(set) {
     var tempSet = new Set();
     for (var i = 0; i &amp;lt; this.dataStore.length; ++i) {
          tempSet.add(this.dataStore[i]);
     }
     for (var i = 0; i &amp;lt; set.dataStore.length; ++i) {
          if (!tempSet.contains(set.dataStore[i])) {
             tempSet.dataStore.push(set.dataStore[i]);
          }
     }
     return tempSet;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;intersect() 交集&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每当发现第一 个集合的成员也属于第二个集合时，便将该成员加入一个新集合，这个新集合即为方法的 返回值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function intersect(set) {
       var tempSet = new Set();
       for (var i = 0; i &amp;lt; this.dataStore.length; ++i) {
          if (set.contains(this.dataStore[i])) {
             tempSet.add(this.dataStore[i]);
          } 
       }
       return tempSet;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;subset()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在判断每个元素是否属于待比较集合前，该方法先使用 size() 方法对比两个集合的大小&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function size() {
        return this.dataStore.length;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;

&lt;p&gt;subset() 方法首先要确定该集合的长度是否小于待比较集合。如果该集合比待比较集合还要大，那么该集合肯定不会是待比较集合的一个子集。 当该集合的长度小于待比较集合时，再判断该集合内的成员是否都属于待比较集合。如果有任意一个成员不属于待比较集合，则返回 false，程序终止。如果一直比较完该集合的 最后一个元素，所有元素都属于待比较集合，那么该集合就是待比较集合的一个子集，该方法返回true。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function subset(set) {
    if (this.size() &amp;gt; set.size()) {
	return false;
    } else {
       for each (var member in this.dataStore) {
          if (!set.contains(member)) {
             return false;
          } 
       }
    }
    return true;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;difference() 返回一个新集合&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function difference(set) {
    var tempSet = new Set();
    for (var i = 0; i &amp;lt; this.dataStore.length; ++i) {
       if (!set.contains(this.dataStore[i])) {
          tempSet.add(this.dataStore[i]);
       } 
    }
    return tempSet;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">集合 集合(set)是一种包含不同元素的数据结构 集合特性 集合中的成员是无序的 集合中不允许相同成员存在 在很多编程语言中，并不把集合当成一种数据类型。当你想要创建一个数据结构，用来保存一些独一无二的元素时，比如一段文本中用到 的单词，集合就变得非常有用 相关概念 空集: 不包含任何成员的集合称为空集 全集: 则是包含一切可能成员的集合 集合相等: 如果两个集合的成员完全相同，则称两个集合相等 子集: 如果一个集合中所有的成员都属于另外一个集合，则前一集合称为后一集合的子集 对集合的操作 并集: 将两个集合中的成员进行合并，得到一个新集合 交集: 两个集合中共同存在的成员组成一个新的集合 补集: 属于一个集合而不属于另一个集合的成员组成的集合 Set类 function Set() { this.dataStore = []; this.add = add; this.remove = remove; this.size = size; this.union = union; this.intersect = intersect; this.subset = subset; this.difference = difference; this.show = show; } show（） function show() { return this.dataStore; } add 方法 function add(data) { if (this.dataStore.indexOf(data) &amp;lt; 0) { this.dataStore.push(data); return true; } else { return false; } } 思路：先要确保数 组中不存在该数据。我们使用 indexOf() 检查新加入的元素在数组中是否存在。如果找到， 该方法返回该元素在数组中的位置;如果没有找到，该方法返回 -1。如果数组中还未包含该 元素，add() 方法会将新加元素保存到数组中并返回 true;否则，返回 false。 remove 方法 function remove(data) { var pos = this.dataStore.indexOf(data); if (pos &amp;gt; -1) { this.dataStore.splice(pos,1); return true; } else { return false; } } union() 并集操作 思路：首先将第一个集合里的成员悉数加入一个临时集合，然后检 查第二个集合中的成员，看它们是否也同时属于第一个集合。如果属于，则跳过该成员， 否则就将该成员加入临时集合 在定义 union() 方法前，先需要定义一个辅助方法 contains()，该方法检查一个成员是否 属于该集合 function contains(data) { if (this.dataStore.indexOf(data) &amp;gt; -1) { return true; } else { return false; } } function union(set) { var tempSet = new Set(); for (var i = 0; i &amp;lt; this.dataStore.length; ++i) { tempSet.add(this.dataStore[i]); } for (var i = 0; i &amp;lt; set.dataStore.length; ++i) { if (!tempSet.contains(set.dataStore[i])) { tempSet.dataStore.push(set.dataStore[i]); } } return tempSet; } intersect() 交集 每当发现第一 个集合的成员也属于第二个集合时，便将该成员加入一个新集合，这个新集合即为方法的 返回值 function intersect(set) { var tempSet = new Set(); for (var i = 0; i &amp;lt; this.dataStore.length; ++i) { if (set.contains(this.dataStore[i])) { tempSet.add(this.dataStore[i]); } } return tempSet; } subset() 在判断每个元素是否属于待比较集合前，该方法先使用 size() 方法对比两个集合的大小 function size() { return this.dataStore.length; } 思路： subset() 方法首先要确定该集合的长度是否小于待比较集合。如果该集合比待比较集合还要大，那么该集合肯定不会是待比较集合的一个子集。 当该集合的长度小于待比较集合时，再判断该集合内的成员是否都属于待比较集合。如果有任意一个成员不属于待比较集合，则返回 false，程序终止。如果一直比较完该集合的 最后一个元素，所有元素都属于待比较集合，那么该集合就是待比较集合的一个子集，该方法返回true。 function subset(set) { if (this.size() &amp;gt; set.size()) { return false; } else { for each (var member in this.dataStore) { if (!set.contains(member)) { return false; } } } return true; } difference() 返回一个新集合 function difference(set) { var tempSet = new Set(); for (var i = 0; i &amp;lt; this.dataStore.length; ++i) { if (!set.contains(this.dataStore[i])) { tempSet.add(this.dataStore[i]); } } return tempSet; }</summary></entry></feed>