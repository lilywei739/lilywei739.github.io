<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.7.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2018-08-10T18:34:19+08:00</updated><id>http://localhost:4000/</id><title type="html">Weili’s Blog</title><subtitle>Weili's blog
</subtitle><author><name>weili</name></author><entry><title type="html">TypeScript (六)</title><link href="http://localhost:4000/2018/08/10/TypeScript_6.html" rel="alternate" type="text/html" title="TypeScript (六)" /><published>2018-08-10T00:00:00+08:00</published><updated>2018-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2018/08/10/TypeScript_6</id><content type="html" xml:base="http://localhost:4000/2018/08/10/TypeScript_6.html">&lt;h2 id=&quot;类二&quot;&gt;类(二)&lt;/h2&gt;

&lt;h3 id=&quot;readonly修饰符&quot;&gt;readonly修饰符&lt;/h3&gt;

&lt;p&gt;可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus(&quot;Man with the 8 strong legs&quot;);
dad.name = &quot;Man with the 3-piece suit&quot;; // 错误! name 是只读的.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;参数属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在上面的例子中，不得不定义一个受保护的成员 name和一个构造函数参数 theName在 Person类里，并且立刻给 name和 theName赋值。 这种情况经常会遇到。&lt;/p&gt;

&lt;p&gt;参数属性可以方便地在一个地方定义并初始化一个成员。&lt;/p&gt;

&lt;p&gt;下面的例子是对之前 Animal类的修改版，使用了参数属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Animal {
    constructor(private name: string) { }
    move(distanceInMeters: number) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意看是如何舍弃了 theName，仅在构造函数里使用 private name: string参数来创建和初始化 name成员。 把声明和赋值合并至一处。&lt;/p&gt;

&lt;p&gt;参数属性通过给构造函数参数添加一个访问限定符来声明。 使用 private限定一个参数属性会声明并初始化一个私有成员；对于 public和 protected来说也是一样。&lt;/p&gt;

&lt;h3 id=&quot;存取器&quot;&gt;存取器&lt;/h3&gt;

&lt;p&gt;TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。&lt;/p&gt;

&lt;p&gt;下面来看如何把一个简单的类改写成使用 get和 set。 首先，我们从一个没有使用存取器的例子开始。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Employee {
    fullName: string;
}

let employee = new Employee();
employee.fullName = &quot;Bob Smith&quot;;
if (employee.fullName) {
    console.log(employee.fullName);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以随意的设置 fullName，这是非常方便的，但是这也可能会带来麻烦。&lt;/p&gt;

&lt;p&gt;下面这个代码里，先检查用户密码是否正确，然后再允许其修改员工信息。 把对 fullName的直接访问改成了可以检查密码的 set方法。 加了一个 get方法，让上面的例子仍然可以工作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let passcode = &quot;secret passcode&quot;;

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode &amp;amp;&amp;amp; passcode == &quot;secret passcode&quot;) {
            this._fullName = newName;
        }
        else {
            console.log(&quot;Error: Unauthorized update of employee!&quot;);
        }
    }
}

let employee = new Employee();
employee.fullName = &quot;Bob Smith&quot;;
if (employee.fullName) {
    alert(employee.fullName);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。&lt;/p&gt;

&lt;p&gt;对于存取器有下面几点需要注意的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。&lt;/li&gt;
  &lt;li&gt;只带有get不带有set的存取器自动被推断为 readonly。 这在从代码生成.d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;静态属性&quot;&gt;静态属性&lt;/h3&gt;

&lt;p&gt;到目前为止，只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。&lt;/p&gt;

&lt;p&gt;也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。&lt;/p&gt;

&lt;p&gt;在这个例子里，我们使用 static定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin前面加上类名。 如同在实例属性上使用 this.前缀来访问属性一样，这里我们使用 Grid.来访问静态属性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        let xDist = (point.x - Grid.origin.x);
        let yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

let grid1 = new Grid(1.0);  // 1x scale
let grid2 = new Grid(5.0);  // 5x scale

console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;抽象类&quot;&gt;抽象类&lt;/h3&gt;

&lt;p&gt;抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abstract class Animal {
    abstract makeSound(): void;
    move(): void {
        console.log('roaming the earch...');
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abstract class Department {

    constructor(public name: string) {
    }

    printName(): void {
        console.log('Department name: ' + this.name);
    }

    abstract printMeeting(): void; // 必须在派生类中实现
}

class AccountingDepartment extends Department {

    constructor() {
        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()
    }

    printMeeting(): void {
        console.log('The Accounting Department meets each Monday at 10am.');
    }

    generateReports(): void {
        console.log('Generating accounting reports...');
    }
}

let department: Department; // 允许创建一个对抽象类型的引用
department = new Department(); // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
department.printName();
department.printMeeting();
department.generateReports(); // 错误: 方法在声明的抽象类中不存在
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;高级技巧&quot;&gt;高级技巧&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;构造函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的 实例的类型。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return &quot;Hello, &quot; + this.greeting;
    }
}

let greeter: Greeter;
greeter = new Greeter(&quot;world&quot;);
console.log(greeter.greet());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里写了 let greeter: Greeter，意思是 Greeter类的实例的类型是 Greeter。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。&lt;/p&gt;

&lt;p&gt;也创建了一个叫做构造函数的值。 这个函数会在使用 new创建类实例的时候被调用。&lt;/p&gt;

&lt;p&gt;下面来看看，上面的代码被编译成JavaScript后是什么样子的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let Greeter = (function () {
    function Greeter(message) {
        this.greeting = message;
    }
    Greeter.prototype.greet = function () {
        return &quot;Hello, &quot; + this.greeting;
    };
    return Greeter;
})();

let greeter;
greeter = new Greeter(&quot;world&quot;);
console.log(greeter.greet());

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码里， let Greeter将被赋值为构造函数。 当调用 new并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，可以认为类具有实例部分与静态部分这两个部分。&lt;/p&gt;

&lt;p&gt;稍微改写一下这个例子，看看它们之间的区别：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Greeter {
    static standardGreeting = &quot;Hello, there&quot;;
    greeting: string;
    greet() {
        if (this.greeting) {
            return &quot;Hello, &quot; + this.greeting;
        }
        else {
            return Greeter.standardGreeting;
        }
    }
}

let greeter1: Greeter;
greeter1 = new Greeter();
console.log(greeter1.greet());

let greeterMaker: typeof Greeter = Greeter;
greeterMaker.standardGreeting = &quot;Hey there!&quot;;

let greeter2: Greeter = new greeterMaker();
console.log(greeter2.greet());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个例子里， greeter1与之前看到的一样。 实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。&lt;/p&gt;

&lt;p&gt;再之后直接使用类。 创建了一个叫做 greeterMaker的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后使用 typeof Greeter，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，”告诉我 Greeter标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 greeterMaker上使用 new，创建 Greeter的实例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;把类当做接口使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Point {
    x: number;
    y: number;
}

interface Point3d extends Point {
    z: number;
}

let point3d: Point3d = {x: 1, y: 2, z: 3};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><summary type="html">类(二) readonly修饰符 可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 class Octopus { readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) { this.name = theName; } } let dad = new Octopus(&quot;Man with the 8 strong legs&quot;); dad.name = &quot;Man with the 3-piece suit&quot;; // 错误! name 是只读的. 参数属性 在上面的例子中，不得不定义一个受保护的成员 name和一个构造函数参数 theName在 Person类里，并且立刻给 name和 theName赋值。 这种情况经常会遇到。 参数属性可以方便地在一个地方定义并初始化一个成员。 下面的例子是对之前 Animal类的修改版，使用了参数属性： class Animal { constructor(private name: string) { } move(distanceInMeters: number) { console.log(`${this.name} moved ${distanceInMeters}m.`); } } 注意看是如何舍弃了 theName，仅在构造函数里使用 private name: string参数来创建和初始化 name成员。 把声明和赋值合并至一处。 参数属性通过给构造函数参数添加一个访问限定符来声明。 使用 private限定一个参数属性会声明并初始化一个私有成员；对于 public和 protected来说也是一样。 存取器 TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。 下面来看如何把一个简单的类改写成使用 get和 set。 首先，我们从一个没有使用存取器的例子开始。 class Employee { fullName: string; } let employee = new Employee(); employee.fullName = &quot;Bob Smith&quot;; if (employee.fullName) { console.log(employee.fullName); } 可以随意的设置 fullName，这是非常方便的，但是这也可能会带来麻烦。 下面这个代码里，先检查用户密码是否正确，然后再允许其修改员工信息。 把对 fullName的直接访问改成了可以检查密码的 set方法。 加了一个 get方法，让上面的例子仍然可以工作。 let passcode = &quot;secret passcode&quot;; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode &amp;amp;&amp;amp; passcode == &quot;secret passcode&quot;) { this._fullName = newName; } else { console.log(&quot;Error: Unauthorized update of employee!&quot;); } } } let employee = new Employee(); employee.fullName = &quot;Bob Smith&quot;; if (employee.fullName) { alert(employee.fullName); } 可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。 对于存取器有下面几点需要注意的： 取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 只带有get不带有set的存取器自动被推断为 readonly。 这在从代码生成.d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。 静态属性 到目前为止，只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin前面加上类名。 如同在实例属性上使用 this.前缀来访问属性一样，这里我们使用 Grid.来访问静态属性。 class Grid { static origin = {x: 0, y: 0}; calculateDistanceFromOrigin(point: {x: number; y: number;}) { let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; } constructor (public scale: number) { } } let grid1 = new Grid(1.0); // 1x scale let grid2 = new Grid(5.0); // 5x scale console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10})); console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10})); 抽象类 抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。 abstract class Animal { abstract makeSound(): void; move(): void { console.log('roaming the earch...'); } } 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。 abstract class Department { constructor(public name: string) { } printName(): void { console.log('Department name: ' + this.name); } abstract printMeeting(): void; // 必须在派生类中实现 } class AccountingDepartment extends Department { constructor() { super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() } printMeeting(): void { console.log('The Accounting Department meets each Monday at 10am.'); } generateReports(): void { console.log('Generating accounting reports...'); } } let department: Department; // 允许创建一个对抽象类型的引用 department = new Department(); // 错误: 不能创建一个抽象类的实例 department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值 department.printName(); department.printMeeting(); department.generateReports(); // 错误: 方法在声明的抽象类中不存在 高级技巧 构造函数 当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的 实例的类型。 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return &quot;Hello, &quot; + this.greeting; } } let greeter: Greeter; greeter = new Greeter(&quot;world&quot;); console.log(greeter.greet()); 这里写了 let greeter: Greeter，意思是 Greeter类的实例的类型是 Greeter。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。 也创建了一个叫做构造函数的值。 这个函数会在使用 new创建类实例的时候被调用。 下面来看看，上面的代码被编译成JavaScript后是什么样子的： let Greeter = (function () { function Greeter(message) { this.greeting = message; } Greeter.prototype.greet = function () { return &quot;Hello, &quot; + this.greeting; }; return Greeter; })(); let greeter; greeter = new Greeter(&quot;world&quot;); console.log(greeter.greet()); 上面的代码里， let Greeter将被赋值为构造函数。 当调用 new并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，可以认为类具有实例部分与静态部分这两个部分。 稍微改写一下这个例子，看看它们之间的区别： class Greeter { static standardGreeting = &quot;Hello, there&quot;; greeting: string; greet() { if (this.greeting) { return &quot;Hello, &quot; + this.greeting; } else { return Greeter.standardGreeting; } } } let greeter1: Greeter; greeter1 = new Greeter(); console.log(greeter1.greet()); let greeterMaker: typeof Greeter = Greeter; greeterMaker.standardGreeting = &quot;Hey there!&quot;; let greeter2: Greeter = new greeterMaker(); console.log(greeter2.greet()); 这个例子里， greeter1与之前看到的一样。 实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。 再之后直接使用类。 创建了一个叫做 greeterMaker的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后使用 typeof Greeter，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，”告诉我 Greeter标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 greeterMaker上使用 new，创建 Greeter的实例。 把类当做接口使用 如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。 class Point { x: number; y: number; } interface Point3d extends Point { z: number; } let point3d: Point3d = {x: 1, y: 2, z: 3};</summary></entry><entry><title type="html">TypeScript (五)</title><link href="http://localhost:4000/2018/07/27/TypeScript_5.html" rel="alternate" type="text/html" title="TypeScript (五)" /><published>2018-07-27T00:00:00+08:00</published><updated>2018-07-27T00:00:00+08:00</updated><id>http://localhost:4000/2018/07/27/TypeScript_5</id><content type="html" xml:base="http://localhost:4000/2018/07/27/TypeScript_5.html">&lt;h2 id=&quot;类一&quot;&gt;类(一)&lt;/h2&gt;

&lt;p&gt;从ECMAScript 6开始，JavaScript能够使用基于类的面向对象的方式。 TypeScript同样支持这种特性.&lt;/p&gt;

&lt;p&gt;看一个使用类的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return &quot;Hello, &quot; + this.greeting;
    }
}

let greeter = new Greeter(&quot;world&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个 greet方法。最后 new 构造了 Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它&lt;/p&gt;

&lt;h3 id=&quot;继承&quot;&gt;继承&lt;/h3&gt;

&lt;p&gt;在TypeScript里，可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。&lt;/p&gt;

&lt;p&gt;看下面的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Animal {
    move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
    }
}

class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个例子展示了最基本的继承：类从基类中继承了属性和方法。&lt;/p&gt;

&lt;p&gt;Dog是一个 派生类，它派生自 Animal 基类，通过 extends关键字。&lt;/p&gt;

&lt;p&gt;派生类通常被称作子类，基类通常被称作超类。&lt;/p&gt;

&lt;p&gt;再看个更加复杂的例子:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log(&quot;Slithering...&quot;);
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log(&quot;Galloping...&quot;);
        super.move(distanceInMeters);
    }
}

let sam = new Snake(&quot;Sammy the Python&quot;);
let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);

sam.move();
tom.move(34);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个例子展示了一些上面没有提到的特性。 使用 extends关键字创建了 Animal的两个子类： Horse和 Snake。&lt;/p&gt;

&lt;p&gt;与前一个例子的不同点是，派生类包含了一个构造函数，它必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，一定要调用 super()。 这个是&lt;strong&gt;TypeScript强制执行的一条重要规则&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这个例子演示了如何在子类里可以重写父类的方法。 Snake 类和 Horse 类都创建了 move 方法，它们重写了从 Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能。&lt;/p&gt;

&lt;p&gt;注意，即使 tom 被声明为 Animal类型，但因为它的值是 Horse，调用 tom.move(34)时，它会调用 Horse里重写的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Slithering...
Sammy the Python moved 5m.
Galloping...
Tommy the Palomino moved 34m.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;公共私有与受保护的修饰符&quot;&gt;公共，私有与受保护的修饰符&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;默认为 public&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在上面的例子里，可以自由的访问程序里定义的成员。 如果对其它语言中的类比较了解，就会注意到在之前的代码里并没有使用 public 来做修饰；例如，C#要求必须明确地使用 public指定成员是可见的。在TypeScript里，成员都默认为 public。&lt;/p&gt;

&lt;p&gt;也可以明确的将一个成员标记成 public。 来重写上面的 Animal类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Animal {
    public name: string;
    public constructor(theName: string) { this.name = theName; }
    public move(distanceInMeters: number) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;private&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当成员被标记成 private时，它就不能在声明它的类的外部访问。比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal(&quot;Cat&quot;).name; // 错误: 'name' 是私有的.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TypeScript使用的是结构性类型系统。 当比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。&lt;/p&gt;

&lt;p&gt;然而，当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，才认为这两个类型是兼容的。 对于 protected 成员也使用这个规则。&lt;/p&gt;

&lt;p&gt;下面来看一个例子，更好地说明了这一点：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super(&quot;Rhino&quot;); }
}

class Employee {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

let animal = new Animal(&quot;Goat&quot;);
let rhino = new Rhino();
let employee = new Employee(&quot;Bob&quot;);

animal = rhino;
animal = employee; // 错误: Animal 与 Employee 不兼容.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个例子中有 Animal和 Rhino两个类， Rhino是 Animal类的子类。 还有一个 Employee类，其类型看上去与 Animal是相同的。&lt;/p&gt;

&lt;p&gt;这里创建了几个这些类的实例，并相互赋值来看看会发生什么。&lt;/p&gt;

&lt;p&gt;因为 Animal和 Rhino共享了来自 Animal里的私有成员定义 private name: string，因此它们是兼容的。 然而 Employee却不是这样。当把 Employee赋值给 Animal的时候，得到一个错误，说它们的类型不兼容。 尽管 Employee里也有一个私有成员 name，但它明显不是 Animal里面定义的那个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;protected&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Person {
    protected name: string;
    constructor(name: string) { this.name = name; }
}

class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name)
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);
console.log(howard.getElevatorPitch());
console.log(howard.name); // 错误
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意，不能在 Person类外使用 name，但是仍然可以通过 Employee类的实例方法访问，因为 Employee是由 Person派生而来的。&lt;/p&gt;

&lt;p&gt;构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Person {
    protected name: string;
    protected constructor(theName: string) { this.name = theName; }
}

// Employee 能够继承 Person
class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);
let john = new Person(&quot;John&quot;); // 错误: 'Person' 的构造函数是被保护的.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><summary type="html">类(一) 从ECMAScript 6开始，JavaScript能够使用基于类的面向对象的方式。 TypeScript同样支持这种特性. 看一个使用类的例子： class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return &quot;Hello, &quot; + this.greeting; } } let greeter = new Greeter(&quot;world&quot;); 这段代码声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个 greet方法。最后 new 构造了 Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它 继承 在TypeScript里，可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。 看下面的例子： class Animal { move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); } } class Dog extends Animal { bark() { console.log('Woof! Woof!'); } } const dog = new Dog(); dog.bark(); dog.move(10); dog.bark(); 这个例子展示了最基本的继承：类从基类中继承了属性和方法。 Dog是一个 派生类，它派生自 Animal 基类，通过 extends关键字。 派生类通常被称作子类，基类通常被称作超类。 再看个更加复杂的例子: class Animal { name: string; constructor(theName: string) { this.name = theName; } move(distanceInMeters: number = 0) { console.log(`${this.name} moved ${distanceInMeters}m.`); } } class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 5) { console.log(&quot;Slithering...&quot;); super.move(distanceInMeters); } } class Horse extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 45) { console.log(&quot;Galloping...&quot;); super.move(distanceInMeters); } } let sam = new Snake(&quot;Sammy the Python&quot;); let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;); sam.move(); tom.move(34); 这个例子展示了一些上面没有提到的特性。 使用 extends关键字创建了 Animal的两个子类： Horse和 Snake。 与前一个例子的不同点是，派生类包含了一个构造函数，它必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。 这个例子演示了如何在子类里可以重写父类的方法。 Snake 类和 Horse 类都创建了 move 方法，它们重写了从 Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能。 注意，即使 tom 被声明为 Animal类型，但因为它的值是 Horse，调用 tom.move(34)时，它会调用 Horse里重写的方法： Slithering... Sammy the Python moved 5m. Galloping... Tommy the Palomino moved 34m. 公共，私有与受保护的修饰符 默认为 public 在上面的例子里，可以自由的访问程序里定义的成员。 如果对其它语言中的类比较了解，就会注意到在之前的代码里并没有使用 public 来做修饰；例如，C#要求必须明确地使用 public指定成员是可见的。在TypeScript里，成员都默认为 public。 也可以明确的将一个成员标记成 public。 来重写上面的 Animal类： class Animal { public name: string; public constructor(theName: string) { this.name = theName; } public move(distanceInMeters: number) { console.log(`${this.name} moved ${distanceInMeters}m.`); } } private 当成员被标记成 private时，它就不能在声明它的类的外部访问。比如： class Animal { private name: string; constructor(theName: string) { this.name = theName; } } new Animal(&quot;Cat&quot;).name; // 错误: 'name' 是私有的. TypeScript使用的是结构性类型系统。 当比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 然而，当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，才认为这两个类型是兼容的。 对于 protected 成员也使用这个规则。 下面来看一个例子，更好地说明了这一点： class Animal { private name: string; constructor(theName: string) { this.name = theName; } } class Rhino extends Animal { constructor() { super(&quot;Rhino&quot;); } } class Employee { private name: string; constructor(theName: string) { this.name = theName; } } let animal = new Animal(&quot;Goat&quot;); let rhino = new Rhino(); let employee = new Employee(&quot;Bob&quot;); animal = rhino; animal = employee; // 错误: Animal 与 Employee 不兼容. 这个例子中有 Animal和 Rhino两个类， Rhino是 Animal类的子类。 还有一个 Employee类，其类型看上去与 Animal是相同的。 这里创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 Animal和 Rhino共享了来自 Animal里的私有成员定义 private name: string，因此它们是兼容的。 然而 Employee却不是这样。当把 Employee赋值给 Animal的时候，得到一个错误，说它们的类型不兼容。 尽管 Employee里也有一个私有成员 name，但它明显不是 Animal里面定义的那个。 protected protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。例如： class Person { protected name: string; constructor(name: string) { this.name = name; } } class Employee extends Person { private department: string; constructor(name: string, department: string) { super(name) this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; } } let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;); console.log(howard.getElevatorPitch()); console.log(howard.name); // 错误 注意，不能在 Person类外使用 name，但是仍然可以通过 Employee类的实例方法访问，因为 Employee是由 Person派生而来的。 构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如， class Person { protected name: string; protected constructor(theName: string) { this.name = theName; } } // Employee 能够继承 Person class Employee extends Person { private department: string; constructor(name: string, department: string) { super(name); this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; } } let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;); let john = new Person(&quot;John&quot;); // 错误: 'Person' 的构造函数是被保护的.</summary></entry><entry><title type="html">TypeScript (四)</title><link href="http://localhost:4000/2018/07/20/TypeScript_4.html" rel="alternate" type="text/html" title="TypeScript (四)" /><published>2018-07-20T00:00:00+08:00</published><updated>2018-07-20T00:00:00+08:00</updated><id>http://localhost:4000/2018/07/20/TypeScript_4</id><content type="html" xml:base="http://localhost:4000/2018/07/20/TypeScript_4.html">&lt;h2 id=&quot;接口二&quot;&gt;接口(二)&lt;/h2&gt;

&lt;h3 id=&quot;函数类型&quot;&gt;函数类型&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;接口能够描述JavaScript中对象拥有的各种各样的外形。&lt;/li&gt;
  &lt;li&gt;接口也可以描述函数类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了使用接口表示函数类型，需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface SearchFunc {
  (source: string, subString: string): boolean;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样定义后，就可以像使用其它接口一样使用这个函数类型的接口。&lt;/p&gt;

&lt;p&gt;下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result &amp;gt; -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于函数类型的类型检查来说，&lt;strong&gt;函数的参数名不需要与接口里定义的名字相匹配&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比如，我们使用下面的代码重写上面的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
  let result = src.search(sub);
  return result &amp;gt; -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;可索引的类型&quot;&gt;可索引的类型&lt;/h3&gt;

&lt;p&gt;与使用接口描述函数类型差不多，可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。&lt;/p&gt;

&lt;p&gt;可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。&lt;/p&gt;

&lt;p&gt;看一个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface StringArray {
  [index: number]: string;
}

let myArray: StringArray;
myArray = [&quot;Bob&quot;, &quot;Fred&quot;];

let myStr: string = myArray[0];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;共有支持两种索引签名：字符串和数字。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[“property”]两种形式都可以。&lt;/p&gt;

&lt;p&gt;下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后，可以将索引签名设置为只读，这样就防止了给索引赋值：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = [&quot;Alice&quot;, &quot;Bob&quot;];
myArray[2] = &quot;Mallory&quot;; // error!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码不能设置myArray[2]，因为索引签名是只读的。&lt;/p&gt;

&lt;h3 id=&quot;类类型&quot;&gt;类类型&lt;/h3&gt;

&lt;h4 id=&quot;实现接口&quot;&gt;实现接口&lt;/h4&gt;

&lt;p&gt;TypeScript也能够用它来明确的强制一个类去符合某种契约&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;类静态部分与实例部分的区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当操作类和接口的时候，要知道类是具有两个类型的：&lt;strong&gt;静态部分的类型和实例的类型&lt;/strong&gt;。 当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface ClockConstructor {
    new (hour: number, minute: number);
}

class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。&lt;/p&gt;

&lt;p&gt;因此，应该直接操作类的静态部分。 看下面的例子，定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。&lt;/p&gt;

&lt;p&gt;为了方便定义一个构造函数 createClock，它用传入的类型创建实例。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
    tick();
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log(&quot;beep beep&quot;);
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log(&quot;tick tock&quot;);
    }
}

let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。&lt;/p&gt;

&lt;h3 id=&quot;继承接口&quot;&gt;继承接口&lt;/h3&gt;

&lt;p&gt;和类一样，接口也可以相互继承。&lt;/p&gt;

&lt;p&gt;这能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = &amp;lt;Square&amp;gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个接口可以继承多个接口，创建出多个接口的合成接口。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = &amp;lt;Square&amp;gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
square.penWidth = 5.0;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;混合类型&quot;&gt;混合类型&lt;/h3&gt;

&lt;p&gt;接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。&lt;/p&gt;

&lt;p&gt;一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = &amp;lt;Counter&amp;gt;function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在使用JavaScript第三方库的时候，就可能需要像上面那样去完整地定义类型。&lt;/p&gt;

&lt;h3 id=&quot;接口继承类&quot;&gt;接口继承类&lt;/h3&gt;

&lt;p&gt;当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。&lt;/p&gt;

&lt;p&gt;当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() { }
}

class TextBox extends Control {
    select() { }
}

// 错误：“Image”类型缺少“state”属性。
class Image implements SelectableControl {
    select() { }
}

class Location {

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。&lt;/p&gt;

&lt;p&gt;在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。&lt;/p&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><summary type="html">接口(二) 函数类型 接口能够描述JavaScript中对象拥有的各种各样的外形。 接口也可以描述函数类型。 为了使用接口表示函数类型，需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 interface SearchFunc { (source: string, subString: string): boolean; } 这样定义后，就可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。 let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { let result = source.search(subString); return result &amp;gt; -1; } 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子： let mySearch: SearchFunc; mySearch = function(src: string, sub: string): boolean { let result = src.search(sub); return result &amp;gt; -1; } 可索引的类型 与使用接口描述函数类型差不多，可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 看一个例子： interface StringArray { [index: number]: string; } let myArray: StringArray; myArray = [&quot;Bob&quot;, &quot;Fred&quot;]; let myStr: string = myArray[0]; 上面定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。 共有支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。 class Animal { name: string; } class Dog extends Animal { breed: string; } // 错误：使用数值型的字符串索引，有时会得到完全不同的Animal! interface NotOkay { [x: number]: Animal; [x: string]: Dog; } 字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[“property”]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示： interface NumberDictionary { [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，`name`的类型与索引类型返回值的类型不匹配 } 最后，可以将索引签名设置为只读，这样就防止了给索引赋值： interface ReadonlyStringArray { readonly [index: number]: string; } let myArray: ReadonlyStringArray = [&quot;Alice&quot;, &quot;Bob&quot;]; myArray[2] = &quot;Mallory&quot;; // error! 上面的代码不能设置myArray[2]，因为索引签名是只读的。 类类型 实现接口 TypeScript也能够用它来明确的强制一个类去符合某种契约 interface ClockInterface { currentTime: Date; } class Clock implements ClockInterface { currentTime: Date; constructor(h: number, m: number) { } } 可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样 interface ClockInterface { currentTime: Date; setTime(d: Date); } class Clock implements ClockInterface { currentTime: Date; setTime(d: Date) { this.currentTime = d; } constructor(h: number, m: number) { } } 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 类静态部分与实例部分的区别 当操作类和接口的时候，要知道类是具有两个类型的：静态部分的类型和实例的类型。 当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误： interface ClockConstructor { new (hour: number, minute: number); } class Clock implements ClockConstructor { currentTime: Date; constructor(h: number, m: number) { } } 因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。 因此，应该直接操作类的静态部分。 看下面的例子，定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便定义一个构造函数 createClock，它用传入的类型创建实例。 interface ClockConstructor { new (hour: number, minute: number): ClockInterface; } interface ClockInterface { tick(); } function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface { return new ctor(hour, minute); } class DigitalClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(&quot;beep beep&quot;); } } class AnalogClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(&quot;tick tock&quot;); } } let digital = createClock(DigitalClock, 12, 17); let analog = createClock(AnalogClock, 7, 32); 因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。 继承接口 和类一样，接口也可以相互继承。 这能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 interface Shape { color: string; } interface Square extends Shape { sideLength: number; } let square = &amp;lt;Square&amp;gt;{}; square.color = &quot;blue&quot;; square.sideLength = 10; 一个接口可以继承多个接口，创建出多个接口的合成接口。 interface Shape { color: string; } interface PenStroke { penWidth: number; } interface Square extends Shape, PenStroke { sideLength: number; } let square = &amp;lt;Square&amp;gt;{}; square.color = &quot;blue&quot;; square.sideLength = 10; square.penWidth = 5.0; 混合类型 接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。 一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。 interface Counter { (start: number): string; interval: number; reset(): void; } function getCounter(): Counter { let counter = &amp;lt;Counter&amp;gt;function (start: number) { }; counter.interval = 123; counter.reset = function () { }; return counter; } let c = getCounter(); c(10); c.reset(); c.interval = 5.0; 在使用JavaScript第三方库的时候，就可能需要像上面那样去完整地定义类型。 接口继承类 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例： class Control { private state: any; } interface SelectableControl extends Control { select(): void; } class Button extends Control implements SelectableControl { select() { } } class TextBox extends Control { select() { } } // 错误：“Image”类型缺少“state”属性。 class Image implements SelectableControl { select() { } } class Location { } 在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。 在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。</summary></entry><entry><title type="html">TypeScript (三)</title><link href="http://localhost:4000/2018/07/13/TypeScript_3.html" rel="alternate" type="text/html" title="TypeScript (三)" /><published>2018-07-13T00:00:00+08:00</published><updated>2018-07-13T00:00:00+08:00</updated><id>http://localhost:4000/2018/07/13/TypeScript_3</id><content type="html" xml:base="http://localhost:4000/2018/07/13/TypeScript_3.html">&lt;h2 id=&quot;接口一&quot;&gt;接口(一)&lt;/h2&gt;

&lt;p&gt;TypeScript的核心原则之一是对值所具有的结构进行类型检查。接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。&lt;/p&gt;

&lt;h3 id=&quot;接口定义&quot;&gt;接口定义&lt;/h3&gt;

&lt;p&gt;通过一个简单示例来观察接口是如何工作的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function printLabel(labelledObj: { label: string }) {
  console.log(labelledObj.label);
}

let myObj = { size: 10, label: &quot;Size 10 Object&quot; };
printLabel(myObj);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。&lt;/p&gt;

&lt;p&gt;需要注意的是，传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。&lt;/p&gt;

&lt;p&gt;重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

let myObj = {size: 10, label: &quot;Size 10 Object&quot;};
printLabel(myObj);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;LabelledValue接口就好比一个名字，用来描述上面例子里的要求。&lt;/li&gt;
  &lt;li&gt;LabelledValue代表了有一个 label属性且类型为string的对象。&lt;/li&gt;
  &lt;li&gt;需要注意的是，只要传入的对象满足LabelledValue提到的必要条件，那么它就是被允许的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。&lt;/p&gt;

&lt;h3 id=&quot;可选属性--&quot;&gt;可选属性 – ‘?’&lt;/h3&gt;

&lt;p&gt;接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。&lt;/p&gt;

&lt;p&gt;下面是应用了“option bags”的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: &quot;white&quot;, area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({color: &quot;black&quot;});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可选属性的好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以对可能存在的属性进行预定义;&lt;/li&gt;
  &lt;li&gt;是可以捕获引用了不存在的属性时的错误。 比如，将属性名拼错就会得到一个错误提示;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;只读属性readonly&quot;&gt;只读属性—‘readonly’&lt;/h3&gt;

&lt;p&gt;一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Point {
    readonly x: number;
    readonly y: number;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TypeScript具有ReadonlyArray&lt;T&gt;类型，它与Array&lt;T&gt;相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：&lt;/T&gt;&lt;/T&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray&amp;lt;number&amp;gt; = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a = ro as number[];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;readonly vs const&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。&lt;/p&gt;

&lt;h3 id=&quot;额外的属性检查&quot;&gt;额外的属性检查&lt;/h3&gt;

&lt;p&gt;先看个例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    // ...
}

let mySquare = createSquare({ colour: &quot;red&quot;, width: 100 });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。&lt;/p&gt;

&lt;p&gt;你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。&lt;/p&gt;

&lt;p&gt;然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// error: 'colour' not expected in type 'SquareConfig'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;绕开这些检查非常简单。 最简便的方法是使用类型断言：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。&lt;/p&gt;

&lt;p&gt;还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let squareOptions = { colour: &quot;red&quot;, width: 100 };
let mySquare = createSquare(squareOptions);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。&lt;/p&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><summary type="html">接口(一) TypeScript的核心原则之一是对值所具有的结构进行类型检查。接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 接口定义 通过一个简单示例来观察接口是如何工作的： function printLabel(labelledObj: { label: string }) { console.log(labelledObj.label); } let myObj = { size: 10, label: &quot;Size 10 Object&quot; }; printLabel(myObj); 类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string： interface LabelledValue { label: string; } function printLabel(labelledObj: LabelledValue) { console.log(labelledObj.label); } let myObj = {size: 10, label: &quot;Size 10 Object&quot;}; printLabel(myObj); LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 LabelledValue代表了有一个 label属性且类型为string的对象。 需要注意的是，只要传入的对象满足LabelledValue提到的必要条件，那么它就是被允许的。 还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。 可选属性 – ‘?’ 接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。 下面是应用了“option bags”的例子： interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): {color: string; area: number} { let newSquare = {color: &quot;white&quot;, area: 100}; if (config.color) { newSquare.color = config.color; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare; } let mySquare = createSquare({color: &quot;black&quot;}); 可选属性的好处： 可以对可能存在的属性进行预定义; 是可以捕获引用了不存在的属性时的错误。 比如，将属性名拼错就会得到一个错误提示; 只读属性—‘readonly’ 一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性: interface Point { readonly x: number; readonly y: number; } 可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。 let p1: Point = { x: 10, y: 20 }; p1.x = 5; // error! TypeScript具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： let a: number[] = [1, 2, 3, 4]; let ro: ReadonlyArray&amp;lt;number&amp;gt; = a; ro[0] = 12; // error! ro.push(5); // error! ro.length = 100; // error! a = ro; // error! 上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写： a = ro as number[]; readonly vs const 最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。 额外的属性检查 先看个例子 interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): { color: string; area: number } { // ... } let mySquare = createSquare({ colour: &quot;red&quot;, width: 100 }); 注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。 你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。 然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。 // error: 'colour' not expected in type 'SquareConfig' 绕开这些检查非常简单。 最简便的方法是使用类型断言： let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig); 然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它： interface SquareConfig { color?: string; width?: number; [propName: string]: any; } 上面的代码表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。 还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。 let squareOptions = { colour: &quot;red&quot;, width: 100 }; let mySquare = createSquare(squareOptions); 要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。</summary></entry><entry><title type="html">TypeScript (二)</title><link href="http://localhost:4000/2018/07/06/TypeScript_2.html" rel="alternate" type="text/html" title="TypeScript (二)" /><published>2018-07-06T00:00:00+08:00</published><updated>2018-07-06T00:00:00+08:00</updated><id>http://localhost:4000/2018/07/06/TypeScript_2</id><content type="html" xml:base="http://localhost:4000/2018/07/06/TypeScript_2.html">&lt;p&gt;TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。&lt;/p&gt;

&lt;h2 id=&quot;基础类型&quot;&gt;基础类型&lt;/h2&gt;

&lt;h3 id=&quot;布尔值&quot;&gt;布尔值&lt;/h3&gt;

&lt;p&gt;最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let isDone: boolean = false;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数值&quot;&gt;数值&lt;/h3&gt;

&lt;p&gt;和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;字符串&quot;&gt;字符串&lt;/h3&gt;

&lt;p&gt;和JavaScript一样，可以使用双引号（ “）或单引号（’）表示字符串&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let name: string = &quot;bob&quot;;
name = &quot;smith&quot;;


//模版字符串

let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is ${ name }.

I'll be ${ age + 1 } years old next month.`;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数组&quot;&gt;数组&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// array
let list_a: number[] = [1, 2, 3]
let list_b: Array&amp;lt;number&amp;gt; = [1, 2, 3] // number 类型的数组
let list_c: [string, number] = ['linkFly', 0] //元组
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;枚举&quot;&gt;枚举&lt;/h3&gt;

&lt;p&gt;enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum Color {Red, Green, Blue}
let c: Color = Color.Green;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;any&quot;&gt;Any&lt;/h3&gt;

&lt;p&gt;有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let notSure: any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false; // okay, definitely a boolean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let list: any[] = [1, true, &quot;free&quot;];

list[1] = 100;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;void&quot;&gt;Void&lt;/h3&gt;

&lt;p&gt;void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function warnUser(): void {
    alert(&quot;This is my warning message&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let unusable: void = undefined;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;null-和-undefined&quot;&gt;Null 和 Undefined&lt;/h3&gt;

&lt;p&gt;TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：&lt;/p&gt;

&lt;p&gt;默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Not much else we can assign to these variables!
let u: undefined = undefined;
let n: null = null;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;never&quot;&gt;Never&lt;/h3&gt;

&lt;p&gt;never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。&lt;/p&gt;

&lt;p&gt;never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
    return error(&quot;Something failed&quot;);
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;类型断言&quot;&gt;类型断言&lt;/h2&gt;

&lt;p&gt;通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。&lt;/p&gt;

&lt;p&gt;类型断言有两种形式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“尖括号”&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let someValue: any = &quot;this is a string&quot;;

let strLength: number = (&amp;lt;string&amp;gt;someValue).length;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;as&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```
let someValue: any = “this is a string”;&lt;/p&gt;

&lt;p&gt;let strLength: number = (someValue as string).length;``&lt;/p&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><summary type="html">TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 基础类型 布尔值 最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean let isDone: boolean = false; 数值 和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。 let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; 字符串 和JavaScript一样，可以使用双引号（ “）或单引号（’）表示字符串 let name: string = &quot;bob&quot;; name = &quot;smith&quot;; //模版字符串 let name: string = `Gene`; let age: number = 37; let sentence: string = `Hello, my name is ${ name }. I'll be ${ age + 1 } years old next month.`; 数组 // array let list_a: number[] = [1, 2, 3] let list_b: Array&amp;lt;number&amp;gt; = [1, 2, 3] // number 类型的数组 let list_c: [string, number] = ['linkFly', 0] //元组 枚举 enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 enum Color {Red, Green, Blue} let c: Color = Color.Green; Any 有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量： let notSure: any = 4; notSure = &quot;maybe a string instead&quot;; notSure = false; // okay, definitely a boolean 在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法： let notSure: any = 4; notSure.ifItExists(); // okay, ifItExists might exist at runtime notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check) let prettySure: Object = 4; prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'. 当只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： let list: any[] = [1, true, &quot;free&quot;]; list[1] = 100; Void void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void function warnUser(): void { alert(&quot;This is my warning message&quot;); } 声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null： let unusable: void = undefined; Null 和 Undefined TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大： 默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。 // Not much else we can assign to these variables! let u: undefined = undefined; let n: null = null; Never never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。 // 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为never function fail() { return error(&quot;Something failed&quot;); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } 类型断言 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。 类型断言有两种形式。 “尖括号” let someValue: any = &quot;this is a string&quot;; let strLength: number = (&amp;lt;string&amp;gt;someValue).length; as ``` let someValue: any = “this is a string”; let strLength: number = (someValue as string).length;``</summary></entry><entry><title type="html">TypeScript (一)</title><link href="http://localhost:4000/2018/06/30/TypeScript_1.html" rel="alternate" type="text/html" title="TypeScript (一)" /><published>2018-06-30T00:00:00+08:00</published><updated>2018-06-30T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/30/TypeScript_1</id><content type="html" xml:base="http://localhost:4000/2018/06/30/TypeScript_1.html">&lt;h2 id=&quot;什么是-typescript&quot;&gt;什么是 TypeScript&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上。&lt;/p&gt;

&lt;h2 id=&quot;typescript-优势&quot;&gt;TypeScript 优势&lt;/h2&gt;

&lt;p&gt;TypeScript 增加了代码的可读性和可维护性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了&lt;/li&gt;
  &lt;li&gt;可以在编译阶段就发现大部分错误，这总比在运行时候出错好&lt;/li&gt;
  &lt;li&gt;增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;typescript-包容性强&quot;&gt;TypeScript 包容性强&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可&lt;/li&gt;
  &lt;li&gt;即使不显式的定义类型，也能够自动做出类型推论&lt;/li&gt;
  &lt;li&gt;可以定义从简单到复杂的一切类型&lt;/li&gt;
  &lt;li&gt;即使 TypeScript 编译报错，也可以生成 JavaScript 文件&lt;/li&gt;
  &lt;li&gt;兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;typescript-的缺点&quot;&gt;TypeScript 的缺点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的东西。而且它的中文资料也不多&lt;/li&gt;
  &lt;li&gt;短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本&lt;/li&gt;
  &lt;li&gt;集成到构建流程需要一些工作量&lt;/li&gt;
  &lt;li&gt;可能和一些库结合的不是很完美&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;安装-typescript&quot;&gt;安装 TypeScript&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;TypeScript 的命令行工具安装方法如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install -g typescript
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编译一个 TypeScript 文件：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tsc hello.ts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 TypeScript 编写的文件以 .ts 为后缀&lt;/p&gt;

&lt;h2 id=&quot;一个完整的例子&quot;&gt;一个完整的例子&lt;/h2&gt;

&lt;p&gt;一个hello.ts命名的TypeScript文件，代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function sayHello(person: string) {
    return 'Hello, ' + person;
}

let user = 'Tom';
console.log(sayHello(user));

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tsc hello.ts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;会生成一个编译好的文件 hello.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function sayHello(person) {
    return 'Hello, ' + person;
}
var user = 'Tom';
console.log(sayHello(user));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><summary type="html">什么是 TypeScript TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。 TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上。 TypeScript 优势 TypeScript 增加了代码的可读性和可维护性 类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了 可以在编译阶段就发现大部分错误，这总比在运行时候出错好 增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等 TypeScript 包容性强 TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可 即使不显式的定义类型，也能够自动做出类型推论 可以定义从简单到复杂的一切类型 即使 TypeScript 编译报错，也可以生成 JavaScript 文件 兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取 TypeScript 的缺点 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的东西。而且它的中文资料也不多 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本 集成到构建流程需要一些工作量 可能和一些库结合的不是很完美 安装 TypeScript TypeScript 的命令行工具安装方法如下： npm install -g typescript 以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。 编译一个 TypeScript 文件： tsc hello.ts 使用 TypeScript 编写的文件以 .ts 为后缀 一个完整的例子 一个hello.ts命名的TypeScript文件，代码如下 function sayHello(person: string) { return 'Hello, ' + person; } let user = 'Tom'; console.log(sayHello(user)); 然后执行 tsc hello.ts 会生成一个编译好的文件 hello.js function sayHello(person) { return 'Hello, ' + person; } var user = 'Tom'; console.log(sayHello(user));</summary></entry><entry><title type="html">webpack4—高级篇</title><link href="http://localhost:4000/2018/06/22/webpack4_%E9%AB%98%E7%BA%A7.html" rel="alternate" type="text/html" title="webpack4---高级篇" /><published>2018-06-22T00:00:00+08:00</published><updated>2018-06-22T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/22/webpack4_%E9%AB%98%E7%BA%A7</id><content type="html" xml:base="http://localhost:4000/2018/06/22/webpack4_%E9%AB%98%E7%BA%A7.html">&lt;h2 id=&quot;tree-shaking&quot;&gt;Tree Shaking&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;css Tree Shaking&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add purify-css purifycss-webpack -D
const glob = require('glob')
const PurifyCSSPlugin = require('purifycss-webpack')
// 去除无用的css
plugins: [
    new PurifyCSSPlugin({
      // 路劲扫描 nodejs内置 路劲检查
      paths: glob.sync(path.join(__dirname, 'pages/*/*.html'))
    })
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;js优化&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add webpack-parallel-uglify-plugin -D
const WebpackParallelUglifyPlugin = require('webpack-parallel-uglify-plugin')
plugins: [
new WebpackParallelUglifyPlugin({
      uglifyJS: {
        output: {
          beautify: false, //不需要格式化
          comments: false //不保留注释
        },
        compress: {
          warnings: false, // 在UglifyJs删除没有用到的代码时不输出警告
          drop_console: true, // 删除所有的 `console` 语句，可以兼容ie浏览器
          collapse_vars: true, // 内嵌定义了但是只用到一次的变量
          reduce_vars: true // 提取出出现多次但是没有定义成变量去引用的静态值
        }
      }
    })
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;提取公共代码&quot;&gt;提取公共代码&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// webpack4最新配置，可以搜索关键字查查配置项
  optimization: {
    splitChunks: {
      cacheGroups: {
        commons: {
          chunks: 'initial',
          minChunks: 2,
          maxInitialRequests: 5, // The default limit is too small to showcase the effect
          minSize: 0, // This is example is too small to create commons chunks
          name: 'common'
        }
      }
    }
  },

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;打包第三方类库&quot;&gt;打包第三方类库&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;DllPlugin插件： 用于打包出一个个动态连接库&lt;/li&gt;
  &lt;li&gt;DllReferencePlugin: 在配置文件中引入DllPlugin插件打包好的动态连接库&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在package.json中
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --mode development&quot;,
    &quot;build:dll&quot;: &quot;webpack --config webpack.dll.config.js --mode development&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server --open --mode development&quot;
  }
新建webpack.dll.config.js  
const path = require('path')
const webpack = require('webpack')

/**
 * 尽量减小搜索范围
 * target: '_dll_[name]' 指定导出变量名字
 */

 module.exports = {
   entry: {
     vendor: ['jquery', 'lodash']
   },
   output: {
     path: path.join(__dirname, 'static'),
     filename: '[name].dll.js',
     library: '_dll_[name]' // 全局变量名，其他模块会从此变量上获取里面模块
   },
   // manifest是描述文件
   plugins: [
     new webpack.DllPlugin({
       name: '_dll_[name]',
       path: path.join(__dirname, 'manifest.json')
     })
   ]
 }
 
在webpack.config.js中
plugins: [
    new webpack.DllReferencePlugin({
        manifest: path.join(__dirname, 'manifest.json')
    })
]
执行npm run build:dll 就可以打包第三方包了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用happypack&quot;&gt;使用happypack&lt;/h2&gt;

&lt;p&gt;HappyPack就能让Webpack把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 happypack&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i happypack@next -D
const HappyPack = require('happypack')
const os = require('os')
const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length })

  {
    test: /\.js$/,
    // loader: 'babel-loader',
    loader: 'happypack/loader?id=happy-babel-js', // 增加新的HappyPack构建loader
    include: [resolve('src')],
    exclude: /node_modules/,
  }
  
  plugins: [
    new HappyPack({
      id: 'happy-babel-js',
      loaders: ['babel-loader?cacheDirectory=true'],
      threadPool: happyThreadPool
    })
]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;显示打包时间&quot;&gt;显示打包时间&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add progress-bar-webpack-plugin -D
const ProgressBarPlugin = require('progress-bar-webpack-plugin')
plugins: [
    new ProgressBarPlugin({
      format: '  build [:bar] ' + chalk.green.bold(':percent') + ' (:elapsed seconds)'
    })
]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><summary type="html">Tree Shaking css Tree Shaking yarn add purify-css purifycss-webpack -D const glob = require('glob') const PurifyCSSPlugin = require('purifycss-webpack') // 去除无用的css plugins: [ new PurifyCSSPlugin({ // 路劲扫描 nodejs内置 路劲检查 paths: glob.sync(path.join(__dirname, 'pages/*/*.html')) }) ] js优化 yarn add webpack-parallel-uglify-plugin -D const WebpackParallelUglifyPlugin = require('webpack-parallel-uglify-plugin') plugins: [ new WebpackParallelUglifyPlugin({ uglifyJS: { output: { beautify: false, //不需要格式化 comments: false //不保留注释 }, compress: { warnings: false, // 在UglifyJs删除没有用到的代码时不输出警告 drop_console: true, // 删除所有的 `console` 语句，可以兼容ie浏览器 collapse_vars: true, // 内嵌定义了但是只用到一次的变量 reduce_vars: true // 提取出出现多次但是没有定义成变量去引用的静态值 } } }) ] 提取公共代码 // webpack4最新配置，可以搜索关键字查查配置项 optimization: { splitChunks: { cacheGroups: { commons: { chunks: 'initial', minChunks: 2, maxInitialRequests: 5, // The default limit is too small to showcase the effect minSize: 0, // This is example is too small to create commons chunks name: 'common' } } } }, 打包第三方类库 DllPlugin插件： 用于打包出一个个动态连接库 DllReferencePlugin: 在配置文件中引入DllPlugin插件打包好的动态连接库 在package.json中 &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack --mode development&quot;, &quot;build:dll&quot;: &quot;webpack --config webpack.dll.config.js --mode development&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open --mode development&quot; } 新建webpack.dll.config.js const path = require('path') const webpack = require('webpack') /** * 尽量减小搜索范围 * target: '_dll_[name]' 指定导出变量名字 */ module.exports = { entry: { vendor: ['jquery', 'lodash'] }, output: { path: path.join(__dirname, 'static'), filename: '[name].dll.js', library: '_dll_[name]' // 全局变量名，其他模块会从此变量上获取里面模块 }, // manifest是描述文件 plugins: [ new webpack.DllPlugin({ name: '_dll_[name]', path: path.join(__dirname, 'manifest.json') }) ] } 在webpack.config.js中 plugins: [ new webpack.DllReferencePlugin({ manifest: path.join(__dirname, 'manifest.json') }) ] 执行npm run build:dll 就可以打包第三方包了 使用happypack HappyPack就能让Webpack把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 happypack npm i happypack@next -D const HappyPack = require('happypack') const os = require('os') const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length }) { test: /\.js$/, // loader: 'babel-loader', loader: 'happypack/loader?id=happy-babel-js', // 增加新的HappyPack构建loader include: [resolve('src')], exclude: /node_modules/, } plugins: [ new HappyPack({ id: 'happy-babel-js', loaders: ['babel-loader?cacheDirectory=true'], threadPool: happyThreadPool }) ] 显示打包时间 yarn add progress-bar-webpack-plugin -D const ProgressBarPlugin = require('progress-bar-webpack-plugin') plugins: [ new ProgressBarPlugin({ format: ' build [:bar] ' + chalk.green.bold(':percent') + ' (:elapsed seconds)' }) ]</summary></entry><entry><title type="html">webpack4—基础篇</title><link href="http://localhost:4000/2018/06/15/webpack4_%E5%9F%BA%E7%A1%80.html" rel="alternate" type="text/html" title="webpack4---基础篇" /><published>2018-06-15T00:00:00+08:00</published><updated>2018-06-15T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/15/webpack4_%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="http://localhost:4000/2018/06/15/webpack4_%E5%9F%BA%E7%A1%80.html">&lt;h2 id=&quot;核心概念&quot;&gt;核心概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。&lt;/li&gt;
  &lt;li&gt;Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。&lt;/li&gt;
  &lt;li&gt;Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。&lt;/li&gt;
  &lt;li&gt;Loader：模块转换器，用于把模块原内容按照需求转换成新内容。&lt;/li&gt;
  &lt;li&gt;Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。&lt;/li&gt;
  &lt;li&gt;Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;webpackgruntgulp&quot;&gt;WebPack、Grunt、Gulp？&lt;/h2&gt;

&lt;p&gt;Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果实在要把二者进行比较，Webpack的处理速度更快更直接，能打包更多不同类型的文件。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;执行流程&quot;&gt;执行流程&lt;/h2&gt;

&lt;p&gt;webpack启动后会在entry里配置的module开始递归解析entry所依赖的所有module，没找到一个module, 就会根据配置的loader去找相应的转换规则，对module进行转换后在解析当前module所依赖的module，这些模块会以entry为分组，一个entry和所有相依赖的module也就是一个chunk，最后webpack会把所有chunk转换成文件输出，在整个流程中webpack会在恰当的时机执行plugin的逻辑&lt;/p&gt;

&lt;h2 id=&quot;从零配置webpack&quot;&gt;从零配置webpack&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;初始化配置&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir webpack-start
cd webpack-start
npm init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;配置webpack&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add webpack webpack-cli -D //webpack4把webpack拆分了
mkdir src
cd src 并且创建index.html, index.js
mkdir dist
touch webpack.config.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;webpack.config.js

module.exports = {
    entry: './src/index.js', //入口文件，src下的index.js
    output: {
        path: path.join(__dirname, 'dist'), // 出口目录，dist文件
        filename: '[name].[hash].js' //这里name就是打包出来的文件名，因为是单入口，就是main，多入口下回分解
    },
    module: {},
    plugin: {},
    devServer: {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;配置开发服务器&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add webpack-dev-server -D
修改webpack.config.js
devServer: {
    contentBase: path.join(__dirname, &quot;dist&quot;), //静态文件根目录
    port: 9090, // 端口
    host: 'localhost',
    overlay: true,
    compress: true // 服务器返回浏览器的时候是否启动gzip压缩
}
修改package.json
&quot;script&quot;: {
    &quot;build&quot;: &quot;webpack --mode development&quot;, //这里为了不压缩代码，用开发环境
    &quot;dev&quot;: &quot;webpack-dev-server --open --mode development&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;支持css文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add style-loader css-loader -D
// css-loader用来处理css中url的路径
// style-loader可以把css文件变成style标签插入head中
// 多个loader是有顺序要求的，从右往左写，因为转换的时候是从右往左转换的
module: {
    rules: {
        test: /\.css$/,
        use: ['style-laoder', 'css-loader'],
        include: path.join(__dirname, 'src'), //限制范围，提高打包速度
        exclude: /node_modules/
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;支持es6，react.js等&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add babel-loader babel-core babel-preset-env babel-preset-stage-0 babel-preset -react -D
  {
    test: /\.js$/,
    use: {
      loader: 'babel-loader',
      query: {
        presets: ['env', 'stage-0', 'react'] // env转换es6 stage-0转es7 react转react
      }
    }
  }
  同时可以把babel配置写到.babelrc中

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;从js中分离css&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add extract-text-webpack-plugin -D
{
    test: /\.css$/, // 转换文件的匹配正则
    use: ExtractTextWebpackPlugin.extract({
      fallback: 'style-loader',
      //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来
      use: ['css-loader']
    })
},
//加上plugin
plugins: [
    new ExtractTextWebpackPlugin({
      filename: 'css/[name].[hash].css' //放到dist/css/下
    })
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;支持图片&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add file-loader url-loader -D
file-loader 解决css等文件中引入图片路径的问题
url-loader 当图片较小的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝
{
// file-loader是解析图片地址，把图片从源文件拷贝到目标文件并且修改源文件名字
// 可以处理任意二进制，bootstrap里的字体
// url-loader可以在文件比较小的时候，直接变成base64字符串内嵌到页面中
{
    test: /\.(png|jpg|jpeg|gif|svg)/,
    use: {
      loader: 'url-loader',
      options: {
        outputPath: 'images/', // 图片输出的路径
        limit: 5 * 1024
      }
    }
},
// 同时要处理打包图片路径问题，
output: {
    publicPath: '/'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;处理css3属性前缀&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add postcss-loader -D
{
    test: /\.css$/, // 转换文件的匹配正则
    // css-loader用来处理css中url的路径
    // style-loader可以把css文件变成style标签插入head中
    // 多个loader是有顺序要求的，从右往左写，因为转换的时候是从右往左转换的
    // 此插件先用css-loader处理一下css文件
    use: ExtractTextWebpackPlugin.extract({
      fallback: 'style-loader',
      //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来
      use: ['css-loader', 'postcss-loader']
    })
},
建立.postcssrc.js文件
module.exports = {
  &quot;plugins&quot;: {
    // to edit target browsers: use &quot;browserslist&quot; field in package.json
    &quot;autoprefixer&quot;: {
      &quot;browsers&quot;: [
        &quot;ie &amp;gt;= 9&quot;,
        &quot;ff &amp;gt;= 30&quot;,
        &quot;chrome &amp;gt;= 34&quot;,
        &quot;safari &amp;gt;= 7&quot;,
        &quot;opera &amp;gt;= 23&quot;
      ]
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;调试打包的代码 webapck通过配置可以自动给我们source maps文件，map文件是一种对应编译文件和源文件的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;devtool: ‘eval-source-map’&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. source-map 把映射文件生成到单独的文件，最完整最慢
2. cheap-module-source-map 在一个单独的文件中产生一个不带列映射的Map
3. eval-source-map 使用eval打包源文件模块,在同一个文件中生成完整sourcemap
4. cheap-module-eval-source-map sourcemap和打包后的JS同行显示，没有映射列
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;压缩js&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;webpack --mode production 会压缩，可以忽略下面
yarn add uglifyjs-webpack-plugin -D
const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin')
new UglifyjsWebpackPlugin(),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;压缩css&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;webpack --mode production 会压缩，可以忽略下面
{
    test: /\.css$/, // 转换文件的匹配正则
    use: ExtractTextWebpackPlugin.extract({
      fallback: 'style-loader',
      use: [
          {
             loader: 'css-laoder',
             options: {minimize: true}
          },
          'postcss-loader'
      ]
    })
},

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;清空打包输出目录&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add clean-webpack-plugin -D
const CleanWebpackPlugin = require('clean-webpack-plugin')
new CleanWebpackPlugin([path.join(__dirname, 'dist')]),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;区分环境变量 许多 library 将通过与 process.env.NODE_ENV 环境变量关联，以决定 library 中应该引用哪些内容。我们可以使用 webpack 内置的 DefinePlugin 为所有的依赖定义这个变量：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;scripts&quot;: {
    &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --mode development&quot;, // 设置NODE_ENV为production
    &quot;dev&quot;: &quot;webpack-dev-server --open --mode development &quot;
},
new webpack.DefinePlugin({
    NODE_ENV:JSON.stringify(process.env.NODE_ENV)
})
在全局都有NODE_ENV这个变量,当yarn run build,时，NODE_ENV = 'production'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;暴露全局变量&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new Webpack.ProvidePlugin({
  '$': 'jquery'
}),

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;resolve解析&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xtension: 指定extension之后可以不用在require或是import的时候加文件扩展名,会依次尝试添加扩展名进行匹配
resolve: {
    //自动补全后缀，注意第一个必须是空字符串,后缀一定以点开头
    extension: ['', '.js', '.json', '.css']
}
alias: 配置别名可以加快webpack查找模块的速度
resolve: {
    alias: {
        'bootstrap': 'bootstrap/dist/css/bootstrap.css'
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;复制静态资源&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add copy-webpack-plugin
const CopyWebpackPlugin = require('copy-webpack-plugin')
new CopyWebpackPlugin([
  {
    from: path.resolve(__dirname, 'static'),
    to: path.resolve(__dirname, 'pages/static'),
    ignore: ['.*']
  }
])

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><summary type="html">核心概念 Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。 Loader：模块转换器，用于把模块原内容按照需求转换成新内容。 Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。 WebPack、Grunt、Gulp？ Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。 Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。 Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。 如果实在要把二者进行比较，Webpack的处理速度更快更直接，能打包更多不同类型的文件。 执行流程 webpack启动后会在entry里配置的module开始递归解析entry所依赖的所有module，没找到一个module, 就会根据配置的loader去找相应的转换规则，对module进行转换后在解析当前module所依赖的module，这些模块会以entry为分组，一个entry和所有相依赖的module也就是一个chunk，最后webpack会把所有chunk转换成文件输出，在整个流程中webpack会在恰当的时机执行plugin的逻辑 从零配置webpack 初始化配置 mkdir webpack-start cd webpack-start npm init 配置webpack yarn add webpack webpack-cli -D //webpack4把webpack拆分了 mkdir src cd src 并且创建index.html, index.js mkdir dist touch webpack.config.js webpack.config.js module.exports = { entry: './src/index.js', //入口文件，src下的index.js output: { path: path.join(__dirname, 'dist'), // 出口目录，dist文件 filename: '[name].[hash].js' //这里name就是打包出来的文件名，因为是单入口，就是main，多入口下回分解 }, module: {}, plugin: {}, devServer: {} } 配置开发服务器 yarn add webpack-dev-server -D 修改webpack.config.js devServer: { contentBase: path.join(__dirname, &quot;dist&quot;), //静态文件根目录 port: 9090, // 端口 host: 'localhost', overlay: true, compress: true // 服务器返回浏览器的时候是否启动gzip压缩 } 修改package.json &quot;script&quot;: { &quot;build&quot;: &quot;webpack --mode development&quot;, //这里为了不压缩代码，用开发环境 &quot;dev&quot;: &quot;webpack-dev-server --open --mode development&quot; } 支持css文件 yarn add style-loader css-loader -D // css-loader用来处理css中url的路径 // style-loader可以把css文件变成style标签插入head中 // 多个loader是有顺序要求的，从右往左写，因为转换的时候是从右往左转换的 module: { rules: { test: /\.css$/, use: ['style-laoder', 'css-loader'], include: path.join(__dirname, 'src'), //限制范围，提高打包速度 exclude: /node_modules/ } } 支持es6，react.js等 yarn add babel-loader babel-core babel-preset-env babel-preset-stage-0 babel-preset -react -D { test: /\.js$/, use: { loader: 'babel-loader', query: { presets: ['env', 'stage-0', 'react'] // env转换es6 stage-0转es7 react转react } } } 同时可以把babel配置写到.babelrc中 从js中分离css yarn add extract-text-webpack-plugin -D { test: /\.css$/, // 转换文件的匹配正则 use: ExtractTextWebpackPlugin.extract({ fallback: 'style-loader', //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来 use: ['css-loader'] }) }, //加上plugin plugins: [ new ExtractTextWebpackPlugin({ filename: 'css/[name].[hash].css' //放到dist/css/下 }) ] 支持图片 yarn add file-loader url-loader -D file-loader 解决css等文件中引入图片路径的问题 url-loader 当图片较小的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝 { // file-loader是解析图片地址，把图片从源文件拷贝到目标文件并且修改源文件名字 // 可以处理任意二进制，bootstrap里的字体 // url-loader可以在文件比较小的时候，直接变成base64字符串内嵌到页面中 { test: /\.(png|jpg|jpeg|gif|svg)/, use: { loader: 'url-loader', options: { outputPath: 'images/', // 图片输出的路径 limit: 5 * 1024 } } }, // 同时要处理打包图片路径问题， output: { publicPath: '/' } 处理css3属性前缀 yarn add postcss-loader -D { test: /\.css$/, // 转换文件的匹配正则 // css-loader用来处理css中url的路径 // style-loader可以把css文件变成style标签插入head中 // 多个loader是有顺序要求的，从右往左写，因为转换的时候是从右往左转换的 // 此插件先用css-loader处理一下css文件 use: ExtractTextWebpackPlugin.extract({ fallback: 'style-loader', //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来 use: ['css-loader', 'postcss-loader'] }) }, 建立.postcssrc.js文件 module.exports = { &quot;plugins&quot;: { // to edit target browsers: use &quot;browserslist&quot; field in package.json &quot;autoprefixer&quot;: { &quot;browsers&quot;: [ &quot;ie &amp;gt;= 9&quot;, &quot;ff &amp;gt;= 30&quot;, &quot;chrome &amp;gt;= 34&quot;, &quot;safari &amp;gt;= 7&quot;, &quot;opera &amp;gt;= 23&quot; ] } } } 调试打包的代码 webapck通过配置可以自动给我们source maps文件，map文件是一种对应编译文件和源文件的方法 devtool: ‘eval-source-map’ 1. source-map 把映射文件生成到单独的文件，最完整最慢 2. cheap-module-source-map 在一个单独的文件中产生一个不带列映射的Map 3. eval-source-map 使用eval打包源文件模块,在同一个文件中生成完整sourcemap 4. cheap-module-eval-source-map sourcemap和打包后的JS同行显示，没有映射列 压缩js webpack --mode production 会压缩，可以忽略下面 yarn add uglifyjs-webpack-plugin -D const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin') new UglifyjsWebpackPlugin(), 压缩css webpack --mode production 会压缩，可以忽略下面 { test: /\.css$/, // 转换文件的匹配正则 use: ExtractTextWebpackPlugin.extract({ fallback: 'style-loader', use: [ { loader: 'css-laoder', options: {minimize: true} }, 'postcss-loader' ] }) }, 清空打包输出目录 yarn add clean-webpack-plugin -D const CleanWebpackPlugin = require('clean-webpack-plugin') new CleanWebpackPlugin([path.join(__dirname, 'dist')]), 区分环境变量 许多 library 将通过与 process.env.NODE_ENV 环境变量关联，以决定 library 中应该引用哪些内容。我们可以使用 webpack 内置的 DefinePlugin 为所有的依赖定义这个变量： &quot;scripts&quot;: { &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --mode development&quot;, // 设置NODE_ENV为production &quot;dev&quot;: &quot;webpack-dev-server --open --mode development &quot; }, new webpack.DefinePlugin({ NODE_ENV:JSON.stringify(process.env.NODE_ENV) }) 在全局都有NODE_ENV这个变量,当yarn run build,时，NODE_ENV = 'production' 暴露全局变量 new Webpack.ProvidePlugin({ '$': 'jquery' }), resolve解析 xtension: 指定extension之后可以不用在require或是import的时候加文件扩展名,会依次尝试添加扩展名进行匹配 resolve: { //自动补全后缀，注意第一个必须是空字符串,后缀一定以点开头 extension: ['', '.js', '.json', '.css'] } alias: 配置别名可以加快webpack查找模块的速度 resolve: { alias: { 'bootstrap': 'bootstrap/dist/css/bootstrap.css' } } 复制静态资源 yarn add copy-webpack-plugin const CopyWebpackPlugin = require('copy-webpack-plugin') new CopyWebpackPlugin([ { from: path.resolve(__dirname, 'static'), to: path.resolve(__dirname, 'pages/static'), ignore: ['.*'] } ])</summary></entry><entry><title type="html">instanceof 和 typeof 的实现原理</title><link href="http://localhost:4000/2018/06/08/instanceof%E5%92%8Ctypeof%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" rel="alternate" type="text/html" title="instanceof 和 typeof 的实现原理" /><published>2018-06-08T00:00:00+08:00</published><updated>2018-06-08T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/08/instanceof%E5%92%8Ctypeof%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86</id><content type="html" xml:base="http://localhost:4000/2018/06/08/instanceof%E5%92%8Ctypeof%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html">&lt;p&gt;这周老大分享了有关原生JS的基础内容，这次我也跟风补一下相关知识。&lt;/p&gt;

&lt;h2 id=&quot;typeof-实现原理&quot;&gt;typeof 实现原理&lt;/h2&gt;

&lt;p&gt;typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let s = new String('abc');
typeof s === 'object'// true
s instanceof String // true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要想判断一个数据具体是哪一种 object 的时候，我们需要利用 instanceof 这个操作符来判断，这个我们后面会说到。&lt;/p&gt;

&lt;p&gt;来谈谈关于 typeof 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？&lt;/p&gt;

&lt;p&gt;其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;000：对象&lt;/li&gt;
  &lt;li&gt;010：浮点数&lt;/li&gt;
  &lt;li&gt;100：字符串&lt;/li&gt;
  &lt;li&gt;110：布尔&lt;/li&gt;
  &lt;li&gt;1：整数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;null：所有机器码均为0&lt;/li&gt;
  &lt;li&gt;undefined：用 −2^30 整数来表示&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待。&lt;/p&gt;

&lt;p&gt;然而用 instanceof 来判断的话&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;null instanceof null // TypeError: Right-hand side of 'instanceof' is not an object

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;null 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考typeof。&lt;/p&gt;

&lt;p&gt;因此在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括symbol），避免对 null 的判断。&lt;/p&gt;

&lt;p&gt;还有一个不错的判断类型的方法，就是Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object.prototype.toString.call(1) // &quot;[object Number]&quot;
Object.prototype.toString.call('hi') // &quot;[object String]&quot;
Object.prototype.toString.call({a:'hi'}) // &quot;[object Object]&quot;
Object.prototype.toString.call([1,'a']) // &quot;[object Array]&quot;
Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;
Object.prototype.toString.call(() =&amp;gt; {}) // &quot;[object Function]&quot;
Object.prototype.toString.call(null) // &quot;[object Null]&quot;
Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;
Object.prototype.toString.call(Symbol(1)) // &quot;[object Symbol]&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;instanceof-操作符的实现原理&quot;&gt;instanceof 操作符的实现原理&lt;/h2&gt;

&lt;p&gt;之前我们提到了 instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let person = function () {
}
let nicole = new person()
nicole instanceof person // true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let person = function () { }
let programmer = function () { }
programmer.prototype = new person()
let nicole = new programmer()
nicole instanceof person // true
nicole instanceof programmer // true

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这是 instanceof 的用法，但是 instanceof 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function new_instance_of(leftVaule, rightVaule) { 
    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
    while (true) {
        if (leftVaule === null) {
            return false;    
        }
        if (leftVaule === rightProto) {
            return true;    
        } 
        leftVaule = leftVaule.__proto__ 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。&lt;/p&gt;

&lt;p&gt;看几个很有趣的例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Foo() {
}
Object instanceof Object // true
Function instanceof Function // true
Function instanceof Object // true
Foo instanceof Foo // false
Foo instanceof Object // true
Foo instanceof Function // true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要想全部理解 instanceof 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。&lt;/p&gt;

&lt;p&gt;关于原型继承的原理，我简单用一张图来表示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180608/20180608-1.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个 JavaScript 对象均有一个隐式的 &lt;strong&gt;proto&lt;/strong&gt; 原型属性，而显式的原型属性是 prototype，只有 Object.prototype.&lt;strong&gt;proto&lt;/strong&gt; 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 instanceof 使用的例子。&lt;/p&gt;

&lt;p&gt;Object instanceof Object&lt;/p&gt;

&lt;p&gt;由图可知，Object 的 prototype 属性是 Object.prototype, 而由于 Object 本身是一个函数，由 Function 所创建，所以 Object.&lt;strong&gt;proto&lt;/strong&gt; 的值是 Function.prototype，而 Function.prototype 的 &lt;strong&gt;proto&lt;/strong&gt; 属性是 Object.prototype，所以我们可以判断出，Object instanceof Object 的结果是 true 。用代码简单的表示一下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;leftValue = Object.__proto__ = Function.prototype;
rightValue = Object.prototype;
// 第一次判断
leftValue != rightValue
leftValue = Function.prototype.__proto__ = Object.prototype
// 第二次判断
leftValue === rightValue
// 返回 true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Function instanceof Function 和 Function instanceof Object 的运行过程与 Object instanceof Object 类似，故不再详说。&lt;/p&gt;

&lt;p&gt;Foo instanceof Foo&lt;/p&gt;

&lt;p&gt;Foo 函数的 prototype 属性是 Foo.prototype，而 Foo 的 &lt;strong&gt;proto&lt;/strong&gt; 属性是 Function.prototype，由图可知，Foo 的原型链上并没有 Foo.prototype ，因此 Foo instanceof Foo 也就返回 false 。&lt;/p&gt;

&lt;p&gt;我们用代码简单的表示一下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;leftValue = Foo, rightValue = Foo
leftValue = Foo.__proto = Function.prototype
rightValue = Foo.prototype
// 第一次判断
leftValue != rightValue
leftValue = Function.prototype.__proto__ = Object.prototype
// 第二次判断
leftValue != rightValue
leftValue = Object.prototype = null
// 第三次判断
leftValue === null
// 返回 false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Foo instanceof Object&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;leftValue = Foo, rightValue = Object
leftValue = Foo.__proto__ = Function.prototype
rightValue = Object.prototype
// 第一次判断
leftValue != rightValue
leftValue = Function.prototype.__proto__ = Object.prototype
// 第二次判断
leftValue === rightValue
// 返回 true 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Foo instanceof Function&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;leftValue = Foo, rightValue = Function
leftValue = Foo.__proto__ = Function.prototype
rightValue = Function.prototype
// 第一次判断
leftValue === rightValue
// 返回 true 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;简单来说，使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。&lt;/p&gt;</content><author><name>weili</name></author><category term="JS" /><summary type="html">这周老大分享了有关原生JS的基础内容，这次我也跟风补一下相关知识。 typeof 实现原理 typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如 let s = new String('abc'); typeof s === 'object'// true s instanceof String // true 要想判断一个数据具体是哪一种 object 的时候，我们需要利用 instanceof 这个操作符来判断，这个我们后面会说到。 来谈谈关于 typeof 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？ 其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。 null：所有机器码均为0 undefined：用 −2^30 整数来表示 所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待。 然而用 instanceof 来判断的话 null instanceof null // TypeError: Right-hand side of 'instanceof' is not an object null 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考typeof。 因此在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括symbol），避免对 null 的判断。 还有一个不错的判断类型的方法，就是Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断 Object.prototype.toString.call(1) // &quot;[object Number]&quot; Object.prototype.toString.call('hi') // &quot;[object String]&quot; Object.prototype.toString.call({a:'hi'}) // &quot;[object Object]&quot; Object.prototype.toString.call([1,'a']) // &quot;[object Array]&quot; Object.prototype.toString.call(true) // &quot;[object Boolean]&quot; Object.prototype.toString.call(() =&amp;gt; {}) // &quot;[object Function]&quot; Object.prototype.toString.call(null) // &quot;[object Null]&quot; Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot; Object.prototype.toString.call(Symbol(1)) // &quot;[object Symbol]&quot; instanceof 操作符的实现原理 之前我们提到了 instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型 let person = function () { } let nicole = new person() nicole instanceof person // true 当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。 let person = function () { } let programmer = function () { } programmer.prototype = new person() let nicole = new programmer() nicole instanceof person // true nicole instanceof programmer // true 这是 instanceof 的用法，但是 instanceof 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下 function new_instance_of(leftVaule, rightVaule) { let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值 leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值 while (true) { if (leftVaule === null) { return false; } if (leftVaule === rightProto) { return true; } leftVaule = leftVaule.__proto__ } } 其实 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。 看几个很有趣的例子 function Foo() { } Object instanceof Object // true Function instanceof Function // true Function instanceof Object // true Foo instanceof Foo // false Foo instanceof Object // true Foo instanceof Function // true 要想全部理解 instanceof 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。 关于原型继承的原理，我简单用一张图来表示 每个 JavaScript 对象均有一个隐式的 proto 原型属性，而显式的原型属性是 prototype，只有 Object.prototype.proto 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 instanceof 使用的例子。 Object instanceof Object 由图可知，Object 的 prototype 属性是 Object.prototype, 而由于 Object 本身是一个函数，由 Function 所创建，所以 Object.proto 的值是 Function.prototype，而 Function.prototype 的 proto 属性是 Object.prototype，所以我们可以判断出，Object instanceof Object 的结果是 true 。用代码简单的表示一下 leftValue = Object.__proto__ = Function.prototype; rightValue = Object.prototype; // 第一次判断 leftValue != rightValue leftValue = Function.prototype.__proto__ = Object.prototype // 第二次判断 leftValue === rightValue // 返回 true Function instanceof Function 和 Function instanceof Object 的运行过程与 Object instanceof Object 类似，故不再详说。 Foo instanceof Foo Foo 函数的 prototype 属性是 Foo.prototype，而 Foo 的 proto 属性是 Function.prototype，由图可知，Foo 的原型链上并没有 Foo.prototype ，因此 Foo instanceof Foo 也就返回 false 。 我们用代码简单的表示一下 leftValue = Foo, rightValue = Foo leftValue = Foo.__proto = Function.prototype rightValue = Foo.prototype // 第一次判断 leftValue != rightValue leftValue = Function.prototype.__proto__ = Object.prototype // 第二次判断 leftValue != rightValue leftValue = Object.prototype = null // 第三次判断 leftValue === null // 返回 false Foo instanceof Object leftValue = Foo, rightValue = Object leftValue = Foo.__proto__ = Function.prototype rightValue = Object.prototype // 第一次判断 leftValue != rightValue leftValue = Function.prototype.__proto__ = Object.prototype // 第二次判断 leftValue === rightValue // 返回 true Foo instanceof Function leftValue = Foo, rightValue = Function leftValue = Foo.__proto__ = Function.prototype rightValue = Function.prototype // 第一次判断 leftValue === rightValue // 返回 true 简单来说，使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。</summary></entry><entry><title type="html">React 组件的性能优化</title><link href="http://localhost:4000/2018/06/02/react_performance.html" rel="alternate" type="text/html" title="React 组件的性能优化" /><published>2018-06-02T00:00:00+08:00</published><updated>2018-06-02T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/02/react_performance</id><content type="html" xml:base="http://localhost:4000/2018/06/02/react_performance.html">&lt;p&gt;虽然react已经提供了很好的渲染性能，但要让程序发挥到极致，还需要进一步了解性能优化的方法，本章节主要从三个方面讲解：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单个react组件的性能优化&lt;/li&gt;
  &lt;li&gt;多个react组件的性能优化&lt;/li&gt;
  &lt;li&gt;用reselect提高数据获取性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;单个react组件的性能优化&quot;&gt;单个react组件的性能优化&lt;/h2&gt;

&lt;p&gt;react渲染之所以快，是因为利用Virtual DOM来计算出DOM树的最少修改，只渲染修改的部分，而不是所有。&lt;/p&gt;

&lt;p&gt;如果能够在开始计算Virtual DOM之前就可以判断结果不会变化，那干脆不要再去计算和比较，速度就会更快。&lt;/p&gt;

&lt;h3 id=&quot;借助react-perf工具发现浪费的渲染时间&quot;&gt;借助react perf工具，发现浪费的渲染时间&lt;/h3&gt;

&lt;p&gt;react perf 这个工具的安装和使用这里不再讲述。&lt;/p&gt;

&lt;p&gt;这个工具记录在点击start和stop按钮之间的所有react的渲染，如果有组件计算Virtual DOM之后，和之前的Virtual DOM相同，就认为是一次浪费。&lt;/p&gt;

&lt;p&gt;这里所说的浪费是计算Virtual DOM的浪费，并不是访问DOM的浪费。&lt;/p&gt;

&lt;p&gt;可以借助这个工具清晰的知道哪个组件被无意义的渲染了，达到优化性能的目的。&lt;/p&gt;

&lt;h3 id=&quot;性能优化的时机&quot;&gt;性能优化的时机&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;过早的优化是万恶之源—–高德纳&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很多人对这句话有个错误的认识，认为高前辈不让做过早的优化，很显然我们误会老高了，他的全句是这样的&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“我们应该忘记忽略很小的性能优化，可以说97%的情况下，过早的优化是万恶之源，而我们应该关心对性能影响最关键的那另外3%的代码”—–高德纳&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前辈的这句话有三个重要的点：&lt;/p&gt;

&lt;p&gt;1、不要把精力放在对整体性能优化提高不大的代码上，而对于性能有关键影响的部分，优化并不嫌早。&lt;/p&gt;

&lt;p&gt;2、所谓过早的优化，是指在没有任何数据体现下开发者对性能优化的猜测，没有可测量的性能指标，完成优化后，也不知道是否达到了预期的结果。&lt;/p&gt;

&lt;p&gt;3、高德纳认为过早的优化是万恶之源，是因为这些优化往往让代码过于复杂和难于维护，但如果早期的优化能够让代码结构更加合理更加容易维护，为什么不呢？&lt;/p&gt;

&lt;h2 id=&quot;多个react组件的性能优化&quot;&gt;多个react组件的性能优化&lt;/h2&gt;

&lt;p&gt;多个组件和单个组件一样，都需要经历组件装载、更新、卸载三个步骤。&lt;/p&gt;

&lt;p&gt;其中装载这个部分没有什么可以性能优化的事情做，卸载部分是会出现组件加载后添加的事件监听等收尾工作，也没有太多的可优化空间。&lt;/p&gt;

&lt;p&gt;重要的放在更新过程。&lt;/p&gt;

&lt;h3 id=&quot;react的调和过程&quot;&gt;react的调和过程&lt;/h3&gt;

&lt;p&gt;什么叫调和？&lt;/p&gt;

&lt;p&gt;就是render后和更新后，生成的这个树，相互比较找不同，这个找不同的过程就叫调和。&lt;/p&gt;

&lt;p&gt;react怎么找不同呢？&lt;/p&gt;

&lt;p&gt;1、先检查两个节点的类型&lt;/p&gt;

&lt;p&gt;这个类型分为两类：一类是dom元素类型，就是div span； 另一类是react组件，也就是利用react库定制的类型。&lt;/p&gt;

&lt;p&gt;1.1  如果不同&lt;/p&gt;

&lt;p&gt;举个例子，组件包裹外层原来是div，更新为span，这个时候，react一看这完全不相同，那后面的子节点也别看了，直接重新构建一份吧，这就造成了性能上面的浪费。&lt;/p&gt;

&lt;p&gt;解决办法：作为开发者尽量不要改动做为包裹层的类型。&lt;/p&gt;

&lt;p&gt;1.2 如果相同&lt;/p&gt;

&lt;p&gt;上面说了类型有两种，如果是dom类型加同，就只对比这个节点的属性和内容，然后更新修改的部分，如下面的代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;原来的：

&amp;lt;div style=&amp;gt;hello&amp;lt;/div&amp;gt;

更改后的：

&amp;lt;div style=&amp;gt;hello&amp;lt;/div&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;DOM节点类型没变，只需要修改它的属性，变动少。&lt;/p&gt;

&lt;p&gt;另外一种类型是react组件类型，它更新时只能根据新节点的props去更新原来的组件，引发这个组件实例的更新过程，按照下面的顺序引发下面的函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;shouldComponentUpdate&lt;/li&gt;
  &lt;li&gt;componentWillReceiveProps&lt;/li&gt;
  &lt;li&gt;componentWillUpdate&lt;/li&gt;
  &lt;li&gt;render&lt;/li&gt;
  &lt;li&gt;componentDidUpdate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个时候就需要合理的使用shouldComonentUpdate函数了，如果没有必要渲染，就返回false。&lt;/p&gt;

&lt;p&gt;好了，对比了根节点之后，会对这个根节点的每一个小节点重复相同的动作，该更新更新，该创建创建。&lt;/p&gt;

&lt;p&gt;2、key的作用&lt;/p&gt;

&lt;p&gt;key就相当于组件的身份证号，标识组件的位置，react可以根据根据key值的有无变化，从而决定是否更新它。&lt;/p&gt;

&lt;p&gt;这个时候注意个问题，在循环一个数组时，不能以数组的下标做为key值定义每个子组件，key值变来变去的无规则也会引起不必要的重新加载或者更新创建。&lt;/p&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><category term="深入浅出React和Redux读书笔记" /><summary type="html">虽然react已经提供了很好的渲染性能，但要让程序发挥到极致，还需要进一步了解性能优化的方法，本章节主要从三个方面讲解： 单个react组件的性能优化 多个react组件的性能优化 用reselect提高数据获取性能 单个react组件的性能优化 react渲染之所以快，是因为利用Virtual DOM来计算出DOM树的最少修改，只渲染修改的部分，而不是所有。 如果能够在开始计算Virtual DOM之前就可以判断结果不会变化，那干脆不要再去计算和比较，速度就会更快。 借助react perf工具，发现浪费的渲染时间 react perf 这个工具的安装和使用这里不再讲述。 这个工具记录在点击start和stop按钮之间的所有react的渲染，如果有组件计算Virtual DOM之后，和之前的Virtual DOM相同，就认为是一次浪费。 这里所说的浪费是计算Virtual DOM的浪费，并不是访问DOM的浪费。 可以借助这个工具清晰的知道哪个组件被无意义的渲染了，达到优化性能的目的。 性能优化的时机 过早的优化是万恶之源—–高德纳 很多人对这句话有个错误的认识，认为高前辈不让做过早的优化，很显然我们误会老高了，他的全句是这样的 “我们应该忘记忽略很小的性能优化，可以说97%的情况下，过早的优化是万恶之源，而我们应该关心对性能影响最关键的那另外3%的代码”—–高德纳 前辈的这句话有三个重要的点： 1、不要把精力放在对整体性能优化提高不大的代码上，而对于性能有关键影响的部分，优化并不嫌早。 2、所谓过早的优化，是指在没有任何数据体现下开发者对性能优化的猜测，没有可测量的性能指标，完成优化后，也不知道是否达到了预期的结果。 3、高德纳认为过早的优化是万恶之源，是因为这些优化往往让代码过于复杂和难于维护，但如果早期的优化能够让代码结构更加合理更加容易维护，为什么不呢？ 多个react组件的性能优化 多个组件和单个组件一样，都需要经历组件装载、更新、卸载三个步骤。 其中装载这个部分没有什么可以性能优化的事情做，卸载部分是会出现组件加载后添加的事件监听等收尾工作，也没有太多的可优化空间。 重要的放在更新过程。 react的调和过程 什么叫调和？ 就是render后和更新后，生成的这个树，相互比较找不同，这个找不同的过程就叫调和。 react怎么找不同呢？ 1、先检查两个节点的类型 这个类型分为两类：一类是dom元素类型，就是div span； 另一类是react组件，也就是利用react库定制的类型。 1.1 如果不同 举个例子，组件包裹外层原来是div，更新为span，这个时候，react一看这完全不相同，那后面的子节点也别看了，直接重新构建一份吧，这就造成了性能上面的浪费。 解决办法：作为开发者尽量不要改动做为包裹层的类型。 1.2 如果相同 上面说了类型有两种，如果是dom类型加同，就只对比这个节点的属性和内容，然后更新修改的部分，如下面的代码 原来的： &amp;lt;div style=&amp;gt;hello&amp;lt;/div&amp;gt; 更改后的： &amp;lt;div style=&amp;gt;hello&amp;lt;/div&amp;gt; DOM节点类型没变，只需要修改它的属性，变动少。 另外一种类型是react组件类型，它更新时只能根据新节点的props去更新原来的组件，引发这个组件实例的更新过程，按照下面的顺序引发下面的函数： shouldComponentUpdate componentWillReceiveProps componentWillUpdate render componentDidUpdate 这个时候就需要合理的使用shouldComonentUpdate函数了，如果没有必要渲染，就返回false。 好了，对比了根节点之后，会对这个根节点的每一个小节点重复相同的动作，该更新更新，该创建创建。 2、key的作用 key就相当于组件的身份证号，标识组件的位置，react可以根据根据key值的有无变化，从而决定是否更新它。 这个时候注意个问题，在循环一个数组时，不能以数组的下标做为key值定义每个子组件，key值变来变去的无规则也会引起不必要的重新加载或者更新创建。</summary></entry></feed>