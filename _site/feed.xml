<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.7.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2018-07-06T16:17:34+08:00</updated><id>http://localhost:4000/</id><title type="html">Weili’s Blog</title><subtitle>Weili's blog
</subtitle><author><name>weili</name></author><entry><title type="html">TypeScript (二)</title><link href="http://localhost:4000/2018/07/06/TypeScript_2.html" rel="alternate" type="text/html" title="TypeScript (二)" /><published>2018-07-06T00:00:00+08:00</published><updated>2018-07-06T00:00:00+08:00</updated><id>http://localhost:4000/2018/07/06/TypeScript_2</id><content type="html" xml:base="http://localhost:4000/2018/07/06/TypeScript_2.html">&lt;p&gt;TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。&lt;/p&gt;

&lt;h2 id=&quot;基础类型&quot;&gt;基础类型&lt;/h2&gt;

&lt;h3 id=&quot;布尔值&quot;&gt;布尔值&lt;/h3&gt;

&lt;p&gt;最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let isDone: boolean = false;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数值&quot;&gt;数值&lt;/h3&gt;

&lt;p&gt;和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;字符串&quot;&gt;字符串&lt;/h3&gt;

&lt;p&gt;和JavaScript一样，可以使用双引号（ “）或单引号（’）表示字符串&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let name: string = &quot;bob&quot;;
name = &quot;smith&quot;;


//模版字符串

let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is ${ name }.

I'll be ${ age + 1 } years old next month.`;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数组&quot;&gt;数组&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// array
let list_a: number[] = [1, 2, 3]
let list_b: Array&amp;lt;number&amp;gt; = [1, 2, 3] // number 类型的数组
let list_c: [string, number] = ['linkFly', 0] //元组
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;枚举&quot;&gt;枚举&lt;/h3&gt;

&lt;p&gt;enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum Color {Red, Green, Blue}
let c: Color = Color.Green;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;any&quot;&gt;Any&lt;/h3&gt;

&lt;p&gt;有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let notSure: any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false; // okay, definitely a boolean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let list: any[] = [1, true, &quot;free&quot;];

list[1] = 100;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;void&quot;&gt;Void&lt;/h3&gt;

&lt;p&gt;void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function warnUser(): void {
    alert(&quot;This is my warning message&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let unusable: void = undefined;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;null-和-undefined&quot;&gt;Null 和 Undefined&lt;/h3&gt;

&lt;p&gt;TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：&lt;/p&gt;

&lt;p&gt;默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Not much else we can assign to these variables!
let u: undefined = undefined;
let n: null = null;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;never&quot;&gt;Never&lt;/h3&gt;

&lt;p&gt;never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。&lt;/p&gt;

&lt;p&gt;never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
    return error(&quot;Something failed&quot;);
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;类型断言&quot;&gt;类型断言&lt;/h2&gt;

&lt;p&gt;通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。&lt;/p&gt;

&lt;p&gt;类型断言有两种形式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“尖括号”&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let someValue: any = &quot;this is a string&quot;;

let strLength: number = (&amp;lt;string&amp;gt;someValue).length;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;as&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let someValue: any = &quot;this is a string&quot;;

let strLength: number = (someValue as string).length;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><summary type="html">TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 基础类型 布尔值 最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean let isDone: boolean = false; 数值 和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。 let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; 字符串 和JavaScript一样，可以使用双引号（ “）或单引号（’）表示字符串 let name: string = &quot;bob&quot;; name = &quot;smith&quot;; //模版字符串 let name: string = `Gene`; let age: number = 37; let sentence: string = `Hello, my name is ${ name }. I'll be ${ age + 1 } years old next month.`; 数组 // array let list_a: number[] = [1, 2, 3] let list_b: Array&amp;lt;number&amp;gt; = [1, 2, 3] // number 类型的数组 let list_c: [string, number] = ['linkFly', 0] //元组 枚举 enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 enum Color {Red, Green, Blue} let c: Color = Color.Green; Any 有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量： let notSure: any = 4; notSure = &quot;maybe a string instead&quot;; notSure = false; // okay, definitely a boolean 在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法： let notSure: any = 4; notSure.ifItExists(); // okay, ifItExists might exist at runtime notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check) let prettySure: Object = 4; prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'. 当只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： let list: any[] = [1, true, &quot;free&quot;]; list[1] = 100; Void void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void function warnUser(): void { alert(&quot;This is my warning message&quot;); } 声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null： let unusable: void = undefined; Null 和 Undefined TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大： 默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。 // Not much else we can assign to these variables! let u: undefined = undefined; let n: null = null; Never never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。 // 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为never function fail() { return error(&quot;Something failed&quot;); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } 类型断言 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。 类型断言有两种形式。 “尖括号” let someValue: any = &quot;this is a string&quot;; let strLength: number = (&amp;lt;string&amp;gt;someValue).length; as let someValue: any = &quot;this is a string&quot;; let strLength: number = (someValue as string).length;</summary></entry><entry><title type="html">TypeScript (一)</title><link href="http://localhost:4000/2018/06/30/TypeScript_1.html" rel="alternate" type="text/html" title="TypeScript (一)" /><published>2018-06-30T00:00:00+08:00</published><updated>2018-06-30T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/30/TypeScript_1</id><content type="html" xml:base="http://localhost:4000/2018/06/30/TypeScript_1.html">&lt;h2 id=&quot;什么是-typescript&quot;&gt;什么是 TypeScript&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上。&lt;/p&gt;

&lt;h2 id=&quot;typescript-优势&quot;&gt;TypeScript 优势&lt;/h2&gt;

&lt;p&gt;TypeScript 增加了代码的可读性和可维护性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了&lt;/li&gt;
  &lt;li&gt;可以在编译阶段就发现大部分错误，这总比在运行时候出错好&lt;/li&gt;
  &lt;li&gt;增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;typescript-包容性强&quot;&gt;TypeScript 包容性强&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可&lt;/li&gt;
  &lt;li&gt;即使不显式的定义类型，也能够自动做出类型推论&lt;/li&gt;
  &lt;li&gt;可以定义从简单到复杂的一切类型&lt;/li&gt;
  &lt;li&gt;即使 TypeScript 编译报错，也可以生成 JavaScript 文件&lt;/li&gt;
  &lt;li&gt;兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;typescript-的缺点&quot;&gt;TypeScript 的缺点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的东西。而且它的中文资料也不多&lt;/li&gt;
  &lt;li&gt;短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本&lt;/li&gt;
  &lt;li&gt;集成到构建流程需要一些工作量&lt;/li&gt;
  &lt;li&gt;可能和一些库结合的不是很完美&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;安装-typescript&quot;&gt;安装 TypeScript&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;TypeScript 的命令行工具安装方法如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install -g typescript
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编译一个 TypeScript 文件：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tsc hello.ts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 TypeScript 编写的文件以 .ts 为后缀&lt;/p&gt;

&lt;h2 id=&quot;一个完整的例子&quot;&gt;一个完整的例子&lt;/h2&gt;

&lt;p&gt;一个hello.ts命名的TypeScript文件，代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function sayHello(person: string) {
    return 'Hello, ' + person;
}

let user = 'Tom';
console.log(sayHello(user));

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tsc hello.ts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;会生成一个编译好的文件 hello.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function sayHello(person) {
    return 'Hello, ' + person;
}
var user = 'Tom';
console.log(sayHello(user));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><summary type="html">什么是 TypeScript TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。 TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上。 TypeScript 优势 TypeScript 增加了代码的可读性和可维护性 类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了 可以在编译阶段就发现大部分错误，这总比在运行时候出错好 增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等 TypeScript 包容性强 TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可 即使不显式的定义类型，也能够自动做出类型推论 可以定义从简单到复杂的一切类型 即使 TypeScript 编译报错，也可以生成 JavaScript 文件 兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取 TypeScript 的缺点 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的东西。而且它的中文资料也不多 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本 集成到构建流程需要一些工作量 可能和一些库结合的不是很完美 安装 TypeScript TypeScript 的命令行工具安装方法如下： npm install -g typescript 以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。 编译一个 TypeScript 文件： tsc hello.ts 使用 TypeScript 编写的文件以 .ts 为后缀 一个完整的例子 一个hello.ts命名的TypeScript文件，代码如下 function sayHello(person: string) { return 'Hello, ' + person; } let user = 'Tom'; console.log(sayHello(user)); 然后执行 tsc hello.ts 会生成一个编译好的文件 hello.js function sayHello(person) { return 'Hello, ' + person; } var user = 'Tom'; console.log(sayHello(user));</summary></entry><entry><title type="html">webpack4—高级篇</title><link href="http://localhost:4000/2018/06/22/webpack4_%E9%AB%98%E7%BA%A7.html" rel="alternate" type="text/html" title="webpack4---高级篇" /><published>2018-06-22T00:00:00+08:00</published><updated>2018-06-22T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/22/webpack4_%E9%AB%98%E7%BA%A7</id><content type="html" xml:base="http://localhost:4000/2018/06/22/webpack4_%E9%AB%98%E7%BA%A7.html">&lt;h2 id=&quot;tree-shaking&quot;&gt;Tree Shaking&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;css Tree Shaking&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add purify-css purifycss-webpack -D
const glob = require('glob')
const PurifyCSSPlugin = require('purifycss-webpack')
// 去除无用的css
plugins: [
    new PurifyCSSPlugin({
      // 路劲扫描 nodejs内置 路劲检查
      paths: glob.sync(path.join(__dirname, 'pages/*/*.html'))
    })
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;js优化&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add webpack-parallel-uglify-plugin -D
const WebpackParallelUglifyPlugin = require('webpack-parallel-uglify-plugin')
plugins: [
new WebpackParallelUglifyPlugin({
      uglifyJS: {
        output: {
          beautify: false, //不需要格式化
          comments: false //不保留注释
        },
        compress: {
          warnings: false, // 在UglifyJs删除没有用到的代码时不输出警告
          drop_console: true, // 删除所有的 `console` 语句，可以兼容ie浏览器
          collapse_vars: true, // 内嵌定义了但是只用到一次的变量
          reduce_vars: true // 提取出出现多次但是没有定义成变量去引用的静态值
        }
      }
    })
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;提取公共代码&quot;&gt;提取公共代码&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// webpack4最新配置，可以搜索关键字查查配置项
  optimization: {
    splitChunks: {
      cacheGroups: {
        commons: {
          chunks: 'initial',
          minChunks: 2,
          maxInitialRequests: 5, // The default limit is too small to showcase the effect
          minSize: 0, // This is example is too small to create commons chunks
          name: 'common'
        }
      }
    }
  },

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;打包第三方类库&quot;&gt;打包第三方类库&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;DllPlugin插件： 用于打包出一个个动态连接库&lt;/li&gt;
  &lt;li&gt;DllReferencePlugin: 在配置文件中引入DllPlugin插件打包好的动态连接库&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在package.json中
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --mode development&quot;,
    &quot;build:dll&quot;: &quot;webpack --config webpack.dll.config.js --mode development&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server --open --mode development&quot;
  }
新建webpack.dll.config.js  
const path = require('path')
const webpack = require('webpack')

/**
 * 尽量减小搜索范围
 * target: '_dll_[name]' 指定导出变量名字
 */

 module.exports = {
   entry: {
     vendor: ['jquery', 'lodash']
   },
   output: {
     path: path.join(__dirname, 'static'),
     filename: '[name].dll.js',
     library: '_dll_[name]' // 全局变量名，其他模块会从此变量上获取里面模块
   },
   // manifest是描述文件
   plugins: [
     new webpack.DllPlugin({
       name: '_dll_[name]',
       path: path.join(__dirname, 'manifest.json')
     })
   ]
 }
 
在webpack.config.js中
plugins: [
    new webpack.DllReferencePlugin({
        manifest: path.join(__dirname, 'manifest.json')
    })
]
执行npm run build:dll 就可以打包第三方包了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用happypack&quot;&gt;使用happypack&lt;/h2&gt;

&lt;p&gt;HappyPack就能让Webpack把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 happypack&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i happypack@next -D
const HappyPack = require('happypack')
const os = require('os')
const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length })

  {
    test: /\.js$/,
    // loader: 'babel-loader',
    loader: 'happypack/loader?id=happy-babel-js', // 增加新的HappyPack构建loader
    include: [resolve('src')],
    exclude: /node_modules/,
  }
  
  plugins: [
    new HappyPack({
      id: 'happy-babel-js',
      loaders: ['babel-loader?cacheDirectory=true'],
      threadPool: happyThreadPool
    })
]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;显示打包时间&quot;&gt;显示打包时间&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add progress-bar-webpack-plugin -D
const ProgressBarPlugin = require('progress-bar-webpack-plugin')
plugins: [
    new ProgressBarPlugin({
      format: '  build [:bar] ' + chalk.green.bold(':percent') + ' (:elapsed seconds)'
    })
]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><summary type="html">Tree Shaking css Tree Shaking yarn add purify-css purifycss-webpack -D const glob = require('glob') const PurifyCSSPlugin = require('purifycss-webpack') // 去除无用的css plugins: [ new PurifyCSSPlugin({ // 路劲扫描 nodejs内置 路劲检查 paths: glob.sync(path.join(__dirname, 'pages/*/*.html')) }) ] js优化 yarn add webpack-parallel-uglify-plugin -D const WebpackParallelUglifyPlugin = require('webpack-parallel-uglify-plugin') plugins: [ new WebpackParallelUglifyPlugin({ uglifyJS: { output: { beautify: false, //不需要格式化 comments: false //不保留注释 }, compress: { warnings: false, // 在UglifyJs删除没有用到的代码时不输出警告 drop_console: true, // 删除所有的 `console` 语句，可以兼容ie浏览器 collapse_vars: true, // 内嵌定义了但是只用到一次的变量 reduce_vars: true // 提取出出现多次但是没有定义成变量去引用的静态值 } } }) ] 提取公共代码 // webpack4最新配置，可以搜索关键字查查配置项 optimization: { splitChunks: { cacheGroups: { commons: { chunks: 'initial', minChunks: 2, maxInitialRequests: 5, // The default limit is too small to showcase the effect minSize: 0, // This is example is too small to create commons chunks name: 'common' } } } }, 打包第三方类库 DllPlugin插件： 用于打包出一个个动态连接库 DllReferencePlugin: 在配置文件中引入DllPlugin插件打包好的动态连接库 在package.json中 &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack --mode development&quot;, &quot;build:dll&quot;: &quot;webpack --config webpack.dll.config.js --mode development&quot;, &quot;dev&quot;: &quot;webpack-dev-server --open --mode development&quot; } 新建webpack.dll.config.js const path = require('path') const webpack = require('webpack') /** * 尽量减小搜索范围 * target: '_dll_[name]' 指定导出变量名字 */ module.exports = { entry: { vendor: ['jquery', 'lodash'] }, output: { path: path.join(__dirname, 'static'), filename: '[name].dll.js', library: '_dll_[name]' // 全局变量名，其他模块会从此变量上获取里面模块 }, // manifest是描述文件 plugins: [ new webpack.DllPlugin({ name: '_dll_[name]', path: path.join(__dirname, 'manifest.json') }) ] } 在webpack.config.js中 plugins: [ new webpack.DllReferencePlugin({ manifest: path.join(__dirname, 'manifest.json') }) ] 执行npm run build:dll 就可以打包第三方包了 使用happypack HappyPack就能让Webpack把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。 happypack npm i happypack@next -D const HappyPack = require('happypack') const os = require('os') const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length }) { test: /\.js$/, // loader: 'babel-loader', loader: 'happypack/loader?id=happy-babel-js', // 增加新的HappyPack构建loader include: [resolve('src')], exclude: /node_modules/, } plugins: [ new HappyPack({ id: 'happy-babel-js', loaders: ['babel-loader?cacheDirectory=true'], threadPool: happyThreadPool }) ] 显示打包时间 yarn add progress-bar-webpack-plugin -D const ProgressBarPlugin = require('progress-bar-webpack-plugin') plugins: [ new ProgressBarPlugin({ format: ' build [:bar] ' + chalk.green.bold(':percent') + ' (:elapsed seconds)' }) ]</summary></entry><entry><title type="html">webpack4—基础篇</title><link href="http://localhost:4000/2018/06/15/webpack4_%E5%9F%BA%E7%A1%80.html" rel="alternate" type="text/html" title="webpack4---基础篇" /><published>2018-06-15T00:00:00+08:00</published><updated>2018-06-15T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/15/webpack4_%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="http://localhost:4000/2018/06/15/webpack4_%E5%9F%BA%E7%A1%80.html">&lt;h2 id=&quot;核心概念&quot;&gt;核心概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。&lt;/li&gt;
  &lt;li&gt;Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。&lt;/li&gt;
  &lt;li&gt;Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。&lt;/li&gt;
  &lt;li&gt;Loader：模块转换器，用于把模块原内容按照需求转换成新内容。&lt;/li&gt;
  &lt;li&gt;Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。&lt;/li&gt;
  &lt;li&gt;Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;webpackgruntgulp&quot;&gt;WebPack、Grunt、Gulp？&lt;/h2&gt;

&lt;p&gt;Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果实在要把二者进行比较，Webpack的处理速度更快更直接，能打包更多不同类型的文件。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;执行流程&quot;&gt;执行流程&lt;/h2&gt;

&lt;p&gt;webpack启动后会在entry里配置的module开始递归解析entry所依赖的所有module，没找到一个module, 就会根据配置的loader去找相应的转换规则，对module进行转换后在解析当前module所依赖的module，这些模块会以entry为分组，一个entry和所有相依赖的module也就是一个chunk，最后webpack会把所有chunk转换成文件输出，在整个流程中webpack会在恰当的时机执行plugin的逻辑&lt;/p&gt;

&lt;h2 id=&quot;从零配置webpack&quot;&gt;从零配置webpack&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;初始化配置&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir webpack-start
cd webpack-start
npm init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;配置webpack&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add webpack webpack-cli -D //webpack4把webpack拆分了
mkdir src
cd src 并且创建index.html, index.js
mkdir dist
touch webpack.config.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;webpack.config.js

module.exports = {
    entry: './src/index.js', //入口文件，src下的index.js
    output: {
        path: path.join(__dirname, 'dist'), // 出口目录，dist文件
        filename: '[name].[hash].js' //这里name就是打包出来的文件名，因为是单入口，就是main，多入口下回分解
    },
    module: {},
    plugin: {},
    devServer: {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;配置开发服务器&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add webpack-dev-server -D
修改webpack.config.js
devServer: {
    contentBase: path.join(__dirname, &quot;dist&quot;), //静态文件根目录
    port: 9090, // 端口
    host: 'localhost',
    overlay: true,
    compress: true // 服务器返回浏览器的时候是否启动gzip压缩
}
修改package.json
&quot;script&quot;: {
    &quot;build&quot;: &quot;webpack --mode development&quot;, //这里为了不压缩代码，用开发环境
    &quot;dev&quot;: &quot;webpack-dev-server --open --mode development&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;支持css文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add style-loader css-loader -D
// css-loader用来处理css中url的路径
// style-loader可以把css文件变成style标签插入head中
// 多个loader是有顺序要求的，从右往左写，因为转换的时候是从右往左转换的
module: {
    rules: {
        test: /\.css$/,
        use: ['style-laoder', 'css-loader'],
        include: path.join(__dirname, 'src'), //限制范围，提高打包速度
        exclude: /node_modules/
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;支持es6，react.js等&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add babel-loader babel-core babel-preset-env babel-preset-stage-0 babel-preset -react -D
  {
    test: /\.js$/,
    use: {
      loader: 'babel-loader',
      query: {
        presets: ['env', 'stage-0', 'react'] // env转换es6 stage-0转es7 react转react
      }
    }
  }
  同时可以把babel配置写到.babelrc中

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;从js中分离css&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add extract-text-webpack-plugin -D
{
    test: /\.css$/, // 转换文件的匹配正则
    use: ExtractTextWebpackPlugin.extract({
      fallback: 'style-loader',
      //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来
      use: ['css-loader']
    })
},
//加上plugin
plugins: [
    new ExtractTextWebpackPlugin({
      filename: 'css/[name].[hash].css' //放到dist/css/下
    })
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;支持图片&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add file-loader url-loader -D
file-loader 解决css等文件中引入图片路径的问题
url-loader 当图片较小的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝
{
// file-loader是解析图片地址，把图片从源文件拷贝到目标文件并且修改源文件名字
// 可以处理任意二进制，bootstrap里的字体
// url-loader可以在文件比较小的时候，直接变成base64字符串内嵌到页面中
{
    test: /\.(png|jpg|jpeg|gif|svg)/,
    use: {
      loader: 'url-loader',
      options: {
        outputPath: 'images/', // 图片输出的路径
        limit: 5 * 1024
      }
    }
},
// 同时要处理打包图片路径问题，
output: {
    publicPath: '/'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;处理css3属性前缀&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add postcss-loader -D
{
    test: /\.css$/, // 转换文件的匹配正则
    // css-loader用来处理css中url的路径
    // style-loader可以把css文件变成style标签插入head中
    // 多个loader是有顺序要求的，从右往左写，因为转换的时候是从右往左转换的
    // 此插件先用css-loader处理一下css文件
    use: ExtractTextWebpackPlugin.extract({
      fallback: 'style-loader',
      //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来
      use: ['css-loader', 'postcss-loader']
    })
},
建立.postcssrc.js文件
module.exports = {
  &quot;plugins&quot;: {
    // to edit target browsers: use &quot;browserslist&quot; field in package.json
    &quot;autoprefixer&quot;: {
      &quot;browsers&quot;: [
        &quot;ie &amp;gt;= 9&quot;,
        &quot;ff &amp;gt;= 30&quot;,
        &quot;chrome &amp;gt;= 34&quot;,
        &quot;safari &amp;gt;= 7&quot;,
        &quot;opera &amp;gt;= 23&quot;
      ]
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;调试打包的代码 webapck通过配置可以自动给我们source maps文件，map文件是一种对应编译文件和源文件的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;devtool: ‘eval-source-map’&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. source-map 把映射文件生成到单独的文件，最完整最慢
2. cheap-module-source-map 在一个单独的文件中产生一个不带列映射的Map
3. eval-source-map 使用eval打包源文件模块,在同一个文件中生成完整sourcemap
4. cheap-module-eval-source-map sourcemap和打包后的JS同行显示，没有映射列
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;压缩js&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;webpack --mode production 会压缩，可以忽略下面
yarn add uglifyjs-webpack-plugin -D
const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin')
new UglifyjsWebpackPlugin(),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;压缩css&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;webpack --mode production 会压缩，可以忽略下面
{
    test: /\.css$/, // 转换文件的匹配正则
    use: ExtractTextWebpackPlugin.extract({
      fallback: 'style-loader',
      use: [
          {
             loader: 'css-laoder',
             options: {minimize: true}
          },
          'postcss-loader'
      ]
    })
},

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;清空打包输出目录&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add clean-webpack-plugin -D
const CleanWebpackPlugin = require('clean-webpack-plugin')
new CleanWebpackPlugin([path.join(__dirname, 'dist')]),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;区分环境变量 许多 library 将通过与 process.env.NODE_ENV 环境变量关联，以决定 library 中应该引用哪些内容。我们可以使用 webpack 内置的 DefinePlugin 为所有的依赖定义这个变量：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;scripts&quot;: {
    &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --mode development&quot;, // 设置NODE_ENV为production
    &quot;dev&quot;: &quot;webpack-dev-server --open --mode development &quot;
},
new webpack.DefinePlugin({
    NODE_ENV:JSON.stringify(process.env.NODE_ENV)
})
在全局都有NODE_ENV这个变量,当yarn run build,时，NODE_ENV = 'production'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;暴露全局变量&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new Webpack.ProvidePlugin({
  '$': 'jquery'
}),

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;resolve解析&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xtension: 指定extension之后可以不用在require或是import的时候加文件扩展名,会依次尝试添加扩展名进行匹配
resolve: {
    //自动补全后缀，注意第一个必须是空字符串,后缀一定以点开头
    extension: ['', '.js', '.json', '.css']
}
alias: 配置别名可以加快webpack查找模块的速度
resolve: {
    alias: {
        'bootstrap': 'bootstrap/dist/css/bootstrap.css'
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;复制静态资源&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yarn add copy-webpack-plugin
const CopyWebpackPlugin = require('copy-webpack-plugin')
new CopyWebpackPlugin([
  {
    from: path.resolve(__dirname, 'static'),
    to: path.resolve(__dirname, 'pages/static'),
    ignore: ['.*']
  }
])

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><summary type="html">核心概念 Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。 Loader：模块转换器，用于把模块原内容按照需求转换成新内容。 Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。 WebPack、Grunt、Gulp？ Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。 Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。 Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。 如果实在要把二者进行比较，Webpack的处理速度更快更直接，能打包更多不同类型的文件。 执行流程 webpack启动后会在entry里配置的module开始递归解析entry所依赖的所有module，没找到一个module, 就会根据配置的loader去找相应的转换规则，对module进行转换后在解析当前module所依赖的module，这些模块会以entry为分组，一个entry和所有相依赖的module也就是一个chunk，最后webpack会把所有chunk转换成文件输出，在整个流程中webpack会在恰当的时机执行plugin的逻辑 从零配置webpack 初始化配置 mkdir webpack-start cd webpack-start npm init 配置webpack yarn add webpack webpack-cli -D //webpack4把webpack拆分了 mkdir src cd src 并且创建index.html, index.js mkdir dist touch webpack.config.js webpack.config.js module.exports = { entry: './src/index.js', //入口文件，src下的index.js output: { path: path.join(__dirname, 'dist'), // 出口目录，dist文件 filename: '[name].[hash].js' //这里name就是打包出来的文件名，因为是单入口，就是main，多入口下回分解 }, module: {}, plugin: {}, devServer: {} } 配置开发服务器 yarn add webpack-dev-server -D 修改webpack.config.js devServer: { contentBase: path.join(__dirname, &quot;dist&quot;), //静态文件根目录 port: 9090, // 端口 host: 'localhost', overlay: true, compress: true // 服务器返回浏览器的时候是否启动gzip压缩 } 修改package.json &quot;script&quot;: { &quot;build&quot;: &quot;webpack --mode development&quot;, //这里为了不压缩代码，用开发环境 &quot;dev&quot;: &quot;webpack-dev-server --open --mode development&quot; } 支持css文件 yarn add style-loader css-loader -D // css-loader用来处理css中url的路径 // style-loader可以把css文件变成style标签插入head中 // 多个loader是有顺序要求的，从右往左写，因为转换的时候是从右往左转换的 module: { rules: { test: /\.css$/, use: ['style-laoder', 'css-loader'], include: path.join(__dirname, 'src'), //限制范围，提高打包速度 exclude: /node_modules/ } } 支持es6，react.js等 yarn add babel-loader babel-core babel-preset-env babel-preset-stage-0 babel-preset -react -D { test: /\.js$/, use: { loader: 'babel-loader', query: { presets: ['env', 'stage-0', 'react'] // env转换es6 stage-0转es7 react转react } } } 同时可以把babel配置写到.babelrc中 从js中分离css yarn add extract-text-webpack-plugin -D { test: /\.css$/, // 转换文件的匹配正则 use: ExtractTextWebpackPlugin.extract({ fallback: 'style-loader', //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来 use: ['css-loader'] }) }, //加上plugin plugins: [ new ExtractTextWebpackPlugin({ filename: 'css/[name].[hash].css' //放到dist/css/下 }) ] 支持图片 yarn add file-loader url-loader -D file-loader 解决css等文件中引入图片路径的问题 url-loader 当图片较小的时候会把图片BASE64编码，大于limit参数的时候还是使用file-loader 进行拷贝 { // file-loader是解析图片地址，把图片从源文件拷贝到目标文件并且修改源文件名字 // 可以处理任意二进制，bootstrap里的字体 // url-loader可以在文件比较小的时候，直接变成base64字符串内嵌到页面中 { test: /\.(png|jpg|jpeg|gif|svg)/, use: { loader: 'url-loader', options: { outputPath: 'images/', // 图片输出的路径 limit: 5 * 1024 } } }, // 同时要处理打包图片路径问题， output: { publicPath: '/' } 处理css3属性前缀 yarn add postcss-loader -D { test: /\.css$/, // 转换文件的匹配正则 // css-loader用来处理css中url的路径 // style-loader可以把css文件变成style标签插入head中 // 多个loader是有顺序要求的，从右往左写，因为转换的时候是从右往左转换的 // 此插件先用css-loader处理一下css文件 use: ExtractTextWebpackPlugin.extract({ fallback: 'style-loader', //如果需要，可以在 sass-loader 之前将 resolve-url-loader 链接进来 use: ['css-loader', 'postcss-loader'] }) }, 建立.postcssrc.js文件 module.exports = { &quot;plugins&quot;: { // to edit target browsers: use &quot;browserslist&quot; field in package.json &quot;autoprefixer&quot;: { &quot;browsers&quot;: [ &quot;ie &amp;gt;= 9&quot;, &quot;ff &amp;gt;= 30&quot;, &quot;chrome &amp;gt;= 34&quot;, &quot;safari &amp;gt;= 7&quot;, &quot;opera &amp;gt;= 23&quot; ] } } } 调试打包的代码 webapck通过配置可以自动给我们source maps文件，map文件是一种对应编译文件和源文件的方法 devtool: ‘eval-source-map’ 1. source-map 把映射文件生成到单独的文件，最完整最慢 2. cheap-module-source-map 在一个单独的文件中产生一个不带列映射的Map 3. eval-source-map 使用eval打包源文件模块,在同一个文件中生成完整sourcemap 4. cheap-module-eval-source-map sourcemap和打包后的JS同行显示，没有映射列 压缩js webpack --mode production 会压缩，可以忽略下面 yarn add uglifyjs-webpack-plugin -D const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin') new UglifyjsWebpackPlugin(), 压缩css webpack --mode production 会压缩，可以忽略下面 { test: /\.css$/, // 转换文件的匹配正则 use: ExtractTextWebpackPlugin.extract({ fallback: 'style-loader', use: [ { loader: 'css-laoder', options: {minimize: true} }, 'postcss-loader' ] }) }, 清空打包输出目录 yarn add clean-webpack-plugin -D const CleanWebpackPlugin = require('clean-webpack-plugin') new CleanWebpackPlugin([path.join(__dirname, 'dist')]), 区分环境变量 许多 library 将通过与 process.env.NODE_ENV 环境变量关联，以决定 library 中应该引用哪些内容。我们可以使用 webpack 内置的 DefinePlugin 为所有的依赖定义这个变量： &quot;scripts&quot;: { &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --mode development&quot;, // 设置NODE_ENV为production &quot;dev&quot;: &quot;webpack-dev-server --open --mode development &quot; }, new webpack.DefinePlugin({ NODE_ENV:JSON.stringify(process.env.NODE_ENV) }) 在全局都有NODE_ENV这个变量,当yarn run build,时，NODE_ENV = 'production' 暴露全局变量 new Webpack.ProvidePlugin({ '$': 'jquery' }), resolve解析 xtension: 指定extension之后可以不用在require或是import的时候加文件扩展名,会依次尝试添加扩展名进行匹配 resolve: { //自动补全后缀，注意第一个必须是空字符串,后缀一定以点开头 extension: ['', '.js', '.json', '.css'] } alias: 配置别名可以加快webpack查找模块的速度 resolve: { alias: { 'bootstrap': 'bootstrap/dist/css/bootstrap.css' } } 复制静态资源 yarn add copy-webpack-plugin const CopyWebpackPlugin = require('copy-webpack-plugin') new CopyWebpackPlugin([ { from: path.resolve(__dirname, 'static'), to: path.resolve(__dirname, 'pages/static'), ignore: ['.*'] } ])</summary></entry><entry><title type="html">instanceof 和 typeof 的实现原理</title><link href="http://localhost:4000/2018/06/08/instanceof%E5%92%8Ctypeof%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" rel="alternate" type="text/html" title="instanceof 和 typeof 的实现原理" /><published>2018-06-08T00:00:00+08:00</published><updated>2018-06-08T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/08/instanceof%E5%92%8Ctypeof%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86</id><content type="html" xml:base="http://localhost:4000/2018/06/08/instanceof%E5%92%8Ctypeof%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html">&lt;p&gt;这周老大分享了有关原生JS的基础内容，这次我也跟风补一下相关知识。&lt;/p&gt;

&lt;h2 id=&quot;typeof-实现原理&quot;&gt;typeof 实现原理&lt;/h2&gt;

&lt;p&gt;typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let s = new String('abc');
typeof s === 'object'// true
s instanceof String // true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要想判断一个数据具体是哪一种 object 的时候，我们需要利用 instanceof 这个操作符来判断，这个我们后面会说到。&lt;/p&gt;

&lt;p&gt;来谈谈关于 typeof 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？&lt;/p&gt;

&lt;p&gt;其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;000：对象&lt;/li&gt;
  &lt;li&gt;010：浮点数&lt;/li&gt;
  &lt;li&gt;100：字符串&lt;/li&gt;
  &lt;li&gt;110：布尔&lt;/li&gt;
  &lt;li&gt;1：整数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;null：所有机器码均为0&lt;/li&gt;
  &lt;li&gt;undefined：用 −2^30 整数来表示&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待。&lt;/p&gt;

&lt;p&gt;然而用 instanceof 来判断的话&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;null instanceof null // TypeError: Right-hand side of 'instanceof' is not an object

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;null 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考typeof。&lt;/p&gt;

&lt;p&gt;因此在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括symbol），避免对 null 的判断。&lt;/p&gt;

&lt;p&gt;还有一个不错的判断类型的方法，就是Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object.prototype.toString.call(1) // &quot;[object Number]&quot;
Object.prototype.toString.call('hi') // &quot;[object String]&quot;
Object.prototype.toString.call({a:'hi'}) // &quot;[object Object]&quot;
Object.prototype.toString.call([1,'a']) // &quot;[object Array]&quot;
Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;
Object.prototype.toString.call(() =&amp;gt; {}) // &quot;[object Function]&quot;
Object.prototype.toString.call(null) // &quot;[object Null]&quot;
Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;
Object.prototype.toString.call(Symbol(1)) // &quot;[object Symbol]&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;instanceof-操作符的实现原理&quot;&gt;instanceof 操作符的实现原理&lt;/h2&gt;

&lt;p&gt;之前我们提到了 instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let person = function () {
}
let nicole = new person()
nicole instanceof person // true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let person = function () { }
let programmer = function () { }
programmer.prototype = new person()
let nicole = new programmer()
nicole instanceof person // true
nicole instanceof programmer // true

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这是 instanceof 的用法，但是 instanceof 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function new_instance_of(leftVaule, rightVaule) { 
    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
    while (true) {
        if (leftVaule === null) {
            return false;    
        }
        if (leftVaule === rightProto) {
            return true;    
        } 
        leftVaule = leftVaule.__proto__ 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。&lt;/p&gt;

&lt;p&gt;看几个很有趣的例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Foo() {
}
Object instanceof Object // true
Function instanceof Function // true
Function instanceof Object // true
Foo instanceof Foo // false
Foo instanceof Object // true
Foo instanceof Function // true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要想全部理解 instanceof 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。&lt;/p&gt;

&lt;p&gt;关于原型继承的原理，我简单用一张图来表示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180608/20180608-1.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个 JavaScript 对象均有一个隐式的 &lt;strong&gt;proto&lt;/strong&gt; 原型属性，而显式的原型属性是 prototype，只有 Object.prototype.&lt;strong&gt;proto&lt;/strong&gt; 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 instanceof 使用的例子。&lt;/p&gt;

&lt;p&gt;Object instanceof Object&lt;/p&gt;

&lt;p&gt;由图可知，Object 的 prototype 属性是 Object.prototype, 而由于 Object 本身是一个函数，由 Function 所创建，所以 Object.&lt;strong&gt;proto&lt;/strong&gt; 的值是 Function.prototype，而 Function.prototype 的 &lt;strong&gt;proto&lt;/strong&gt; 属性是 Object.prototype，所以我们可以判断出，Object instanceof Object 的结果是 true 。用代码简单的表示一下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;leftValue = Object.__proto__ = Function.prototype;
rightValue = Object.prototype;
// 第一次判断
leftValue != rightValue
leftValue = Function.prototype.__proto__ = Object.prototype
// 第二次判断
leftValue === rightValue
// 返回 true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Function instanceof Function 和 Function instanceof Object 的运行过程与 Object instanceof Object 类似，故不再详说。&lt;/p&gt;

&lt;p&gt;Foo instanceof Foo&lt;/p&gt;

&lt;p&gt;Foo 函数的 prototype 属性是 Foo.prototype，而 Foo 的 &lt;strong&gt;proto&lt;/strong&gt; 属性是 Function.prototype，由图可知，Foo 的原型链上并没有 Foo.prototype ，因此 Foo instanceof Foo 也就返回 false 。&lt;/p&gt;

&lt;p&gt;我们用代码简单的表示一下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;leftValue = Foo, rightValue = Foo
leftValue = Foo.__proto = Function.prototype
rightValue = Foo.prototype
// 第一次判断
leftValue != rightValue
leftValue = Function.prototype.__proto__ = Object.prototype
// 第二次判断
leftValue != rightValue
leftValue = Object.prototype = null
// 第三次判断
leftValue === null
// 返回 false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Foo instanceof Object&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;leftValue = Foo, rightValue = Object
leftValue = Foo.__proto__ = Function.prototype
rightValue = Object.prototype
// 第一次判断
leftValue != rightValue
leftValue = Function.prototype.__proto__ = Object.prototype
// 第二次判断
leftValue === rightValue
// 返回 true 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Foo instanceof Function&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;leftValue = Foo, rightValue = Function
leftValue = Foo.__proto__ = Function.prototype
rightValue = Function.prototype
// 第一次判断
leftValue === rightValue
// 返回 true 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;简单来说，使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。&lt;/p&gt;</content><author><name>weili</name></author><category term="JS" /><summary type="html">这周老大分享了有关原生JS的基础内容，这次我也跟风补一下相关知识。 typeof 实现原理 typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如 let s = new String('abc'); typeof s === 'object'// true s instanceof String // true 要想判断一个数据具体是哪一种 object 的时候，我们需要利用 instanceof 这个操作符来判断，这个我们后面会说到。 来谈谈关于 typeof 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？ 其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。 null：所有机器码均为0 undefined：用 −2^30 整数来表示 所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待。 然而用 instanceof 来判断的话 null instanceof null // TypeError: Right-hand side of 'instanceof' is not an object null 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考typeof。 因此在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括symbol），避免对 null 的判断。 还有一个不错的判断类型的方法，就是Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断 Object.prototype.toString.call(1) // &quot;[object Number]&quot; Object.prototype.toString.call('hi') // &quot;[object String]&quot; Object.prototype.toString.call({a:'hi'}) // &quot;[object Object]&quot; Object.prototype.toString.call([1,'a']) // &quot;[object Array]&quot; Object.prototype.toString.call(true) // &quot;[object Boolean]&quot; Object.prototype.toString.call(() =&amp;gt; {}) // &quot;[object Function]&quot; Object.prototype.toString.call(null) // &quot;[object Null]&quot; Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot; Object.prototype.toString.call(Symbol(1)) // &quot;[object Symbol]&quot; instanceof 操作符的实现原理 之前我们提到了 instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型 let person = function () { } let nicole = new person() nicole instanceof person // true 当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。 let person = function () { } let programmer = function () { } programmer.prototype = new person() let nicole = new programmer() nicole instanceof person // true nicole instanceof programmer // true 这是 instanceof 的用法，但是 instanceof 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下 function new_instance_of(leftVaule, rightVaule) { let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值 leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值 while (true) { if (leftVaule === null) { return false; } if (leftVaule === rightProto) { return true; } leftVaule = leftVaule.__proto__ } } 其实 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。 看几个很有趣的例子 function Foo() { } Object instanceof Object // true Function instanceof Function // true Function instanceof Object // true Foo instanceof Foo // false Foo instanceof Object // true Foo instanceof Function // true 要想全部理解 instanceof 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。 关于原型继承的原理，我简单用一张图来表示 每个 JavaScript 对象均有一个隐式的 proto 原型属性，而显式的原型属性是 prototype，只有 Object.prototype.proto 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 instanceof 使用的例子。 Object instanceof Object 由图可知，Object 的 prototype 属性是 Object.prototype, 而由于 Object 本身是一个函数，由 Function 所创建，所以 Object.proto 的值是 Function.prototype，而 Function.prototype 的 proto 属性是 Object.prototype，所以我们可以判断出，Object instanceof Object 的结果是 true 。用代码简单的表示一下 leftValue = Object.__proto__ = Function.prototype; rightValue = Object.prototype; // 第一次判断 leftValue != rightValue leftValue = Function.prototype.__proto__ = Object.prototype // 第二次判断 leftValue === rightValue // 返回 true Function instanceof Function 和 Function instanceof Object 的运行过程与 Object instanceof Object 类似，故不再详说。 Foo instanceof Foo Foo 函数的 prototype 属性是 Foo.prototype，而 Foo 的 proto 属性是 Function.prototype，由图可知，Foo 的原型链上并没有 Foo.prototype ，因此 Foo instanceof Foo 也就返回 false 。 我们用代码简单的表示一下 leftValue = Foo, rightValue = Foo leftValue = Foo.__proto = Function.prototype rightValue = Foo.prototype // 第一次判断 leftValue != rightValue leftValue = Function.prototype.__proto__ = Object.prototype // 第二次判断 leftValue != rightValue leftValue = Object.prototype = null // 第三次判断 leftValue === null // 返回 false Foo instanceof Object leftValue = Foo, rightValue = Object leftValue = Foo.__proto__ = Function.prototype rightValue = Object.prototype // 第一次判断 leftValue != rightValue leftValue = Function.prototype.__proto__ = Object.prototype // 第二次判断 leftValue === rightValue // 返回 true Foo instanceof Function leftValue = Foo, rightValue = Function leftValue = Foo.__proto__ = Function.prototype rightValue = Function.prototype // 第一次判断 leftValue === rightValue // 返回 true 简单来说，使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。</summary></entry><entry><title type="html">React 组件的性能优化</title><link href="http://localhost:4000/2018/06/02/react_performance.html" rel="alternate" type="text/html" title="React 组件的性能优化" /><published>2018-06-02T00:00:00+08:00</published><updated>2018-06-02T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/02/react_performance</id><content type="html" xml:base="http://localhost:4000/2018/06/02/react_performance.html">&lt;p&gt;虽然react已经提供了很好的渲染性能，但要让程序发挥到极致，还需要进一步了解性能优化的方法，本章节主要从三个方面讲解：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单个react组件的性能优化&lt;/li&gt;
  &lt;li&gt;多个react组件的性能优化&lt;/li&gt;
  &lt;li&gt;用reselect提高数据获取性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;单个react组件的性能优化&quot;&gt;单个react组件的性能优化&lt;/h2&gt;

&lt;p&gt;react渲染之所以快，是因为利用Virtual DOM来计算出DOM树的最少修改，只渲染修改的部分，而不是所有。&lt;/p&gt;

&lt;p&gt;如果能够在开始计算Virtual DOM之前就可以判断结果不会变化，那干脆不要再去计算和比较，速度就会更快。&lt;/p&gt;

&lt;h3 id=&quot;借助react-perf工具发现浪费的渲染时间&quot;&gt;借助react perf工具，发现浪费的渲染时间&lt;/h3&gt;

&lt;p&gt;react perf 这个工具的安装和使用这里不再讲述。&lt;/p&gt;

&lt;p&gt;这个工具记录在点击start和stop按钮之间的所有react的渲染，如果有组件计算Virtual DOM之后，和之前的Virtual DOM相同，就认为是一次浪费。&lt;/p&gt;

&lt;p&gt;这里所说的浪费是计算Virtual DOM的浪费，并不是访问DOM的浪费。&lt;/p&gt;

&lt;p&gt;可以借助这个工具清晰的知道哪个组件被无意义的渲染了，达到优化性能的目的。&lt;/p&gt;

&lt;h3 id=&quot;性能优化的时机&quot;&gt;性能优化的时机&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;过早的优化是万恶之源—–高德纳&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很多人对这句话有个错误的认识，认为高前辈不让做过早的优化，很显然我们误会老高了，他的全句是这样的&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“我们应该忘记忽略很小的性能优化，可以说97%的情况下，过早的优化是万恶之源，而我们应该关心对性能影响最关键的那另外3%的代码”—–高德纳&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前辈的这句话有三个重要的点：&lt;/p&gt;

&lt;p&gt;1、不要把精力放在对整体性能优化提高不大的代码上，而对于性能有关键影响的部分，优化并不嫌早。&lt;/p&gt;

&lt;p&gt;2、所谓过早的优化，是指在没有任何数据体现下开发者对性能优化的猜测，没有可测量的性能指标，完成优化后，也不知道是否达到了预期的结果。&lt;/p&gt;

&lt;p&gt;3、高德纳认为过早的优化是万恶之源，是因为这些优化往往让代码过于复杂和难于维护，但如果早期的优化能够让代码结构更加合理更加容易维护，为什么不呢？&lt;/p&gt;

&lt;h2 id=&quot;多个react组件的性能优化&quot;&gt;多个react组件的性能优化&lt;/h2&gt;

&lt;p&gt;多个组件和单个组件一样，都需要经历组件装载、更新、卸载三个步骤。&lt;/p&gt;

&lt;p&gt;其中装载这个部分没有什么可以性能优化的事情做，卸载部分是会出现组件加载后添加的事件监听等收尾工作，也没有太多的可优化空间。&lt;/p&gt;

&lt;p&gt;重要的放在更新过程。&lt;/p&gt;

&lt;h3 id=&quot;react的调和过程&quot;&gt;react的调和过程&lt;/h3&gt;

&lt;p&gt;什么叫调和？&lt;/p&gt;

&lt;p&gt;就是render后和更新后，生成的这个树，相互比较找不同，这个找不同的过程就叫调和。&lt;/p&gt;

&lt;p&gt;react怎么找不同呢？&lt;/p&gt;

&lt;p&gt;1、先检查两个节点的类型&lt;/p&gt;

&lt;p&gt;这个类型分为两类：一类是dom元素类型，就是div span； 另一类是react组件，也就是利用react库定制的类型。&lt;/p&gt;

&lt;p&gt;1.1  如果不同&lt;/p&gt;

&lt;p&gt;举个例子，组件包裹外层原来是div，更新为span，这个时候，react一看这完全不相同，那后面的子节点也别看了，直接重新构建一份吧，这就造成了性能上面的浪费。&lt;/p&gt;

&lt;p&gt;解决办法：作为开发者尽量不要改动做为包裹层的类型。&lt;/p&gt;

&lt;p&gt;1.2 如果相同&lt;/p&gt;

&lt;p&gt;上面说了类型有两种，如果是dom类型加同，就只对比这个节点的属性和内容，然后更新修改的部分，如下面的代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;原来的：

&amp;lt;div style=&amp;gt;hello&amp;lt;/div&amp;gt;

更改后的：

&amp;lt;div style=&amp;gt;hello&amp;lt;/div&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;DOM节点类型没变，只需要修改它的属性，变动少。&lt;/p&gt;

&lt;p&gt;另外一种类型是react组件类型，它更新时只能根据新节点的props去更新原来的组件，引发这个组件实例的更新过程，按照下面的顺序引发下面的函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;shouldComponentUpdate&lt;/li&gt;
  &lt;li&gt;componentWillReceiveProps&lt;/li&gt;
  &lt;li&gt;componentWillUpdate&lt;/li&gt;
  &lt;li&gt;render&lt;/li&gt;
  &lt;li&gt;componentDidUpdate&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个时候就需要合理的使用shouldComonentUpdate函数了，如果没有必要渲染，就返回false。&lt;/p&gt;

&lt;p&gt;好了，对比了根节点之后，会对这个根节点的每一个小节点重复相同的动作，该更新更新，该创建创建。&lt;/p&gt;

&lt;p&gt;2、key的作用&lt;/p&gt;

&lt;p&gt;key就相当于组件的身份证号，标识组件的位置，react可以根据根据key值的有无变化，从而决定是否更新它。&lt;/p&gt;

&lt;p&gt;这个时候注意个问题，在循环一个数组时，不能以数组的下标做为key值定义每个子组件，key值变来变去的无规则也会引起不必要的重新加载或者更新创建。&lt;/p&gt;</content><author><name>weili</name></author><category term="JS" /><category term="前端" /><category term="深入浅出React和Redux读书笔记" /><summary type="html">虽然react已经提供了很好的渲染性能，但要让程序发挥到极致，还需要进一步了解性能优化的方法，本章节主要从三个方面讲解： 单个react组件的性能优化 多个react组件的性能优化 用reselect提高数据获取性能 单个react组件的性能优化 react渲染之所以快，是因为利用Virtual DOM来计算出DOM树的最少修改，只渲染修改的部分，而不是所有。 如果能够在开始计算Virtual DOM之前就可以判断结果不会变化，那干脆不要再去计算和比较，速度就会更快。 借助react perf工具，发现浪费的渲染时间 react perf 这个工具的安装和使用这里不再讲述。 这个工具记录在点击start和stop按钮之间的所有react的渲染，如果有组件计算Virtual DOM之后，和之前的Virtual DOM相同，就认为是一次浪费。 这里所说的浪费是计算Virtual DOM的浪费，并不是访问DOM的浪费。 可以借助这个工具清晰的知道哪个组件被无意义的渲染了，达到优化性能的目的。 性能优化的时机 过早的优化是万恶之源—–高德纳 很多人对这句话有个错误的认识，认为高前辈不让做过早的优化，很显然我们误会老高了，他的全句是这样的 “我们应该忘记忽略很小的性能优化，可以说97%的情况下，过早的优化是万恶之源，而我们应该关心对性能影响最关键的那另外3%的代码”—–高德纳 前辈的这句话有三个重要的点： 1、不要把精力放在对整体性能优化提高不大的代码上，而对于性能有关键影响的部分，优化并不嫌早。 2、所谓过早的优化，是指在没有任何数据体现下开发者对性能优化的猜测，没有可测量的性能指标，完成优化后，也不知道是否达到了预期的结果。 3、高德纳认为过早的优化是万恶之源，是因为这些优化往往让代码过于复杂和难于维护，但如果早期的优化能够让代码结构更加合理更加容易维护，为什么不呢？ 多个react组件的性能优化 多个组件和单个组件一样，都需要经历组件装载、更新、卸载三个步骤。 其中装载这个部分没有什么可以性能优化的事情做，卸载部分是会出现组件加载后添加的事件监听等收尾工作，也没有太多的可优化空间。 重要的放在更新过程。 react的调和过程 什么叫调和？ 就是render后和更新后，生成的这个树，相互比较找不同，这个找不同的过程就叫调和。 react怎么找不同呢？ 1、先检查两个节点的类型 这个类型分为两类：一类是dom元素类型，就是div span； 另一类是react组件，也就是利用react库定制的类型。 1.1 如果不同 举个例子，组件包裹外层原来是div，更新为span，这个时候，react一看这完全不相同，那后面的子节点也别看了，直接重新构建一份吧，这就造成了性能上面的浪费。 解决办法：作为开发者尽量不要改动做为包裹层的类型。 1.2 如果相同 上面说了类型有两种，如果是dom类型加同，就只对比这个节点的属性和内容，然后更新修改的部分，如下面的代码 原来的： &amp;lt;div style=&amp;gt;hello&amp;lt;/div&amp;gt; 更改后的： &amp;lt;div style=&amp;gt;hello&amp;lt;/div&amp;gt; DOM节点类型没变，只需要修改它的属性，变动少。 另外一种类型是react组件类型，它更新时只能根据新节点的props去更新原来的组件，引发这个组件实例的更新过程，按照下面的顺序引发下面的函数： shouldComponentUpdate componentWillReceiveProps componentWillUpdate render componentDidUpdate 这个时候就需要合理的使用shouldComonentUpdate函数了，如果没有必要渲染，就返回false。 好了，对比了根节点之后，会对这个根节点的每一个小节点重复相同的动作，该更新更新，该创建创建。 2、key的作用 key就相当于组件的身份证号，标识组件的位置，react可以根据根据key值的有无变化，从而决定是否更新它。 这个时候注意个问题，在循环一个数组时，不能以数组的下标做为key值定义每个子组件，key值变来变去的无规则也会引起不必要的重新加载或者更新创建。</summary></entry><entry><title type="html">彻底理解浏览器的缓存机制</title><link href="http://localhost:4000/2018/05/11/browsers_caching.html" rel="alternate" type="text/html" title="彻底理解浏览器的缓存机制" /><published>2018-05-11T00:00:00+08:00</published><updated>2018-05-11T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/11/browsers_caching</id><content type="html" xml:base="http://localhost:4000/2018/05/11/browsers_caching.html">&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;

&lt;p&gt;浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-1.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体，如下图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-2.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。&lt;/p&gt;

&lt;h2 id=&quot;缓存过程分析&quot;&gt;缓存过程分析&lt;/h2&gt;

&lt;p&gt;浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-3.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由上图我们可以知道：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是&lt;strong&gt;强制缓存和协商缓存&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;强制缓存&quot;&gt;强制缓存&lt;/h3&gt;

&lt;p&gt;强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：&lt;/p&gt;

&lt;p&gt;不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-4.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-5.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-6.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;强制缓存的缓存规则&quot;&gt;强制缓存的缓存规则&lt;/h4&gt;

&lt;p&gt;当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。&lt;/p&gt;

&lt;h5 id=&quot;expires&quot;&gt;Expires&lt;/h5&gt;

&lt;p&gt;Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？&lt;/p&gt;

&lt;h5 id=&quot;cache-control&quot;&gt;Cache-Control&lt;/h5&gt;

&lt;p&gt;在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;public：所有内容都将被缓存（客户端和代理服务器都可缓存）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;private：所有内容只有客户端可以缓存，Cache-Control的默认取值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看一个例子&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-7.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由上面的例子我们可以知道：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP响应报文中expires的时间值，是一个绝对值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP响应报文中Cache-Control为max-age=600，是相对值&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于Cache-Control的优先级比expires，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。&lt;/p&gt;

&lt;p&gt;注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-8.png&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&amp;gt; disk。&lt;/p&gt;

&lt;p&gt;接下来再一起详细分析一下缓存读取问题：&lt;/p&gt;

&lt;p&gt;访问https://www.babytree.com –&amp;gt; 200 –&amp;gt; 关闭网站的标签页 –&amp;gt; 重新打开https://www.babytree.com –&amp;gt; 200(from disk cache) –&amp;gt; 刷新 –&amp;gt; 200(from memory cache)&lt;/p&gt;

&lt;p&gt;过程如下：&lt;/p&gt;

&lt;p&gt;1) 访问www.babytree.com&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-9.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2) 关闭页面&lt;/p&gt;

&lt;p&gt;3) 重新打开&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-10.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4) 刷新&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-11.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;最后一个步骤刷新的时候，不是同时存在着from disk cache和from memory cache吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于这个问题，需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时效性：一旦该进程关闭，则该进程的内存则会清空。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。&lt;/p&gt;

&lt;h3 id=&quot;协商缓存&quot;&gt;协商缓存&lt;/h3&gt;

&lt;p&gt;协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;协商缓存生效，返回304，如下&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-12.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;协商缓存失效，返回200和请求结果结果，如下&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-13.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。&lt;/p&gt;

&lt;h5 id=&quot;last-modified--if-modified-since&quot;&gt;Last-Modified / If-Modified-Since&lt;/h5&gt;

&lt;p&gt;Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-14.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-15.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;etag--if-none-match&quot;&gt;Etag / If-None-Match&lt;/h5&gt;

&lt;p&gt;Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-16.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-17.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180511/20180511-18.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;</content><author><name>weili</name></author><category term="JS" /><category term="缓存机制" /><summary type="html">定义 浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种： HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图 HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体，如下图 注： 通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via； 实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。 这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。 缓存过程分析 浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图： 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。 强制缓存 强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下： 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图： 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图 强制缓存的缓存规则 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。 Expires Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。 Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？ 到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？ Cache-Control 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为： public：所有内容都将被缓存（客户端和代理服务器都可缓存） private：所有内容只有客户端可以缓存，Cache-Control的默认取值 no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效 看一个例子 由上面的例子我们可以知道： HTTP响应报文中expires的时间值，是一个绝对值 HTTP响应报文中Cache-Control为max-age=600，是相对值 由于Cache-Control的优先级比expires，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。 注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。 浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？ 状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。 那么from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？ from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&amp;gt; disk。 接下来再一起详细分析一下缓存读取问题： 访问https://www.babytree.com –&amp;gt; 200 –&amp;gt; 关闭网站的标签页 –&amp;gt; 重新打开https://www.babytree.com –&amp;gt; 200(from disk cache) –&amp;gt; 刷新 –&amp;gt; 200(from memory cache) 过程如下： 1) 访问www.babytree.com 2) 关闭页面 3) 重新打开 4) 刷新 最后一个步骤刷新的时候，不是同时存在着from disk cache和from memory cache吗？ 对于这个问题，需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下: 内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性： 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。 时效性：一旦该进程关闭，则该进程的内存则会清空。 硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。 在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。 协商缓存 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304，如下 协商缓存失效，返回200和请求结果结果，如下 同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。 Last-Modified / If-Modified-Since Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。 If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下 Etag / If-None-Match Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。 If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下 注：Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。 总结 强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：</summary></entry><entry><title type="html">HTML 5.2?</title><link href="http://localhost:4000/2018/05/03/HTML5_2.html" rel="alternate" type="text/html" title="HTML 5.2?" /><published>2018-05-03T00:00:00+08:00</published><updated>2018-05-03T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/03/HTML5_2</id><content type="html" xml:base="http://localhost:4000/2018/05/03/HTML5_2.html">&lt;p&gt;一个月前，HTML 5.2 正式成为了 W3C 的推荐标准（REC）。当一个规范到达 REC 阶段，就意味着它已经正式得到了 W3C 成员和理事长的认可。并且 W3C 将正式推荐浏览器厂商部署、web 开发者实现此规范。&lt;/p&gt;

&lt;p&gt;在 HTML 5.2 中有一些添加和删除,&lt;a href=&quot;https://www.w3.org/TR/html52/changes.html#changes&quot;&gt;更多详细参考–HTML 5.2 变动内容&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;增加的新特性&quot;&gt;增加的新特性&lt;/h2&gt;

&lt;h3 id=&quot;dialog--原生对话框&quot;&gt;dialog  原生对话框&lt;/h3&gt;

&lt;p&gt;在 web 中，对话框比比皆是，但是它们的实现方式都各有不同。对话框很难实现可访问性，这导致大多数的对话框对那些不方便以视觉方式访问网页的用户来说都是不可用的。&lt;/p&gt;

&lt;p&gt;新的 dialog 元素旨在改变这种状况，它提供了一种简单的方式来实现模态对话框。之后我会单独写一篇文章专门介绍这个元素的工作方式，在此先简单介绍一下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;由一个 &amp;lt;dialog&amp;gt; 元素创建对话框：

&amp;lt;dialog&amp;gt;  
  &amp;lt;h2&amp;gt;Dialog Title&amp;lt;/h2&amp;gt;
  &amp;lt;p&amp;gt;Dialog content and other stuff will go here&amp;lt;/p&amp;gt;
&amp;lt;/dialog&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;默认情况下，对话框会在视图中（以及 DOM 访问中）隐藏，只有设置 open 属性后，对话框才会显示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dialog open&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;open 属性可以通过调用 show() 与 close() 方法开启或关闭，任何 HTMLDialogElement 都可以调用这两个方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;button id=&quot;open&quot;&amp;gt;Open Dialog&amp;lt;/button&amp;gt;  
&amp;lt;button id=&quot;close&quot;&amp;gt;Close Dialog&amp;lt;/button&amp;gt;

&amp;lt;dialog id=&quot;dialog&quot;&amp;gt;  
  &amp;lt;h2&amp;gt;Dialog Title&amp;lt;/h2&amp;gt;
  &amp;lt;p&amp;gt;Dialog content and other stuff will go here&amp;lt;/p&amp;gt;
&amp;lt;/dialog&amp;gt;

&amp;lt;script&amp;gt;  
const dialog = document.getElementById(&quot;dialog&quot;);

document.getElementById(&quot;open&quot;).addEventListener(&quot;click&quot;, () =&amp;gt; {  
  dialog.show();
});

document.getElementById(&quot;close&quot;).addEventListener(&quot;click&quot;, () =&amp;gt; {  
  dialog.close();
});
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Chrome 浏览器已经支持 &lt;dialog&gt; 元素，Firefox 也即将支持（behind a flag）&lt;/dialog&gt;&lt;/p&gt;

&lt;p&gt;主流浏览器兼容情况的数据&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180503/20180503-1.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;在-iframe-中使用-payment-request-api支付请求-api&quot;&gt;在 iFrame 中使用 Payment Request API（支付请求 API）&lt;/h3&gt;

&lt;p&gt;Payment Request API 是支付结算表单的原生替代方案。它将支付信息置于浏览器处理，用来代替之前各个网站各不相同的结算表单，旨在为用户提供一种标准、一致的支付方式。&lt;/p&gt;

&lt;p&gt;在 HTML 5.2 之前，这种支付请求无法在文档嵌入的 iframe 中使用，导致第三方嵌入式支付解决方案（如 Stripe, Paystack）基本不可能使用这个 API，因为它们通常是在 iframe 中处理支付接口。&lt;/p&gt;

&lt;p&gt;为此，HTML 5.2 引入了用于 iframe 的 allowpaymentrequest 属性，允许用户在宿主网页中访问 iframe 的 Payment Request API。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;iframe allowpaymentrequest&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;苹果的图标尺寸&quot;&gt;苹果的图标尺寸&lt;/h3&gt;

&lt;p&gt;如要定义网页图标，我们可以在文档的 head 中使用 link rel 元素。如果要定义不同尺寸的图标，我们可以使用 sizes 属性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;link rel=&quot;icon&quot; sizes=&quot;16x16&quot; href=&quot;path/to/icon16.png&quot;&amp;gt;  
&amp;lt;link rel=&quot;icon&quot; sizes=&quot;32x32&quot; href=&quot;path/to/icon32.png&quot;&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个属性虽然纯粹是个建议，但如果提供了多种尺寸的图标，可以让用户代理（UA）决定使用哪种尺寸的图标。在大多数设备有着不同的“最佳”图标尺寸时尤为重要。&lt;/p&gt;

&lt;p&gt;在 HTML 5.2 之前，sizes 属性仅能用于 rel 为 icon 的 link 元素中。然而，苹果的 iOS 设备不支持 sizes 属性。为了解决这个问题，苹果自己引入了一个他们设备专用的 rel appple-touch-icon 用于定义他们设备上使用的图标。&lt;/p&gt;

&lt;p&gt;在 HTML 5.2 中，规范定义了 sizes 属性不再仅仅可用于 rel 为 icon 的元素，也能用于 rel 为 apple-touch-icon 的元素。这样可以让我们为不同的苹果设备提供不同尺寸的图标。不过直到现在为止，据我所知苹果的设备还是不支持 sizes 属性。在将来苹果最终支持此规范时，它将派上用场。&lt;/p&gt;

&lt;h2 id=&quot;新的有效实践&quot;&gt;新的有效实践&lt;/h2&gt;

&lt;p&gt;除了新特性之外，HTML 5.2 还将一些之前无效的 HTML 写法认定为有效。&lt;/p&gt;

&lt;h3 id=&quot;多个-main-元素&quot;&gt;多个 main 元素&lt;/h3&gt;
&lt;p&gt;main 元素代表网页的主要内容。虽然不同网页的重复内容可以放在 header、section 或者其它元素中，但 main 元素是为页面上的特定内容保留的。因此在 HTML 5.2 之前，main 元素在 DOM 中必须唯一才能令页面有效。&lt;/p&gt;

&lt;p&gt;随着单页面应用（SPA）的普及，要坚持这个原则变得困难起来。在同一个网页的 DOM 中可能会有多个 main 元素，但在任意时刻只能给用户展示其中的一个。
使用 HTML 5.2，我们只要保证同一时刻只有一个 main 元素可见，就能在我们的标签中使用多个 main 元素。与此同时其它的 main 元素必须使用 hidden 属性进行隐藏。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;main&amp;gt;...&amp;lt;/main&amp;gt;  
&amp;lt;main hidden&amp;gt;...&amp;lt;/main&amp;gt;  
&amp;lt;main hidden&amp;gt;...&amp;lt;/main&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们都知道，通过 CSS 来隐藏元素的方法有很多，但多余的 main 元素必须使用 hidden 属性进行隐藏。任何其它隐藏此元素的方法（如 display: none; 和 visibility: hidden;）都将无效。&lt;/p&gt;

&lt;h3 id=&quot;legend-中的标题元素&quot;&gt;legend 中的标题元素&lt;/h3&gt;

&lt;p&gt;在表单中，legend 元素表示 fieldset 表单域中的标题。在 HTML 5.2 前，legend 元素的内容必须为纯文本。而现在，它可以包含标题元素（h1等）了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;fieldset&amp;gt;  
    &amp;lt;legend&amp;gt;&amp;lt;h2&amp;gt;Basic Information&amp;lt;/h2&amp;gt;&amp;lt;/legend&amp;gt;
    &amp;lt;!-- Form fields for basic information --&amp;gt;
&amp;lt;/fieldset&amp;gt;  
&amp;lt;fieldset&amp;gt;  
    &amp;lt;legend&amp;gt;&amp;lt;h2&amp;gt;Contact Information&amp;lt;/h2&amp;gt;&amp;lt;/legend&amp;gt;
    &amp;lt;!-- Form fields for contact information --&amp;gt;
&amp;lt;/fieldset&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们想用 fieldset 对表单中不同部分进行分组时，这个特性非常有用。在这种情况下使用标题元素是有意义的，因为这能让那些依赖于文档大纲的用户可以轻松导航至表单的对应部分。&lt;/p&gt;

&lt;h2 id=&quot;移除的特性&quot;&gt;移除的特性&lt;/h2&gt;

&lt;p&gt;在 HTML 5.2 中移除了一些元素，具体为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;keygen：曾经用于帮助表单生成公钥
menu 与 menuitem：曾经用于创建导航与内容菜单
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;新的无效实践&quot;&gt;新的无效实践&lt;/h2&gt;

&lt;p&gt;最后，一些开发实践方式被规定不再有效。&lt;/p&gt;

&lt;p&gt;在 p 中不再能包含行内、浮动、块类型的子元素&lt;/p&gt;

&lt;p&gt;在 HTML 5.2 中，p 元素中唯一合法的子元素只能是文字内容。这也意味着以下类型的元素不再能嵌套于段落标签 p 内：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;行内块（Inline blocks）&lt;/li&gt;
  &lt;li&gt;行内表格（Inline tables）&lt;/li&gt;
  &lt;li&gt;浮动块与固定位置块&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不再支持严格文档类型（Strict Doctypes）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&amp;gt;&lt;/span&gt; 

&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&amp;gt;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="JS" /><category term="HTML" /><summary type="html">一个月前，HTML 5.2 正式成为了 W3C 的推荐标准（REC）。当一个规范到达 REC 阶段，就意味着它已经正式得到了 W3C 成员和理事长的认可。并且 W3C 将正式推荐浏览器厂商部署、web 开发者实现此规范。 在 HTML 5.2 中有一些添加和删除,更多详细参考–HTML 5.2 变动内容 增加的新特性 dialog 原生对话框 在 web 中，对话框比比皆是，但是它们的实现方式都各有不同。对话框很难实现可访问性，这导致大多数的对话框对那些不方便以视觉方式访问网页的用户来说都是不可用的。 新的 dialog 元素旨在改变这种状况，它提供了一种简单的方式来实现模态对话框。之后我会单独写一篇文章专门介绍这个元素的工作方式，在此先简单介绍一下。 由一个 &amp;lt;dialog&amp;gt; 元素创建对话框： &amp;lt;dialog&amp;gt; &amp;lt;h2&amp;gt;Dialog Title&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;Dialog content and other stuff will go here&amp;lt;/p&amp;gt; &amp;lt;/dialog&amp;gt; 默认情况下，对话框会在视图中（以及 DOM 访问中）隐藏，只有设置 open 属性后，对话框才会显示。 &amp;lt;dialog open&amp;gt; open 属性可以通过调用 show() 与 close() 方法开启或关闭，任何 HTMLDialogElement 都可以调用这两个方法。 &amp;lt;button id=&quot;open&quot;&amp;gt;Open Dialog&amp;lt;/button&amp;gt; &amp;lt;button id=&quot;close&quot;&amp;gt;Close Dialog&amp;lt;/button&amp;gt; &amp;lt;dialog id=&quot;dialog&quot;&amp;gt; &amp;lt;h2&amp;gt;Dialog Title&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;Dialog content and other stuff will go here&amp;lt;/p&amp;gt; &amp;lt;/dialog&amp;gt; &amp;lt;script&amp;gt; const dialog = document.getElementById(&quot;dialog&quot;); document.getElementById(&quot;open&quot;).addEventListener(&quot;click&quot;, () =&amp;gt; { dialog.show(); }); document.getElementById(&quot;close&quot;).addEventListener(&quot;click&quot;, () =&amp;gt; { dialog.close(); }); &amp;lt;/script&amp;gt; Chrome 浏览器已经支持 元素，Firefox 也即将支持（behind a flag） 主流浏览器兼容情况的数据 在 iFrame 中使用 Payment Request API（支付请求 API） Payment Request API 是支付结算表单的原生替代方案。它将支付信息置于浏览器处理，用来代替之前各个网站各不相同的结算表单，旨在为用户提供一种标准、一致的支付方式。 在 HTML 5.2 之前，这种支付请求无法在文档嵌入的 iframe 中使用，导致第三方嵌入式支付解决方案（如 Stripe, Paystack）基本不可能使用这个 API，因为它们通常是在 iframe 中处理支付接口。 为此，HTML 5.2 引入了用于 iframe 的 allowpaymentrequest 属性，允许用户在宿主网页中访问 iframe 的 Payment Request API。 &amp;lt;iframe allowpaymentrequest&amp;gt; 苹果的图标尺寸 如要定义网页图标，我们可以在文档的 head 中使用 link rel 元素。如果要定义不同尺寸的图标，我们可以使用 sizes 属性。 &amp;lt;link rel=&quot;icon&quot; sizes=&quot;16x16&quot; href=&quot;path/to/icon16.png&quot;&amp;gt; &amp;lt;link rel=&quot;icon&quot; sizes=&quot;32x32&quot; href=&quot;path/to/icon32.png&quot;&amp;gt; 这个属性虽然纯粹是个建议，但如果提供了多种尺寸的图标，可以让用户代理（UA）决定使用哪种尺寸的图标。在大多数设备有着不同的“最佳”图标尺寸时尤为重要。 在 HTML 5.2 之前，sizes 属性仅能用于 rel 为 icon 的 link 元素中。然而，苹果的 iOS 设备不支持 sizes 属性。为了解决这个问题，苹果自己引入了一个他们设备专用的 rel appple-touch-icon 用于定义他们设备上使用的图标。 在 HTML 5.2 中，规范定义了 sizes 属性不再仅仅可用于 rel 为 icon 的元素，也能用于 rel 为 apple-touch-icon 的元素。这样可以让我们为不同的苹果设备提供不同尺寸的图标。不过直到现在为止，据我所知苹果的设备还是不支持 sizes 属性。在将来苹果最终支持此规范时，它将派上用场。 新的有效实践 除了新特性之外，HTML 5.2 还将一些之前无效的 HTML 写法认定为有效。 多个 main 元素 main 元素代表网页的主要内容。虽然不同网页的重复内容可以放在 header、section 或者其它元素中，但 main 元素是为页面上的特定内容保留的。因此在 HTML 5.2 之前，main 元素在 DOM 中必须唯一才能令页面有效。 随着单页面应用（SPA）的普及，要坚持这个原则变得困难起来。在同一个网页的 DOM 中可能会有多个 main 元素，但在任意时刻只能给用户展示其中的一个。 使用 HTML 5.2，我们只要保证同一时刻只有一个 main 元素可见，就能在我们的标签中使用多个 main 元素。与此同时其它的 main 元素必须使用 hidden 属性进行隐藏。 &amp;lt;main&amp;gt;...&amp;lt;/main&amp;gt; &amp;lt;main hidden&amp;gt;...&amp;lt;/main&amp;gt; &amp;lt;main hidden&amp;gt;...&amp;lt;/main&amp;gt; 我们都知道，通过 CSS 来隐藏元素的方法有很多，但多余的 main 元素必须使用 hidden 属性进行隐藏。任何其它隐藏此元素的方法（如 display: none; 和 visibility: hidden;）都将无效。 legend 中的标题元素 在表单中，legend 元素表示 fieldset 表单域中的标题。在 HTML 5.2 前，legend 元素的内容必须为纯文本。而现在，它可以包含标题元素（h1等）了。 &amp;lt;fieldset&amp;gt; &amp;lt;legend&amp;gt;&amp;lt;h2&amp;gt;Basic Information&amp;lt;/h2&amp;gt;&amp;lt;/legend&amp;gt; &amp;lt;!-- Form fields for basic information --&amp;gt; &amp;lt;/fieldset&amp;gt; &amp;lt;fieldset&amp;gt; &amp;lt;legend&amp;gt;&amp;lt;h2&amp;gt;Contact Information&amp;lt;/h2&amp;gt;&amp;lt;/legend&amp;gt; &amp;lt;!-- Form fields for contact information --&amp;gt; &amp;lt;/fieldset&amp;gt; 当我们想用 fieldset 对表单中不同部分进行分组时，这个特性非常有用。在这种情况下使用标题元素是有意义的，因为这能让那些依赖于文档大纲的用户可以轻松导航至表单的对应部分。 移除的特性 在 HTML 5.2 中移除了一些元素，具体为： keygen：曾经用于帮助表单生成公钥 menu 与 menuitem：曾经用于创建导航与内容菜单 新的无效实践 最后，一些开发实践方式被规定不再有效。 在 p 中不再能包含行内、浮动、块类型的子元素 在 HTML 5.2 中，p 元素中唯一合法的子元素只能是文字内容。这也意味着以下类型的元素不再能嵌套于段落标签 p 内： 行内块（Inline blocks） 行内表格（Inline tables） 浮动块与固定位置块 不再支持严格文档类型（Strict Doctypes） &amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&amp;gt; &amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&amp;gt;</summary></entry><entry><title type="html">Promise 对象</title><link href="http://localhost:4000/2018/04/03/Promise.html" rel="alternate" type="text/html" title="Promise 对象" /><published>2018-04-03T00:00:00+08:00</published><updated>2018-04-03T00:00:00+08:00</updated><id>http://localhost:4000/2018/04/03/Promise</id><content type="html" xml:base="http://localhost:4000/2018/04/03/Promise.html">&lt;h1 id=&quot;promise-对象&quot;&gt;Promise 对象&lt;/h1&gt;

&lt;p&gt;ES6中，新增了Promise对象，它主要用于处理异步回调代码，让代码不至于陷入回调嵌套的死路中。&lt;/p&gt;

&lt;h2 id=&quot;promise本质&quot;&gt;Promise本质&lt;/h2&gt;

&lt;p&gt;Promise本质上是一个构造器 ，专门用来构造对象的。自己身上有all、reject、resolve等方法，原型上有then、catch等的方法，它接受一个函数作为参数&lt;/p&gt;

&lt;h2 id=&quot;promise的几个重要方法&quot;&gt;Promise的几个重要方法&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;promise Promise.prototype.then( resolveFn, [rejectFn] )

  @param resolveFn( ...args )  
    函数，当Promise实例状态变为“完成”状态时会被执行，  
    用于将从当前promise中取出reresolve( ...args )中得到的参数（...args），  
    并进行相应的操作，比如将（args）传入另一个封装了promise构造器的函数，  
    并将该函数执行完成后返回的promise实例返回  
    @param ...args  
      参数列表，当前promise实例处于“完成”状态时，通过resolve(...args)得到的值。  
  @param [rejectFn( ...args )]  
    函数，可选，当Promise实例状态变为“失败”状态时会被执行，  
    用于将从当前promise中取出reject( ...args )中得到的参数（...args），  
    并进行相应的操作，比如将（args）传入另一个封装了promise构造器的函数，  
    并将该函数执行完成后返回的promise实例返回  
    @param ...args  
      参数列表，当前promise处于“完成”状态时，通过resolve(...args)得到的值。  
  @return promise  
    promise对象，resolveFn或rejectFn执行后的返回值，  
    我们一般会在fn中调用另一个封装了promise构造器的函数，  
    然后将其返回给then()方法，then()方法再将其作为then的返回值返回给当前链式调用处，  
    如果fn()返回的不是一个promise对象，then()会帮我们将fn()返回值封装成promise对象，  
    这样，我们就可以确保能够链式调用then()方法，并取得当前promise中获得的函数运行结果。  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then()方法定义在Promise.prototype上，用于为Promise实例添加状态更改时的回调函数，相当于监听一样。
当当前promise实例状态变为“完成”状态时，resolveFn函数自动执行。
当当前promise实例状态变为“失败”状态时，rejectFn函数自动执行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;promise Promise.prototype.catch( rejectFn )

  @param rejectFn( ...args )  
    函数，当Promise实例状态变为“失败”状态时会被执行，  
    用于将从当前promise中取出reject( ...args )中得到的参数（...args），  
    并进行相应的操作，比如将（args）传入另一个封装了promise构造器的函数，  
    并将该函数执行完成后返回的promise实例返回  
    @param ...args  
      参数列表，当前promise处于“完成”状态时，通过resolve(...args)得到的值。  
  @return promise  
    promise对象，rejectFn执行后的返回值，  
    如果fn()返回的不是一个promise对象，catch()会帮我们将fn()返回值封装成promise对象，  
    并将其返回，以确保promise能够被继续链式调用下去。  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该方法其实是“.then(null, rejectFn)”的别名，用于指定状态转为“失败”时的回调函数。
建议不要在then()方法中定义第二个参数，而应该使用catch()，结构层次会更好一些。
如果没有使用catch()方法指定错误错误处理的回调函数，promise实例抛出的错误不会传递到外层代码。
如果promise状态已经变为了resolved（“失败”状态），再抛出任何错误，都是无效的。
promise实例中抛出的错误具有冒泡的特性，它会一直向后传递，直到被捕获为止。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Promise.all( [promise1, promise2, …, promisen] )

  @param [promise1, promise2, ..., promisen]
    可遍历对象，一个由promise对象构成的可遍历对象，常用数组表示
  @return promise
    promise对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Promise.all()用于将多个Promise实例包装成一个新的Promise实例，并返回。
Promise.all()方法接受一个由Promise实例组成的可遍历对象。如果可遍历对象中存在有不是Promise实例的元素，就会调用Promise.resolve()方法，将其转为Promise实例。
本文的可遍历对象，指的是那些具有Iterator接口的对象，如Array、WeakSet、Map、Set、WeakMap等函数的实例。&lt;/p&gt;

&lt;p&gt;Promise.all()方法返回的Promise实例的状态分成两种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可遍历对象中的Promise实例状态全变为 完成 状态时，该实例的状态才会转变为 完成 状态，此时，可遍历对象中的Promise实例的返回值会组成一个数组，传给该实例的回调。&lt;/li&gt;
  &lt;li&gt;可遍历对象只要存在Promise实例状态转为 失败 状态时，该实例的状态就会转变为 失败 状态，此时，第一个转为 失败 状态的Promise实例的返回值会传给该实例的回调。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Promise.race( [promise1, promise2, …, promisen] )
  @param [promise1, promise2, ..., promisen]
    可遍历对象，一个由promise对象构成的可遍历对象，常用数组表示
  @return promise
    promise对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Promise.race()与Promise.all()用法基本上一致，功能上也几乎相同，唯一的差异就是： 
Promise.race()方法返回的Promise实例的状态分成两种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可遍历对象只要存在Promise实例状态转为 完成 状态时，该实例的状态才会转变为 完成 状态，此时，第一个转为 完成 状态的Promise实例的返回值，会作为该实例的then()方法的回调函数的参数。&lt;/li&gt;
  &lt;li&gt;可遍历对象只要存在Promise实例状态转为 失败 状态时，该实例的状态就会转变为 失败 状态，此时，第一个转为 失败 状态的Promise实例的返回值，会作为该实例的then()方法的回调函数的参数。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;promise Promise.resolve( notHaveThenMethodObject )
  @param notHaveThenMethodObject
    对象，一个原型链上不具有then()方法的对象
  @return promise
    promise对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果Promise.resolve()的参数的原型链上不具有then方法，则返回一个新的Promise实例，且其状态为 完成 状态，并且会将它的参数作为该实例的then()方法的回调函数的参数。&lt;/p&gt;

&lt;p&gt;如果Promise.resolve()的参数是一个Promise实例（原型链上具有then方法），则将其原封不动地返回。&lt;/p&gt;

&lt;p&gt;Promise.resolve()方法允许调用时不使用任何参数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;promise Promise.reject( something )
  @param something
    任意值，用于传递给返回值的then()方法的回调函数参数的值
  @return promise
    promise对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Promise.reject方法的用法和resolve方法基本一样，只是它返回的Promise实例，状态都是 失败 状态。
Promise.reject方法的参数会被作为该实例的then()方法的回调函数的参数。
Promise.resolve()方法允许调用时不使用任何参数。&lt;/p&gt;

&lt;p&gt;Promise构造器回调函数参数中的 resolve 和 reject 和Promise构造器方法中的 reject() 和 resolve() 效果是不一样的。
Promise构造器回调函数参数中的 resolve 和 reject 用于更改当前Promise的状态，并将其值返回给当前Promise的then()方法的参数。 Promise构造器方法中的 reject() 和 resolve() 可以直接返回一个已经改变状态的新的Promise对象。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Promise.reject() Promise.resolve()&lt;/li&gt;
  &lt;li&gt;new Promise((resolve, reject)=&amp;gt;{ resolve(…) 或 reject(…) })&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Promise.prototype.done( [resolveFn], [rejectFn] )
  @param [resolveFn( ...args )]  
    函数，可选，当Promise实例状态变为“完成”状态时会被执行，  
    用于将从当前promise中取出reresolve( ...args )中得到的参数（...args），  
    并进行相应的操作，比如将（args）传入另一个封装了promise构造器的函数，  
    并将该函数执行完成后返回的promise实例返回  
    @param ...args  
      参数列表，当前promise实例处于“完成”状态时，通过resolve(...args)得到的值。  
  @param [rejectFn( ...args )]  
    函数，可选，当Promise实例状态变为“失败”状态时会被执行，  
    用于将从当前promise中取出reject( ...args )中得到的参数（...args），  
    并进行相应的操作，比如将（args）传入另一个封装了promise构造器的函数，  
    并将该函数执行完成后返回的promise实例返回  
    @param ...args  
      参数列表，当前promise处于“完成”状态时，通过resolve(...args)得到的值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不管以then()或catch()方法结尾，若最后一个方法抛出错误，则在内部可能无法捕捉到该错误，外界也无法获得，为了避免这种情况发生，Promise构造器的原型链上提供了done()方法。&lt;/p&gt;

&lt;p&gt;promise.done()方法总是处于会调链的低端，它可以捕捉到任何在回调链上抛出的错误，并将其抛出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Promise.prototype.finally( simpleFn )
  @param simpleFn  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个普通函数，这个普通函数无论如何都会被执行。&lt;br /&gt;
finally方法指定，不管Promise对象最后状态如何，都会执行的操作。&lt;/p&gt;</content><author><name>weili</name></author><category term="JS" /><category term="Promise" /><category term="前端" /><summary type="html">Promise 对象 ES6中，新增了Promise对象，它主要用于处理异步回调代码，让代码不至于陷入回调嵌套的死路中。 Promise本质 Promise本质上是一个构造器 ，专门用来构造对象的。自己身上有all、reject、resolve等方法，原型上有then、catch等的方法，它接受一个函数作为参数 Promise的几个重要方法 promise Promise.prototype.then( resolveFn, [rejectFn] ) @param resolveFn( ...args ) 函数，当Promise实例状态变为“完成”状态时会被执行， 用于将从当前promise中取出reresolve( ...args )中得到的参数（...args）， 并进行相应的操作，比如将（args）传入另一个封装了promise构造器的函数， 并将该函数执行完成后返回的promise实例返回 @param ...args 参数列表，当前promise实例处于“完成”状态时，通过resolve(...args)得到的值。 @param [rejectFn( ...args )] 函数，可选，当Promise实例状态变为“失败”状态时会被执行， 用于将从当前promise中取出reject( ...args )中得到的参数（...args）， 并进行相应的操作，比如将（args）传入另一个封装了promise构造器的函数， 并将该函数执行完成后返回的promise实例返回 @param ...args 参数列表，当前promise处于“完成”状态时，通过resolve(...args)得到的值。 @return promise promise对象，resolveFn或rejectFn执行后的返回值， 我们一般会在fn中调用另一个封装了promise构造器的函数， 然后将其返回给then()方法，then()方法再将其作为then的返回值返回给当前链式调用处， 如果fn()返回的不是一个promise对象，then()会帮我们将fn()返回值封装成promise对象， 这样，我们就可以确保能够链式调用then()方法，并取得当前promise中获得的函数运行结果。 then()方法定义在Promise.prototype上，用于为Promise实例添加状态更改时的回调函数，相当于监听一样。 当当前promise实例状态变为“完成”状态时，resolveFn函数自动执行。 当当前promise实例状态变为“失败”状态时，rejectFn函数自动执行。 promise Promise.prototype.catch( rejectFn ) @param rejectFn( ...args ) 函数，当Promise实例状态变为“失败”状态时会被执行， 用于将从当前promise中取出reject( ...args )中得到的参数（...args）， 并进行相应的操作，比如将（args）传入另一个封装了promise构造器的函数， 并将该函数执行完成后返回的promise实例返回 @param ...args 参数列表，当前promise处于“完成”状态时，通过resolve(...args)得到的值。 @return promise promise对象，rejectFn执行后的返回值， 如果fn()返回的不是一个promise对象，catch()会帮我们将fn()返回值封装成promise对象， 并将其返回，以确保promise能够被继续链式调用下去。 该方法其实是“.then(null, rejectFn)”的别名，用于指定状态转为“失败”时的回调函数。 建议不要在then()方法中定义第二个参数，而应该使用catch()，结构层次会更好一些。 如果没有使用catch()方法指定错误错误处理的回调函数，promise实例抛出的错误不会传递到外层代码。 如果promise状态已经变为了resolved（“失败”状态），再抛出任何错误，都是无效的。 promise实例中抛出的错误具有冒泡的特性，它会一直向后传递，直到被捕获为止。 Promise.all( [promise1, promise2, …, promisen] ) @param [promise1, promise2, ..., promisen] 可遍历对象，一个由promise对象构成的可遍历对象，常用数组表示 @return promise promise对象 Promise.all()用于将多个Promise实例包装成一个新的Promise实例，并返回。 Promise.all()方法接受一个由Promise实例组成的可遍历对象。如果可遍历对象中存在有不是Promise实例的元素，就会调用Promise.resolve()方法，将其转为Promise实例。 本文的可遍历对象，指的是那些具有Iterator接口的对象，如Array、WeakSet、Map、Set、WeakMap等函数的实例。 Promise.all()方法返回的Promise实例的状态分成两种情况： 可遍历对象中的Promise实例状态全变为 完成 状态时，该实例的状态才会转变为 完成 状态，此时，可遍历对象中的Promise实例的返回值会组成一个数组，传给该实例的回调。 可遍历对象只要存在Promise实例状态转为 失败 状态时，该实例的状态就会转变为 失败 状态，此时，第一个转为 失败 状态的Promise实例的返回值会传给该实例的回调。 Promise.race( [promise1, promise2, …, promisen] ) @param [promise1, promise2, ..., promisen] 可遍历对象，一个由promise对象构成的可遍历对象，常用数组表示 @return promise promise对象 Promise.race()与Promise.all()用法基本上一致，功能上也几乎相同，唯一的差异就是： Promise.race()方法返回的Promise实例的状态分成两种情况： 可遍历对象只要存在Promise实例状态转为 完成 状态时，该实例的状态才会转变为 完成 状态，此时，第一个转为 完成 状态的Promise实例的返回值，会作为该实例的then()方法的回调函数的参数。 可遍历对象只要存在Promise实例状态转为 失败 状态时，该实例的状态就会转变为 失败 状态，此时，第一个转为 失败 状态的Promise实例的返回值，会作为该实例的then()方法的回调函数的参数。 promise Promise.resolve( notHaveThenMethodObject ) @param notHaveThenMethodObject 对象，一个原型链上不具有then()方法的对象 @return promise promise对象 如果Promise.resolve()的参数的原型链上不具有then方法，则返回一个新的Promise实例，且其状态为 完成 状态，并且会将它的参数作为该实例的then()方法的回调函数的参数。 如果Promise.resolve()的参数是一个Promise实例（原型链上具有then方法），则将其原封不动地返回。 Promise.resolve()方法允许调用时不使用任何参数。 promise Promise.reject( something ) @param something 任意值，用于传递给返回值的then()方法的回调函数参数的值 @return promise promise对象 Promise.reject方法的用法和resolve方法基本一样，只是它返回的Promise实例，状态都是 失败 状态。 Promise.reject方法的参数会被作为该实例的then()方法的回调函数的参数。 Promise.resolve()方法允许调用时不使用任何参数。 Promise构造器回调函数参数中的 resolve 和 reject 和Promise构造器方法中的 reject() 和 resolve() 效果是不一样的。 Promise构造器回调函数参数中的 resolve 和 reject 用于更改当前Promise的状态，并将其值返回给当前Promise的then()方法的参数。 Promise构造器方法中的 reject() 和 resolve() 可以直接返回一个已经改变状态的新的Promise对象。 Promise.reject() Promise.resolve() new Promise((resolve, reject)=&amp;gt;{ resolve(…) 或 reject(…) }) Promise.prototype.done( [resolveFn], [rejectFn] ) @param [resolveFn( ...args )] 函数，可选，当Promise实例状态变为“完成”状态时会被执行， 用于将从当前promise中取出reresolve( ...args )中得到的参数（...args）， 并进行相应的操作，比如将（args）传入另一个封装了promise构造器的函数， 并将该函数执行完成后返回的promise实例返回 @param ...args 参数列表，当前promise实例处于“完成”状态时，通过resolve(...args)得到的值。 @param [rejectFn( ...args )] 函数，可选，当Promise实例状态变为“失败”状态时会被执行， 用于将从当前promise中取出reject( ...args )中得到的参数（...args）， 并进行相应的操作，比如将（args）传入另一个封装了promise构造器的函数， 并将该函数执行完成后返回的promise实例返回 @param ...args 参数列表，当前promise处于“完成”状态时，通过resolve(...args)得到的值。 不管以then()或catch()方法结尾，若最后一个方法抛出错误，则在内部可能无法捕捉到该错误，外界也无法获得，为了避免这种情况发生，Promise构造器的原型链上提供了done()方法。 promise.done()方法总是处于会调链的低端，它可以捕捉到任何在回调链上抛出的错误，并将其抛出。 Promise.prototype.finally( simpleFn ) @param simpleFn 一个普通函数，这个普通函数无论如何都会被执行。 finally方法指定，不管Promise对象最后状态如何，都会执行的操作。</summary></entry><entry><title type="html">basic-knowledge(一).md</title><link href="http://localhost:4000/js/2018/03/31/basic-knowledge-1.html" rel="alternate" type="text/html" title="basic-knowledge(一).md" /><published>2018-03-31T00:00:00+08:00</published><updated>2018-03-31T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/03/31/basic-knowledge-1</id><content type="html" xml:base="http://localhost:4000/js/2018/03/31/basic-knowledge-1.html">&lt;h1 id=&quot;项目小知识点&quot;&gt;项目小知识点&lt;/h1&gt;

&lt;p&gt;项目中用到的一些小知识点，用于记录一下：&lt;/p&gt;

&lt;p&gt;1、 数组去重&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = [1,10,4,6,10,9,8,6,10]

    // 从前向后逐个比较，相同的删除
    Array.prototype.distinct1 = function () {
        var arr = this;
        for(var i=0; i&amp;lt;arr.length; i++) {
            for(var j=i+1; j&amp;lt;arr.length; j++) {
                if(arr[i] === arr[j]) {
                    arr.splice(j,1)
                    j = ++i;
                }
            }
        }
        return arr
    }

    // 从前向后比较，不相同的push到新数组
    Array.prototype.distinct2 = function () {
        var arr = this;
        var temp = [];
        for(var i=0; i&amp;lt;arr.length; i++) {
            for(var j=i+1; j&amp;lt;arr.length; j++) {
                if(arr[i] === arr[j]) {
                    j = ++i;
                }
            }
            temp.push(arr[i])
        }
        return temp
    }

    // 利用对象属性名不能重复的特性
    Array.prototype.distinct3 = function () {
        var obj = {};
        var arr =this;
        var temp = [];
        for(var i=0; i&amp;lt;arr.length; i++) {
            if(!obj[arr[i]]) {
                temp.push(arr[i])
                obj[arr[i]] = 1;
            }
        }
        return temp
    }

    // 利用indexOf 如果无法匹配到相同的，push进新数组
    Array.prototype.distinct4 = function () {
        var arr = this;
        var temp = [];
        arr.forEach(function (item, i) {
            var num = arr.indexOf(item, i+1)
            if(num === -1) {
                temp.push(item)
            }
        })
        return temp
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">项目小知识点 项目中用到的一些小知识点，用于记录一下： 1、 数组去重 var arr = [1,10,4,6,10,9,8,6,10] // 从前向后逐个比较，相同的删除 Array.prototype.distinct1 = function () { var arr = this; for(var i=0; i&amp;lt;arr.length; i++) { for(var j=i+1; j&amp;lt;arr.length; j++) { if(arr[i] === arr[j]) { arr.splice(j,1) j = ++i; } } } return arr } // 从前向后比较，不相同的push到新数组 Array.prototype.distinct2 = function () { var arr = this; var temp = []; for(var i=0; i&amp;lt;arr.length; i++) { for(var j=i+1; j&amp;lt;arr.length; j++) { if(arr[i] === arr[j]) { j = ++i; } } temp.push(arr[i]) } return temp } // 利用对象属性名不能重复的特性 Array.prototype.distinct3 = function () { var obj = {}; var arr =this; var temp = []; for(var i=0; i&amp;lt;arr.length; i++) { if(!obj[arr[i]]) { temp.push(arr[i]) obj[arr[i]] = 1; } } return temp } // 利用indexOf 如果无法匹配到相同的，push进新数组 Array.prototype.distinct4 = function () { var arr = this; var temp = []; arr.forEach(function (item, i) { var num = arr.indexOf(item, i+1) if(num === -1) { temp.push(item) } }) return temp }</summary></entry></feed>