<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.7.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2018-05-04T18:45:38+08:00</updated><id>http://localhost:4000/</id><title type="html">Weili’s Blog</title><subtitle>Weili's blog
</subtitle><author><name>weili</name></author><entry><title type="html">HTML 5.2?</title><link href="http://localhost:4000/2018/05/03/HTML5_2.html" rel="alternate" type="text/html" title="HTML 5.2?" /><published>2018-05-03T00:00:00+08:00</published><updated>2018-05-03T00:00:00+08:00</updated><id>http://localhost:4000/2018/05/03/HTML5_2</id><content type="html" xml:base="http://localhost:4000/2018/05/03/HTML5_2.html">&lt;p&gt;一个月前，HTML 5.2 正式成为了 W3C 的推荐标准（REC）。当一个规范到达 REC 阶段，就意味着它已经正式得到了 W3C 成员和理事长的认可。并且 W3C 将正式推荐浏览器厂商部署、web 开发者实现此规范。&lt;/p&gt;

&lt;p&gt;在 HTML 5.2 中有一些添加和删除,&lt;a href=&quot;https://www.w3.org/TR/html52/changes.html#changes&quot;&gt;更多详细参考–HTML 5.2 变动内容&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;增加的新特性&quot;&gt;增加的新特性&lt;/h2&gt;

&lt;h3 id=&quot;dialog--原生对话框&quot;&gt;dialog  原生对话框&lt;/h3&gt;

&lt;p&gt;在 web 中，对话框比比皆是，但是它们的实现方式都各有不同。对话框很难实现可访问性，这导致大多数的对话框对那些不方便以视觉方式访问网页的用户来说都是不可用的。&lt;/p&gt;

&lt;p&gt;新的 dialog 元素旨在改变这种状况，它提供了一种简单的方式来实现模态对话框。之后我会单独写一篇文章专门介绍这个元素的工作方式，在此先简单介绍一下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;由一个 &amp;lt;dialog&amp;gt; 元素创建对话框：

&amp;lt;dialog&amp;gt;  
  &amp;lt;h2&amp;gt;Dialog Title&amp;lt;/h2&amp;gt;
  &amp;lt;p&amp;gt;Dialog content and other stuff will go here&amp;lt;/p&amp;gt;
&amp;lt;/dialog&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;默认情况下，对话框会在视图中（以及 DOM 访问中）隐藏，只有设置 open 属性后，对话框才会显示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dialog open&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;open 属性可以通过调用 show() 与 close() 方法开启或关闭，任何 HTMLDialogElement 都可以调用这两个方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;button id=&quot;open&quot;&amp;gt;Open Dialog&amp;lt;/button&amp;gt;  
&amp;lt;button id=&quot;close&quot;&amp;gt;Close Dialog&amp;lt;/button&amp;gt;

&amp;lt;dialog id=&quot;dialog&quot;&amp;gt;  
  &amp;lt;h2&amp;gt;Dialog Title&amp;lt;/h2&amp;gt;
  &amp;lt;p&amp;gt;Dialog content and other stuff will go here&amp;lt;/p&amp;gt;
&amp;lt;/dialog&amp;gt;

&amp;lt;script&amp;gt;  
const dialog = document.getElementById(&quot;dialog&quot;);

document.getElementById(&quot;open&quot;).addEventListener(&quot;click&quot;, () =&amp;gt; {  
  dialog.show();
});

document.getElementById(&quot;close&quot;).addEventListener(&quot;click&quot;, () =&amp;gt; {  
  dialog.close();
});
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Chrome 浏览器已经支持 &lt;dialog&gt; 元素，Firefox 也即将支持（behind a flag）&lt;/dialog&gt;&lt;/p&gt;

&lt;p&gt;主流浏览器兼容情况的数据&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180503/20180503-1.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;在-iframe-中使用-payment-request-api支付请求-api&quot;&gt;在 iFrame 中使用 Payment Request API（支付请求 API）&lt;/h3&gt;

&lt;p&gt;Payment Request API 是支付结算表单的原生替代方案。它将支付信息置于浏览器处理，用来代替之前各个网站各不相同的结算表单，旨在为用户提供一种标准、一致的支付方式。&lt;/p&gt;

&lt;p&gt;在 HTML 5.2 之前，这种支付请求无法在文档嵌入的 iframe 中使用，导致第三方嵌入式支付解决方案（如 Stripe, Paystack）基本不可能使用这个 API，因为它们通常是在 iframe 中处理支付接口。&lt;/p&gt;

&lt;p&gt;为此，HTML 5.2 引入了用于 iframe 的 allowpaymentrequest 属性，允许用户在宿主网页中访问 iframe 的 Payment Request API。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;iframe allowpaymentrequest&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;苹果的图标尺寸&quot;&gt;苹果的图标尺寸&lt;/h3&gt;

&lt;p&gt;如要定义网页图标，我们可以在文档的 head 中使用 link rel 元素。如果要定义不同尺寸的图标，我们可以使用 sizes 属性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;link rel=&quot;icon&quot; sizes=&quot;16x16&quot; href=&quot;path/to/icon16.png&quot;&amp;gt;  
&amp;lt;link rel=&quot;icon&quot; sizes=&quot;32x32&quot; href=&quot;path/to/icon32.png&quot;&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个属性虽然纯粹是个建议，但如果提供了多种尺寸的图标，可以让用户代理（UA）决定使用哪种尺寸的图标。在大多数设备有着不同的“最佳”图标尺寸时尤为重要。&lt;/p&gt;

&lt;p&gt;在 HTML 5.2 之前，sizes 属性仅能用于 rel 为 icon 的 link 元素中。然而，苹果的 iOS 设备不支持 sizes 属性。为了解决这个问题，苹果自己引入了一个他们设备专用的 rel appple-touch-icon 用于定义他们设备上使用的图标。&lt;/p&gt;

&lt;p&gt;在 HTML 5.2 中，规范定义了 sizes 属性不再仅仅可用于 rel 为 icon 的元素，也能用于 rel 为 apple-touch-icon 的元素。这样可以让我们为不同的苹果设备提供不同尺寸的图标。不过直到现在为止，据我所知苹果的设备还是不支持 sizes 属性。在将来苹果最终支持此规范时，它将派上用场。&lt;/p&gt;

&lt;h2 id=&quot;新的有效实践&quot;&gt;新的有效实践&lt;/h2&gt;

&lt;p&gt;除了新特性之外，HTML 5.2 还将一些之前无效的 HTML 写法认定为有效。&lt;/p&gt;

&lt;h3 id=&quot;多个-main-元素&quot;&gt;多个 main 元素&lt;/h3&gt;
&lt;p&gt;main 元素代表网页的主要内容。虽然不同网页的重复内容可以放在 header、section 或者其它元素中，但 main 元素是为页面上的特定内容保留的。因此在 HTML 5.2 之前，main 元素在 DOM 中必须唯一才能令页面有效。&lt;/p&gt;

&lt;p&gt;随着单页面应用（SPA）的普及，要坚持这个原则变得困难起来。在同一个网页的 DOM 中可能会有多个 main 元素，但在任意时刻只能给用户展示其中的一个。
使用 HTML 5.2，我们只要保证同一时刻只有一个 main 元素可见，就能在我们的标签中使用多个 main 元素。与此同时其它的 main 元素必须使用 hidden 属性进行隐藏。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;main&amp;gt;...&amp;lt;/main&amp;gt;  
&amp;lt;main hidden&amp;gt;...&amp;lt;/main&amp;gt;  
&amp;lt;main hidden&amp;gt;...&amp;lt;/main&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们都知道，通过 CSS 来隐藏元素的方法有很多，但多余的 main 元素必须使用 hidden 属性进行隐藏。任何其它隐藏此元素的方法（如 display: none; 和 visibility: hidden;）都将无效。&lt;/p&gt;

&lt;h3 id=&quot;legend-中的标题元素&quot;&gt;legend 中的标题元素&lt;/h3&gt;

&lt;p&gt;在表单中，legend 元素表示 fieldset 表单域中的标题。在 HTML 5.2 前，legend 元素的内容必须为纯文本。而现在，它可以包含标题元素（h1等）了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;fieldset&amp;gt;  
    &amp;lt;legend&amp;gt;&amp;lt;h2&amp;gt;Basic Information&amp;lt;/h2&amp;gt;&amp;lt;/legend&amp;gt;
    &amp;lt;!-- Form fields for basic information --&amp;gt;
&amp;lt;/fieldset&amp;gt;  
&amp;lt;fieldset&amp;gt;  
    &amp;lt;legend&amp;gt;&amp;lt;h2&amp;gt;Contact Information&amp;lt;/h2&amp;gt;&amp;lt;/legend&amp;gt;
    &amp;lt;!-- Form fields for contact information --&amp;gt;
&amp;lt;/fieldset&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们想用 fieldset 对表单中不同部分进行分组时，这个特性非常有用。在这种情况下使用标题元素是有意义的，因为这能让那些依赖于文档大纲的用户可以轻松导航至表单的对应部分。&lt;/p&gt;

&lt;h2 id=&quot;移除的特性&quot;&gt;移除的特性&lt;/h2&gt;

&lt;p&gt;在 HTML 5.2 中移除了一些元素，具体为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;keygen：曾经用于帮助表单生成公钥
menu 与 menuitem：曾经用于创建导航与内容菜单
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;新的无效实践&quot;&gt;新的无效实践&lt;/h2&gt;

&lt;p&gt;最后，一些开发实践方式被规定不再有效。&lt;/p&gt;

&lt;p&gt;在 p 中不再能包含行内、浮动、块类型的子元素&lt;/p&gt;

&lt;p&gt;在 HTML 5.2 中，p 元素中唯一合法的子元素只能是文字内容。这也意味着以下类型的元素不再能嵌套于段落标签 p 内：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;行内块（Inline blocks）&lt;/li&gt;
  &lt;li&gt;行内表格（Inline tables）&lt;/li&gt;
  &lt;li&gt;浮动块与固定位置块&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不再支持严格文档类型（Strict Doctypes）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&amp;gt;&lt;/span&gt; 

&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&amp;gt;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="JS" /><category term="HTML" /><summary type="html">一个月前，HTML 5.2 正式成为了 W3C 的推荐标准（REC）。当一个规范到达 REC 阶段，就意味着它已经正式得到了 W3C 成员和理事长的认可。并且 W3C 将正式推荐浏览器厂商部署、web 开发者实现此规范。 在 HTML 5.2 中有一些添加和删除,更多详细参考–HTML 5.2 变动内容 增加的新特性 dialog 原生对话框 在 web 中，对话框比比皆是，但是它们的实现方式都各有不同。对话框很难实现可访问性，这导致大多数的对话框对那些不方便以视觉方式访问网页的用户来说都是不可用的。 新的 dialog 元素旨在改变这种状况，它提供了一种简单的方式来实现模态对话框。之后我会单独写一篇文章专门介绍这个元素的工作方式，在此先简单介绍一下。 由一个 &amp;lt;dialog&amp;gt; 元素创建对话框： &amp;lt;dialog&amp;gt; &amp;lt;h2&amp;gt;Dialog Title&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;Dialog content and other stuff will go here&amp;lt;/p&amp;gt; &amp;lt;/dialog&amp;gt; 默认情况下，对话框会在视图中（以及 DOM 访问中）隐藏，只有设置 open 属性后，对话框才会显示。 &amp;lt;dialog open&amp;gt; open 属性可以通过调用 show() 与 close() 方法开启或关闭，任何 HTMLDialogElement 都可以调用这两个方法。 &amp;lt;button id=&quot;open&quot;&amp;gt;Open Dialog&amp;lt;/button&amp;gt; &amp;lt;button id=&quot;close&quot;&amp;gt;Close Dialog&amp;lt;/button&amp;gt; &amp;lt;dialog id=&quot;dialog&quot;&amp;gt; &amp;lt;h2&amp;gt;Dialog Title&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;Dialog content and other stuff will go here&amp;lt;/p&amp;gt; &amp;lt;/dialog&amp;gt; &amp;lt;script&amp;gt; const dialog = document.getElementById(&quot;dialog&quot;); document.getElementById(&quot;open&quot;).addEventListener(&quot;click&quot;, () =&amp;gt; { dialog.show(); }); document.getElementById(&quot;close&quot;).addEventListener(&quot;click&quot;, () =&amp;gt; { dialog.close(); }); &amp;lt;/script&amp;gt; Chrome 浏览器已经支持 元素，Firefox 也即将支持（behind a flag） 主流浏览器兼容情况的数据 在 iFrame 中使用 Payment Request API（支付请求 API） Payment Request API 是支付结算表单的原生替代方案。它将支付信息置于浏览器处理，用来代替之前各个网站各不相同的结算表单，旨在为用户提供一种标准、一致的支付方式。 在 HTML 5.2 之前，这种支付请求无法在文档嵌入的 iframe 中使用，导致第三方嵌入式支付解决方案（如 Stripe, Paystack）基本不可能使用这个 API，因为它们通常是在 iframe 中处理支付接口。 为此，HTML 5.2 引入了用于 iframe 的 allowpaymentrequest 属性，允许用户在宿主网页中访问 iframe 的 Payment Request API。 &amp;lt;iframe allowpaymentrequest&amp;gt; 苹果的图标尺寸 如要定义网页图标，我们可以在文档的 head 中使用 link rel 元素。如果要定义不同尺寸的图标，我们可以使用 sizes 属性。 &amp;lt;link rel=&quot;icon&quot; sizes=&quot;16x16&quot; href=&quot;path/to/icon16.png&quot;&amp;gt; &amp;lt;link rel=&quot;icon&quot; sizes=&quot;32x32&quot; href=&quot;path/to/icon32.png&quot;&amp;gt; 这个属性虽然纯粹是个建议，但如果提供了多种尺寸的图标，可以让用户代理（UA）决定使用哪种尺寸的图标。在大多数设备有着不同的“最佳”图标尺寸时尤为重要。 在 HTML 5.2 之前，sizes 属性仅能用于 rel 为 icon 的 link 元素中。然而，苹果的 iOS 设备不支持 sizes 属性。为了解决这个问题，苹果自己引入了一个他们设备专用的 rel appple-touch-icon 用于定义他们设备上使用的图标。 在 HTML 5.2 中，规范定义了 sizes 属性不再仅仅可用于 rel 为 icon 的元素，也能用于 rel 为 apple-touch-icon 的元素。这样可以让我们为不同的苹果设备提供不同尺寸的图标。不过直到现在为止，据我所知苹果的设备还是不支持 sizes 属性。在将来苹果最终支持此规范时，它将派上用场。 新的有效实践 除了新特性之外，HTML 5.2 还将一些之前无效的 HTML 写法认定为有效。 多个 main 元素 main 元素代表网页的主要内容。虽然不同网页的重复内容可以放在 header、section 或者其它元素中，但 main 元素是为页面上的特定内容保留的。因此在 HTML 5.2 之前，main 元素在 DOM 中必须唯一才能令页面有效。 随着单页面应用（SPA）的普及，要坚持这个原则变得困难起来。在同一个网页的 DOM 中可能会有多个 main 元素，但在任意时刻只能给用户展示其中的一个。 使用 HTML 5.2，我们只要保证同一时刻只有一个 main 元素可见，就能在我们的标签中使用多个 main 元素。与此同时其它的 main 元素必须使用 hidden 属性进行隐藏。 &amp;lt;main&amp;gt;...&amp;lt;/main&amp;gt; &amp;lt;main hidden&amp;gt;...&amp;lt;/main&amp;gt; &amp;lt;main hidden&amp;gt;...&amp;lt;/main&amp;gt; 我们都知道，通过 CSS 来隐藏元素的方法有很多，但多余的 main 元素必须使用 hidden 属性进行隐藏。任何其它隐藏此元素的方法（如 display: none; 和 visibility: hidden;）都将无效。 legend 中的标题元素 在表单中，legend 元素表示 fieldset 表单域中的标题。在 HTML 5.2 前，legend 元素的内容必须为纯文本。而现在，它可以包含标题元素（h1等）了。 &amp;lt;fieldset&amp;gt; &amp;lt;legend&amp;gt;&amp;lt;h2&amp;gt;Basic Information&amp;lt;/h2&amp;gt;&amp;lt;/legend&amp;gt; &amp;lt;!-- Form fields for basic information --&amp;gt; &amp;lt;/fieldset&amp;gt; &amp;lt;fieldset&amp;gt; &amp;lt;legend&amp;gt;&amp;lt;h2&amp;gt;Contact Information&amp;lt;/h2&amp;gt;&amp;lt;/legend&amp;gt; &amp;lt;!-- Form fields for contact information --&amp;gt; &amp;lt;/fieldset&amp;gt; 当我们想用 fieldset 对表单中不同部分进行分组时，这个特性非常有用。在这种情况下使用标题元素是有意义的，因为这能让那些依赖于文档大纲的用户可以轻松导航至表单的对应部分。 移除的特性 在 HTML 5.2 中移除了一些元素，具体为： keygen：曾经用于帮助表单生成公钥 menu 与 menuitem：曾经用于创建导航与内容菜单 新的无效实践 最后，一些开发实践方式被规定不再有效。 在 p 中不再能包含行内、浮动、块类型的子元素 在 HTML 5.2 中，p 元素中唯一合法的子元素只能是文字内容。这也意味着以下类型的元素不再能嵌套于段落标签 p 内： 行内块（Inline blocks） 行内表格（Inline tables） 浮动块与固定位置块 不再支持严格文档类型（Strict Doctypes） &amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&amp;gt; &amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&amp;gt;</summary></entry><entry><title type="html">basic-knowledge(一).md</title><link href="http://localhost:4000/js/2018/03/31/basic-knowledge-1.html" rel="alternate" type="text/html" title="basic-knowledge(一).md" /><published>2018-03-31T00:00:00+08:00</published><updated>2018-03-31T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/03/31/basic-knowledge-1</id><content type="html" xml:base="http://localhost:4000/js/2018/03/31/basic-knowledge-1.html">&lt;h1 id=&quot;项目小知识点&quot;&gt;项目小知识点&lt;/h1&gt;

&lt;p&gt;项目中用到的一些小知识点，用于记录一下：&lt;/p&gt;

&lt;p&gt;1、 数组去重&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = [1,10,4,6,10,9,8,6,10]

    // 从前向后逐个比较，相同的删除
    Array.prototype.distinct1 = function () {
        var arr = this;
        for(var i=0; i&amp;lt;arr.length; i++) {
            for(var j=i+1; j&amp;lt;arr.length; j++) {
                if(arr[i] === arr[j]) {
                    arr.splice(j,1)
                    j = ++i;
                }
            }
        }
        return arr
    }

    // 从前向后比较，不相同的push到新数组
    Array.prototype.distinct2 = function () {
        var arr = this;
        var temp = [];
        for(var i=0; i&amp;lt;arr.length; i++) {
            for(var j=i+1; j&amp;lt;arr.length; j++) {
                if(arr[i] === arr[j]) {
                    j = ++i;
                }
            }
            temp.push(arr[i])
        }
        return temp
    }

    // 利用对象属性名不能重复的特性
    Array.prototype.distinct3 = function () {
        var obj = {};
        var arr =this;
        var temp = [];
        for(var i=0; i&amp;lt;arr.length; i++) {
            if(!obj[arr[i]]) {
                temp.push(arr[i])
                obj[arr[i]] = 1;
            }
        }
        return temp
    }

    // 利用indexOf 如果无法匹配到相同的，push进新数组
    Array.prototype.distinct4 = function () {
        var arr = this;
        var temp = [];
        arr.forEach(function (item, i) {
            var num = arr.indexOf(item, i+1)
            if(num === -1) {
                temp.push(item)
            }
        })
        return temp
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">项目小知识点 项目中用到的一些小知识点，用于记录一下： 1、 数组去重 var arr = [1,10,4,6,10,9,8,6,10] // 从前向后逐个比较，相同的删除 Array.prototype.distinct1 = function () { var arr = this; for(var i=0; i&amp;lt;arr.length; i++) { for(var j=i+1; j&amp;lt;arr.length; j++) { if(arr[i] === arr[j]) { arr.splice(j,1) j = ++i; } } } return arr } // 从前向后比较，不相同的push到新数组 Array.prototype.distinct2 = function () { var arr = this; var temp = []; for(var i=0; i&amp;lt;arr.length; i++) { for(var j=i+1; j&amp;lt;arr.length; j++) { if(arr[i] === arr[j]) { j = ++i; } } temp.push(arr[i]) } return temp } // 利用对象属性名不能重复的特性 Array.prototype.distinct3 = function () { var obj = {}; var arr =this; var temp = []; for(var i=0; i&amp;lt;arr.length; i++) { if(!obj[arr[i]]) { temp.push(arr[i]) obj[arr[i]] = 1; } } return temp } // 利用indexOf 如果无法匹配到相同的，push进新数组 Array.prototype.distinct4 = function () { var arr = this; var temp = []; arr.forEach(function (item, i) { var num = arr.indexOf(item, i+1) if(num === -1) { temp.push(item) } }) return temp }</summary></entry><entry><title type="html">什么是G2?</title><link href="http://localhost:4000/2018/03/23/anvt_G2_1.html" rel="alternate" type="text/html" title="什么是G2?" /><published>2018-03-23T00:00:00+08:00</published><updated>2018-03-23T00:00:00+08:00</updated><id>http://localhost:4000/2018/03/23/anvt_G2_1</id><content type="html" xml:base="http://localhost:4000/2018/03/23/anvt_G2_1.html">&lt;h2 id=&quot;什么是g2&quot;&gt;什么是G2?&lt;/h2&gt;

&lt;p&gt;G2 是一套基于可视化编码的图形语法，以数据驱动，具有高度的易用性和扩展性，用户无需关注各种繁琐的实现细节，一条语句即可构建出各种各样的可交互的统计图表。&lt;/p&gt;

&lt;p&gt;就是这个样子：&lt;/p&gt;

&lt;h3 id=&quot;引入方法&quot;&gt;引入方法&lt;/h3&gt;

&lt;p&gt;1、直接引入&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;https://gw.alipayobjects.com/os/antv/assets/g2/3.0.5-beta.5/g2.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2、npm功安装完成之后，import 或 require 引用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install @antv/g2 --save

import G2 from '@antv/g2';

const chart = new G2.Chart({
  container: 'c1',
  width: 600,
  height: 300
});

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;如何使用&quot;&gt;如何使用？&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;创建 div 图表容器&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div id=&quot;c1&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;定制图表进行绘制
    &lt;ul&gt;
      &lt;li&gt;创建 Chart 图表对象，指定图表所在的容器 ID；&lt;/li&gt;
      &lt;li&gt;载入图表数据源；&lt;/li&gt;
      &lt;li&gt;使用图形语法进行图表的绘制；&lt;/li&gt;
      &lt;li&gt;渲染图表。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;数据源
const data = [
  { genre: 'Sports', sold: 275 },
  { genre: 'Strategy', sold: 115 },
  { genre: 'Action', sold: 120 },
  { genre: 'Shooter', sold: 350 },
  { genre: 'Other', sold: 150 }
]; // G2 对数据源格式的要求，仅仅是 JSON 数组，数组的每个元素是一个标准 JSON 对象

// Step 1: 创建 Chart 对象
const chart = new G2.Chart({
  container: 'c1', // 指定图表容器 ID
  width : 600, // 指定图表宽度
  height : 300 // 指定图表高度
});

// Step 2: 载入数据源
chart.source(data);

// Step 3：创建图形语法，绘制柱状图，由 genre 和 sold 两个属性决定图形位置，genre 映射至 x 轴，sold 映射至 y 轴
chart.interval().position('genre*sold').color('genre')

// Step 4: 渲染图表
chart.render();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;可视化框架的构成&quot;&gt;可视化框架的构成&lt;/h3&gt;

&lt;p&gt;一个可视化框架需要四部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据处理模块，对数据进行加工的模块，包括一些数据处理方法。例如：合并、分组、排序、过滤、计算统计信息等&lt;/li&gt;
  &lt;li&gt;图形映射模块，将数据映射到图形视觉通道的过程。例如：将数据映射成颜色、位置、大小等&lt;/li&gt;
  &lt;li&gt;图形展示模块，决定使用何种图形来展示数据，点、线、面等图形标记&lt;/li&gt;
  &lt;li&gt;辅助信息模块，用于说明视觉通道跟数据的映射关系，例如：坐标轴、图例、辅助文本等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数据处理模块&quot;&gt;数据处理模块&lt;/h3&gt;

&lt;p&gt;数据处理模块已经从 G2 中独立出来，作为 DataSet 模块单独提供，主要包含下面几个模块：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DataSet 包含多个 DataView, 管理多个数据源&lt;/li&gt;
  &lt;li&gt;DataView 每个 DataView 对应一个数据源，可以理解为一个图表，可以进行布局（Layout)、数据加工（Transform)&lt;/li&gt;
  &lt;li&gt;Layout 对数据进行布局&lt;/li&gt;
  &lt;li&gt;Transform 对数据进行加工、统计等处理，包括对地图数据的处理，这个很强大&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;图形映射模块&quot;&gt;图形映射模块&lt;/h3&gt;

&lt;p&gt;图形映射模块完成了将数据映射到数学空间
[0-1]，再从数学空间映射到画布空间的整个过程，主要包括三个模块：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Scale 将数据映射到 0-1 之间，方便映射到画布上&lt;/li&gt;
  &lt;li&gt;Attr 图形属性，数据映射到图形的属性（视觉通道），包括位置、颜色、大小、形状等&lt;/li&gt;
  &lt;li&gt;Coord 展示图形需用到的坐标系，将数据映射到位置的属性（视觉通道）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;辅助信息&quot;&gt;辅助信息&lt;/h3&gt;

&lt;p&gt;辅助信息用于标示数据在各种图形属性上的映射，使得用户更容易的理解数据，主要包括下面几个模块：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Axis 坐标轴，辅助用户识别图形所在的位置，判断数据大小的辅助元素&lt;/li&gt;
  &lt;li&gt;Tooltip 提示信息，用户鼠标在画布上移动时，实时出现的鼠标附近的数据信息&lt;/li&gt;
  &lt;li&gt;Guide 其他辅助元素，可以在图上添加辅助的文本、辅助图片、辅助线等，增强用户对图形的认知。&lt;/li&gt;
  &lt;li&gt;Legend 图例，辅助用户识别图形的大小、颜色、形状，通常用于判断数据对应图形的分类&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;图形展示&quot;&gt;图形展示&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Chart 图表，展示图形的入口，会生成一个画布，同时管理数据到图形映射的所有周期&lt;/li&gt;
  &lt;li&gt;View 视图，一个画布上可以显示多张图表，每个图表有各自的绘图区域、数据源、坐标系等信息&lt;/li&gt;
  &lt;li&gt;Geom 数据映射到的图形标识，G2 中的图形标识有：点、线、路径、面积、多边形等&lt;/li&gt;
  &lt;li&gt;Shape 更加细分的图形标识，例如，点可以分为圆点、正方形、十字等，线可以分为点线、折线、曲线等&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;数据处理模块之&quot;&gt;数据处理模块之&lt;/h2&gt;

&lt;p&gt;一、DataSet&lt;/p&gt;

&lt;p&gt;dataSet主要通过state状态管理多个dataview视图，实现多图联动，或者关联视图。
dataView则是对应的是每一个数据源，通过connector来接入不同类型的数据，通过tranform进行数据的转换或者过滤。最后输出我们理想的数据，dataSet是与g2分离的，需要用到的时候可以加载
在图形映射模块上，&lt;/p&gt;

&lt;p&gt;DataSet的使用语法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// step1 创建 dataset 指定状态量
const ds = new DataSet({
  state: {
    year: '2010'
  }
});

// step2 创建 DataView
const dv = ds.createView().source(data);

dv.transform({
  type: 'filter',
  callback(row) {
    return row.year === ds.state.year;
  }
});


// step3 引用 DataView
chart.source(dv);

// step4 更新状态量
ds.setState('year', '2012');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;DataSet 主要完成了以下功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;源数据的解析，将csv, dsv,geojson 转成标准的JSON，查看Connector&lt;/li&gt;
  &lt;li&gt;加工数据，包括 filter,map,fold(补数据) 等操作，查看 Transform&lt;/li&gt;
  &lt;li&gt;统计函数，汇总统计、百分比、封箱 等统计函数，查看 Transform&lt;/li&gt;
  &lt;li&gt;特殊数据处理，包括 地理数据、矩形树图、桑基图、文字云 的数据处理，查看 Transform&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（一）Connector&lt;/p&gt;

&lt;p&gt;接入语法：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dv.source(data, {
  type: connectorName,   connectorName//就是下面几种数据类型
  ...otherOptions
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可接入的数据类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;default 默认 //普通二维数据&lt;/li&gt;
  &lt;li&gt;dsv&lt;/li&gt;
  &lt;li&gt;csv&lt;/li&gt;
  &lt;li&gt;tsv&lt;/li&gt;
  &lt;li&gt;GeoJSON  //地理数据&lt;/li&gt;
  &lt;li&gt;TopoJSON //树结构数据&lt;/li&gt;
  &lt;li&gt;hierarchy&lt;/li&gt;
  &lt;li&gt;graph    //图数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以这样理解，以上几种类型，分别对应着几种实例，可以使用该种实例提供的方法，比如GeoJSON这种类型，在制作地图时需要用到的类型，以中国地图为例，传入中国的省市名称，这个类型能根据这些地名提供对应的地理位置区域，从而画出地图中对应的区域。&lt;/p&gt;

&lt;p&gt;（二）Transform&lt;/p&gt;

&lt;p&gt;功能很强大，只概括几种常见的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;过滤&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dv.transform({
  type: 'filter',
  callback(row) { // 判断某一行是否保留，默认返回true
    return row.year &amp;gt; 1998;
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;数据加工&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dv.transform({
  type: 'map',
  callback(row) { // 加工数据后返回新的一行，默认返回行数据本身
    row.newCol = row.xxx + row.yyy;
    return row;
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;字段重命名&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dv.transform({
  type: 'rename',
  map: {
    xxx: 'yyy' // row.xxx 会被替换成 row.yyy
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;数据排序&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dv.transform({
  type: 'sort',
  callback(a, b) { // 排序依据，和原生js的排序callback一致
    return a.year - b.year;
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;percent 总和百分比&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dv.transform({
  type: 'percent',
  field: 'sold',           // 统计销量
  dimension: 'year',       // 每年的占比
  groupBy: [ 'category' ], // 以不同产品类别为分组
  as: 'percent'            // 结果存储在 percent 字段
});

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;几个字段的意思：&lt;/p&gt;

&lt;p&gt;field 是统计发生的字段（求和，求百分比），
dimension 是统计的维度字段，也就是”每个不同的 dimension 下，
field 值占总和的百分比”，
groupBy 则是分组字段，每一个分组内部独立求百分比（每一个分组内，最后的 percent 字段相加之和为 1）。&lt;/p&gt;</content><author><name>weili</name></author><category term="JS" /><category term="g2" /><category term="图形化数据" /><summary type="html">什么是G2? G2 是一套基于可视化编码的图形语法，以数据驱动，具有高度的易用性和扩展性，用户无需关注各种繁琐的实现细节，一条语句即可构建出各种各样的可交互的统计图表。 就是这个样子： 引入方法 1、直接引入 &amp;lt;script src=&quot;https://gw.alipayobjects.com/os/antv/assets/g2/3.0.5-beta.5/g2.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; 2、npm功安装完成之后，import 或 require 引用 npm install @antv/g2 --save import G2 from '@antv/g2'; const chart = new G2.Chart({ container: 'c1', width: 600, height: 300 }); 如何使用？ 创建 div 图表容器 &amp;lt;div id=&quot;c1&quot;&amp;gt;&amp;lt;/div&amp;gt; 定制图表进行绘制 创建 Chart 图表对象，指定图表所在的容器 ID； 载入图表数据源； 使用图形语法进行图表的绘制； 渲染图表。 数据源 const data = [ { genre: 'Sports', sold: 275 }, { genre: 'Strategy', sold: 115 }, { genre: 'Action', sold: 120 }, { genre: 'Shooter', sold: 350 }, { genre: 'Other', sold: 150 } ]; // G2 对数据源格式的要求，仅仅是 JSON 数组，数组的每个元素是一个标准 JSON 对象 // Step 1: 创建 Chart 对象 const chart = new G2.Chart({ container: 'c1', // 指定图表容器 ID width : 600, // 指定图表宽度 height : 300 // 指定图表高度 }); // Step 2: 载入数据源 chart.source(data); // Step 3：创建图形语法，绘制柱状图，由 genre 和 sold 两个属性决定图形位置，genre 映射至 x 轴，sold 映射至 y 轴 chart.interval().position('genre*sold').color('genre') // Step 4: 渲染图表 chart.render(); 可视化框架的构成 一个可视化框架需要四部分： 数据处理模块，对数据进行加工的模块，包括一些数据处理方法。例如：合并、分组、排序、过滤、计算统计信息等 图形映射模块，将数据映射到图形视觉通道的过程。例如：将数据映射成颜色、位置、大小等 图形展示模块，决定使用何种图形来展示数据，点、线、面等图形标记 辅助信息模块，用于说明视觉通道跟数据的映射关系，例如：坐标轴、图例、辅助文本等 数据处理模块 数据处理模块已经从 G2 中独立出来，作为 DataSet 模块单独提供，主要包含下面几个模块： DataSet 包含多个 DataView, 管理多个数据源 DataView 每个 DataView 对应一个数据源，可以理解为一个图表，可以进行布局（Layout)、数据加工（Transform) Layout 对数据进行布局 Transform 对数据进行加工、统计等处理，包括对地图数据的处理，这个很强大 图形映射模块 图形映射模块完成了将数据映射到数学空间 [0-1]，再从数学空间映射到画布空间的整个过程，主要包括三个模块： Scale 将数据映射到 0-1 之间，方便映射到画布上 Attr 图形属性，数据映射到图形的属性（视觉通道），包括位置、颜色、大小、形状等 Coord 展示图形需用到的坐标系，将数据映射到位置的属性（视觉通道） 辅助信息 辅助信息用于标示数据在各种图形属性上的映射，使得用户更容易的理解数据，主要包括下面几个模块： Axis 坐标轴，辅助用户识别图形所在的位置，判断数据大小的辅助元素 Tooltip 提示信息，用户鼠标在画布上移动时，实时出现的鼠标附近的数据信息 Guide 其他辅助元素，可以在图上添加辅助的文本、辅助图片、辅助线等，增强用户对图形的认知。 Legend 图例，辅助用户识别图形的大小、颜色、形状，通常用于判断数据对应图形的分类 图形展示 Chart 图表，展示图形的入口，会生成一个画布，同时管理数据到图形映射的所有周期 View 视图，一个画布上可以显示多张图表，每个图表有各自的绘图区域、数据源、坐标系等信息 Geom 数据映射到的图形标识，G2 中的图形标识有：点、线、路径、面积、多边形等 Shape 更加细分的图形标识，例如，点可以分为圆点、正方形、十字等，线可以分为点线、折线、曲线等 数据处理模块之 一、DataSet dataSet主要通过state状态管理多个dataview视图，实现多图联动，或者关联视图。 dataView则是对应的是每一个数据源，通过connector来接入不同类型的数据，通过tranform进行数据的转换或者过滤。最后输出我们理想的数据，dataSet是与g2分离的，需要用到的时候可以加载 在图形映射模块上， DataSet的使用语法 // step1 创建 dataset 指定状态量 const ds = new DataSet({ state: { year: '2010' } }); // step2 创建 DataView const dv = ds.createView().source(data); dv.transform({ type: 'filter', callback(row) { return row.year === ds.state.year; } }); // step3 引用 DataView chart.source(dv); // step4 更新状态量 ds.setState('year', '2012'); DataSet 主要完成了以下功能： 源数据的解析，将csv, dsv,geojson 转成标准的JSON，查看Connector 加工数据，包括 filter,map,fold(补数据) 等操作，查看 Transform 统计函数，汇总统计、百分比、封箱 等统计函数，查看 Transform 特殊数据处理，包括 地理数据、矩形树图、桑基图、文字云 的数据处理，查看 Transform （一）Connector 接入语法： dv.source(data, { type: connectorName, connectorName//就是下面几种数据类型 ...otherOptions }); 可接入的数据类型： default 默认 //普通二维数据 dsv csv tsv GeoJSON //地理数据 TopoJSON //树结构数据 hierarchy graph //图数据 可以这样理解，以上几种类型，分别对应着几种实例，可以使用该种实例提供的方法，比如GeoJSON这种类型，在制作地图时需要用到的类型，以中国地图为例，传入中国的省市名称，这个类型能根据这些地名提供对应的地理位置区域，从而画出地图中对应的区域。 （二）Transform 功能很强大，只概括几种常见的： 过滤 dv.transform({ type: 'filter', callback(row) { // 判断某一行是否保留，默认返回true return row.year &amp;gt; 1998; } }); 数据加工 dv.transform({ type: 'map', callback(row) { // 加工数据后返回新的一行，默认返回行数据本身 row.newCol = row.xxx + row.yyy; return row; } }); 字段重命名 dv.transform({ type: 'rename', map: { xxx: 'yyy' // row.xxx 会被替换成 row.yyy } }); 数据排序 dv.transform({ type: 'sort', callback(a, b) { // 排序依据，和原生js的排序callback一致 return a.year - b.year; } }); percent 总和百分比 dv.transform({ type: 'percent', field: 'sold', // 统计销量 dimension: 'year', // 每年的占比 groupBy: [ 'category' ], // 以不同产品类别为分组 as: 'percent' // 结果存储在 percent 字段 }); 几个字段的意思： field 是统计发生的字段（求和，求百分比）， dimension 是统计的维度字段，也就是”每个不同的 dimension 下， field 值占总和的百分比”， groupBy 则是分组字段，每一个分组内部独立求百分比（每一个分组内，最后的 percent 字段相加之和为 1）。</summary></entry><entry><title type="html">JS基础–高级算法–贪心算法</title><link href="http://localhost:4000/js/2018/03/16/AdvancedAlgorithms-2.html" rel="alternate" type="text/html" title="JS基础--高级算法--贪心算法" /><published>2018-03-16T00:00:00+08:00</published><updated>2018-03-16T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/03/16/AdvancedAlgorithms-2</id><content type="html" xml:base="http://localhost:4000/js/2018/03/16/AdvancedAlgorithms-2.html">&lt;h1 id=&quot;高级算法贪心算法&quot;&gt;高级算法–贪心算法&lt;/h1&gt;

&lt;p&gt;贪心算法总是会选择当下的最优解，而不去考虑这一次的选择会不会对未来的选择造成影响，目的是得到当前最优解。&lt;/p&gt;

&lt;h2 id=&quot;使用贪心算法的经典案例&quot;&gt;使用贪心算法的经典案例&lt;/h2&gt;

&lt;h3 id=&quot;找零问题&quot;&gt;找零问题&lt;/h3&gt;

&lt;p&gt;从商店购买了一些商品，找零 63 美分，店员要 怎样给你这些零钱呢?如果店员根据贪心算法来找零的话，他会给你两个 25 美分、一个 10 美分和三个 1 美分。在没有使用 50 美分的情况下这是最少的硬币数量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function makeChange(origAmt, coins) {
    var remainAmt = 0;

    if (origAmt % .25 &amp;lt; origAmt) {
       coins[3] = parseInt(origAmt / .25);
       remainAmt = origAmt % .25;
       origAmt = remainAmt;
    }

    if (origAmt % .1 &amp;lt; origAmt) {
       coins[2] = parseInt(origAmt / .1);
       remainAmt = origAmt % .1;
       origAmt = remainAmt;
    }

    if (origAmt % .05 &amp;lt; origAmt) {
       coins[1] = parseInt(origAmt / .05);
       remainAmt = origAmt % .05;
       origAmt = remainAmt;
    }

    coins[0] = parseInt(origAmt / .01);
}


function showChange(coins) {
    if (coins[3] &amp;gt; 0) {
        document.write(&quot;25 美分的数量 - &quot; + coins[3] + &quot; - &quot; + coins[3] * .25); 
    }

    if (coins[2] &amp;gt; 0) {
        document.write(&quot;10 美分的数量 - &quot; + coins[2] + &quot; - &quot; + coins[2] * .10);
    }

    if (coins[1] &amp;gt; 0) {
        document.write(&quot;5 美分的数量 - &quot; + coins[1] + &quot; - &quot; + coins[1] * .05);
    }

    if (coins[0] &amp;gt; 0) {
        document.write(&quot;1 美分的数量 - &quot; + coins[0] + &quot; - &quot; + coins[0] * .01);
    } 
}

var origAmt = .63;
var coins = [];
makeChange(origAmt, coins);
showChange(coins);

========================
结果如下：

25美分的数量 - 2 - 0.5 
10美分的数量 - 1 - 0.1 
1美分的数量 - 3 - 0.03
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;makeChange() 函数从面值最高的 25 美分硬币开始，一直尝试使用这个面值去找零。总共 用到的 25 美分硬币数量会存储在 coins 数组中。如果剩余金额不到 25 美分，算法将会尝 试使用 10 美分硬币去找零，用到的 10 美分硬币总总数也会存储在 coins 数组里。接下来 算法会以相同的方式使用 5 美分和 1 美分来找零。&lt;/p&gt;

&lt;p&gt;在所有面额都可用且数量不限的情况下，这种方案总能找到最优解。如果某种面额不可用，比如 5 美分，则会得到一个次优解。&lt;/p&gt;

&lt;h3 id=&quot;背包问题之贪心算法解决方案&quot;&gt;背包问题之贪心算法解决方案&lt;/h3&gt;

&lt;p&gt;如果用贪心算法处理背包问题，它有一个前提放入背包的物品从本质上说是连续的，那 么可以简单地通过物品的单价除以单位体积来确定物品的价值，先装价值最高的物品直到该物品装完或者将背包装满，接着装价值次高的物品，直到 这种物品也装完或将背包装满，以此类推。&lt;/p&gt;

&lt;p&gt;思路是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(1) 背包的容量为 W，物品的价格为 v，重量为 w。&lt;/li&gt;
  &lt;li&gt;(2) 根据 v/w 的比率对物品排序。&lt;/li&gt;
  &lt;li&gt;(3) 按比率的降序方式来考虑物品。&lt;/li&gt;
  &lt;li&gt;(4) 尽可能多地放入每个物品。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如给出了四个物品的重量、价格和比率&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;物品&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;A&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;B&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
      &lt;th&gt;D&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;价格&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;50&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;140&lt;/td&gt;
      &lt;td&gt;60&lt;/td&gt;
      &lt;td&gt;60&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;尺寸&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;20&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;比率&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;7&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function ksack(values, weights, capacity) {
    var load = 0;
    var i = 0;
    var w = 0;
    while (load &amp;lt; capacity &amp;amp;&amp;amp; i &amp;lt; 4) {
       if (weights[i] &amp;lt;= (capacity-load)) {
          w += values[i];
          load += weights[i];
       } else {
       
          var r = (capacity-load)/weights[i];
          w += r * values[i];
          load += weights[i];
       } 
       ++i;
    }
    return w;
}

var items = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;];
var values = [50, 140, 60, 60];
var weights = [5, 20, 10, 12];
var capacity = 30;

document.write(ksack(values, weights, capacity)); // 显示 220
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">高级算法–贪心算法 贪心算法总是会选择当下的最优解，而不去考虑这一次的选择会不会对未来的选择造成影响，目的是得到当前最优解。 使用贪心算法的经典案例 找零问题 从商店购买了一些商品，找零 63 美分，店员要 怎样给你这些零钱呢?如果店员根据贪心算法来找零的话，他会给你两个 25 美分、一个 10 美分和三个 1 美分。在没有使用 50 美分的情况下这是最少的硬币数量。 function makeChange(origAmt, coins) { var remainAmt = 0; if (origAmt % .25 &amp;lt; origAmt) { coins[3] = parseInt(origAmt / .25); remainAmt = origAmt % .25; origAmt = remainAmt; } if (origAmt % .1 &amp;lt; origAmt) { coins[2] = parseInt(origAmt / .1); remainAmt = origAmt % .1; origAmt = remainAmt; } if (origAmt % .05 &amp;lt; origAmt) { coins[1] = parseInt(origAmt / .05); remainAmt = origAmt % .05; origAmt = remainAmt; } coins[0] = parseInt(origAmt / .01); } function showChange(coins) { if (coins[3] &amp;gt; 0) { document.write(&quot;25 美分的数量 - &quot; + coins[3] + &quot; - &quot; + coins[3] * .25); } if (coins[2] &amp;gt; 0) { document.write(&quot;10 美分的数量 - &quot; + coins[2] + &quot; - &quot; + coins[2] * .10); } if (coins[1] &amp;gt; 0) { document.write(&quot;5 美分的数量 - &quot; + coins[1] + &quot; - &quot; + coins[1] * .05); } if (coins[0] &amp;gt; 0) { document.write(&quot;1 美分的数量 - &quot; + coins[0] + &quot; - &quot; + coins[0] * .01); } } var origAmt = .63; var coins = []; makeChange(origAmt, coins); showChange(coins); ======================== 结果如下： 25美分的数量 - 2 - 0.5 10美分的数量 - 1 - 0.1 1美分的数量 - 3 - 0.03 makeChange() 函数从面值最高的 25 美分硬币开始，一直尝试使用这个面值去找零。总共 用到的 25 美分硬币数量会存储在 coins 数组中。如果剩余金额不到 25 美分，算法将会尝 试使用 10 美分硬币去找零，用到的 10 美分硬币总总数也会存储在 coins 数组里。接下来 算法会以相同的方式使用 5 美分和 1 美分来找零。 在所有面额都可用且数量不限的情况下，这种方案总能找到最优解。如果某种面额不可用，比如 5 美分，则会得到一个次优解。 背包问题之贪心算法解决方案 如果用贪心算法处理背包问题，它有一个前提放入背包的物品从本质上说是连续的，那 么可以简单地通过物品的单价除以单位体积来确定物品的价值，先装价值最高的物品直到该物品装完或者将背包装满，接着装价值次高的物品，直到 这种物品也装完或将背包装满，以此类推。 思路是 (1) 背包的容量为 W，物品的价格为 v，重量为 w。 (2) 根据 v/w 的比率对物品排序。 (3) 按比率的降序方式来考虑物品。 (4) 尽可能多地放入每个物品。 如给出了四个物品的重量、价格和比率 物品 A B C D 价格 50 140 60 60 尺寸 5 20 10 12 比率 10 7 6 5 function ksack(values, weights, capacity) { var load = 0; var i = 0; var w = 0; while (load &amp;lt; capacity &amp;amp;&amp;amp; i &amp;lt; 4) { if (weights[i] &amp;lt;= (capacity-load)) { w += values[i]; load += weights[i]; } else { var r = (capacity-load)/weights[i]; w += r * values[i]; load += weights[i]; } ++i; } return w; } var items = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]; var values = [50, 140, 60, 60]; var weights = [5, 20, 10, 12]; var capacity = 30; document.write(ksack(values, weights, capacity)); // 显示 220</summary></entry><entry><title type="html">JS基础–高级算法–动态规划</title><link href="http://localhost:4000/js/2018/03/09/AdvancedAlgorithms-1.html" rel="alternate" type="text/html" title="JS基础--高级算法--动态规划" /><published>2018-03-09T00:00:00+08:00</published><updated>2018-03-09T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/03/09/AdvancedAlgorithms-1</id><content type="html" xml:base="http://localhost:4000/js/2018/03/09/AdvancedAlgorithms-1.html">&lt;h1 id=&quot;高级算法动态规划&quot;&gt;高级算法–动态规划&lt;/h1&gt;

&lt;h2 id=&quot;动态规则与递归的关系与区别&quot;&gt;动态规则与递归的关系与区别&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;动态规划有时被认为是一种与递归相反的技术。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整 个问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个 整体解决方案，从而解决掉整个大问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;递归去解决问题虽然简洁，但效率不高,许多使用递归去解决的编程问题，可以重写为使用动态规划的技巧去解决&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;动态规划方案&quot;&gt;动态规划方案&lt;/h2&gt;

&lt;p&gt;动态规划方案通常会使用一个数组来建立一张表，用于存放被分解成众多子问题的解。当算法执行完 毕，最终的解将会在这个表中很明显的地方被找到&lt;/p&gt;

&lt;h2 id=&quot;使用动态规划方案能做点什么&quot;&gt;使用动态规划方案能做点什么？&lt;/h2&gt;

&lt;h3 id=&quot;计算斐波那契数列&quot;&gt;计算斐波那契数列&lt;/h3&gt;

&lt;p&gt;斐波那契数列可以定义为以下序列:&lt;/p&gt;

&lt;p&gt;0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …&lt;/p&gt;

&lt;p&gt;该序列是由前两项数值相加而成的&lt;/p&gt;

&lt;p&gt;递归的实现方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function recurFib(n) {
    if (n &amp;lt; 2) {
        return n; 
    } else {
        
        return recurFib(n-1) + recurFib(n-2);
    } 
}
document.write(recurFib(10)); // 显示 55
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个计算过程当中，有太多值在递归调用中被重新计算,这也是递归方法效率低下的原因。&lt;/p&gt;

&lt;p&gt;再看下动态规则的实现方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function dynFib(n) {
    var val = [];
    for (var i = 0; i &amp;lt;= n; ++i) {
        val[i] = 0; 
    }
    if (n == 1 || n == 2) {
        return 1;
    } else {
        val[1] = 1;
        val[2] = 2;
        for (var i = 3; i &amp;lt;= n; ++i) {
            val[i] = val[i-1] + val[i-2];
        }
        return val[n-1];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个数组 val 中保存了中间结果。如果要计算的斐波那契数是 1 或者 2，那么 if 语 句会返回 1。否则，数值 1 和 2 将被保存在 val 数组中 1 和 2 的位置。循环将会从 3 到输 入的参数之间进行遍历，将数组的每个元素赋值为前两个元素之和，循环结束，数组的最 后一个元素值即为最终计算得到的斐波那契数值，这个数值也将作为函数的返回值。&lt;/p&gt;

&lt;p&gt;斐波那契数列在数组 val 中的排列顺序如下:&lt;/p&gt;

&lt;p&gt;val[0] = 0 val[1] = 1 val[2] = 2 val[3] = 3 val[4] = 5 val[5] = 8 val[6] = 13&lt;/p&gt;

&lt;h3 id=&quot;寻找最长公共子串&quot;&gt;寻找最长公共子串&lt;/h3&gt;

&lt;p&gt;用动态规划去寻找两个字符串的最长公共子串。例如，在单词 “raven”和“havoc”中，最长的公共子串是“av”。&lt;/p&gt;

&lt;p&gt;原理：&lt;/p&gt;

&lt;p&gt;使用一个二维数组存储两个字符串相同 位置的字符比较结果。初始化时，该数组的每一个元素被设置为 0。每次在这两个数组的 相同位置发现了匹配，就将数组对应行和列的元素加 1，否则保持为 0。按照这种方式，一个变量会持续记录下找到了多少个匹配项。当算法执行完毕时，这个变 量会结合一个索引变量来获得最长公共子串。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function lcs(word1, word2) {
     var max = 0;
     var index = 0;
     var lcsarr = new Array(word1.length + 1);
     for (var i = 0; i &amp;lt;= word1.length + 1; ++i) {
         lcsarr[i] = new Array(word2.length + 1);
         for (var j = 0; j &amp;lt;= word2.length + 1; ++j) {
            lcsarr[i][j] = 0;
        }
    }

    //上面这一部分初始化了两个变量以及一个二维数组。多数语言对二维数组的声明都很 简单，但在 JavaScript 中需要很费劲地在一个数组中定义另一个数组，这样才能声明一个 二维数组。以下代码片段中的最后一个 for 循环会对这个数组进行初始化，


    for (var i = 0; i &amp;lt;= word1.length; ++i) {
       for (var j = 0; j &amp;lt;= word2.length; ++j) {
          if (i == 0 || j == 0) {
             lcsarr[i][j] = 0;
          } else {
              if (word1[i - 1] == word2[j - 1]) {
                lcsarr[i][j] = lcsarr[i - 1][j - 1] + 1;
              } else {
                lcsarr[i][j] = 0;
              } 
          }
          if (max &amp;lt; lcsarr[i][j]) {
             max = lcsarr[i][j];
             index = i;
          } 
        }
    }

    //这一部分构建了用于保存字符匹配记录的表。数组的第一个元素总是被设置为 0。如果两 个字符串相应位置的字符进行了匹配，当前数组元素的值将被设置为前一次循环中数组元 素保存的值加 1。比如，如果两个字符串 &quot;back&quot; 和 &quot;cace&quot;，当算法运行到第二个字符处 时，那么数值 1 将被保存到当前元素中，因为前一个元素并不匹配，0 被保存在那个元素 中(0+1)。接下来算法移动到下一个位置，由于此时两个字符仍被匹配，当前数组元素将 被设置为 2(1+1)。由于两个字符串的最后一个字符不匹配，所以最长公共子串的长度是 2。最后，如果变量 max 的值比现在存储在数组中的当前元素要小，max 的值将被赋值给这 个元素，变量 index 的值将被设置为 i 的当前值。这两个变量将在函数的最后一部分用于 确定从哪里开始获取最长公共子串。

    var str = &quot;&quot;;
    if (max == 0) {
       return &quot;&quot;;
    } else {
        for (var i = index - max; i &amp;lt;= max; ++i) {
          str += word2[i];
        }
        return str; 
    }

    //这一部分代码用于确认从哪里开始构建这个最长公共子串。以变量 index 减去变量 max 的差值作为起始点，以变量 max 的值作为终点:
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;背包问题递归解决方案&quot;&gt;背包问题:递归解决方案&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function max(a, b) {
    return (a &amp;gt; b) ? a : b;
}

function knapsack(capacity, size, value, n) {
    if (n == 0 || capacity == 0) {
        return 0; 
    }
    if (size[n - 1] &amp;gt; capacity) {
       return knapsack(capacity, size, value, n - 1);
    } else {
       return max(value[n - 1] +
          knapsack(capacity - size[n - 1], size, value, n - 1),
          knapsack(capacity, size, value, n - 1));
    } 
}

var value = [4, 5, 10, 11, 13];
var size = [3, 4, 7, 8, 9];
var capacity = 16;
var n = 5;
document.write(knapsack(capacity, size, value, n));

//结果：23
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;背包问题动态规划方案&quot;&gt;背包问题:动态规划方案&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function max(a, b) {
    return (a &amp;gt; b) ? a : b;
}
function dKnapsack(capacity, size, value, n) {
  var K = [];
  for (var i = 0; i &amp;lt;= capacity + 1; i++) {
      K[i] = [];
  }
  for (var i = 0; i &amp;lt;= n; i++) {
     for (var w = 0; w &amp;lt;= capacity; w++) {
        if (i == 0 || w == 0) {
            K[i][w] = 0; 
        } else if (size[i - 1] &amp;lt;= w) {
           K[i][w] = max(value[i - 1] + K[i-1][w-size[i-1]], K[i-1][w]);
        } else {
           K[i][w] = K[i - 1][w];
        }
        document.write(K[i][w] + &quot; &quot;);
     }
  }
  return K[n][capacity];
}
var value = [4, 5, 10, 11, 13];
var size = [3, 4, 7, 8, 9];
var capacity = 16;
var n = 5;
document.write(dKnapsack(capacity, size, value, n));

结果：

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 
0 0 0 4 5 5 5 9 9 9 9 9 9 9 9 9 9
0 0 0 4 5 5 5 10 10 10 14 15 15 15 19 19 19 
0 0 0 4 5 5 5 10 11 11 14 15 16 16 19 21 21 
0 0 0 4 5 5 5 10 11 13 14 15 17 18 19 21 23 
23
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">高级算法–动态规划 动态规则与递归的关系与区别 动态规划有时被认为是一种与递归相反的技术。 递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整 个问题。 动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个 整体解决方案，从而解决掉整个大问题。 递归去解决问题虽然简洁，但效率不高,许多使用递归去解决的编程问题，可以重写为使用动态规划的技巧去解决 动态规划方案 动态规划方案通常会使用一个数组来建立一张表，用于存放被分解成众多子问题的解。当算法执行完 毕，最终的解将会在这个表中很明显的地方被找到 使用动态规划方案能做点什么？ 计算斐波那契数列 斐波那契数列可以定义为以下序列: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, … 该序列是由前两项数值相加而成的 递归的实现方式： function recurFib(n) { if (n &amp;lt; 2) { return n; } else { return recurFib(n-1) + recurFib(n-2); } } document.write(recurFib(10)); // 显示 55 在这个计算过程当中，有太多值在递归调用中被重新计算,这也是递归方法效率低下的原因。 再看下动态规则的实现方法： function dynFib(n) { var val = []; for (var i = 0; i &amp;lt;= n; ++i) { val[i] = 0; } if (n == 1 || n == 2) { return 1; } else { val[1] = 1; val[2] = 2; for (var i = 3; i &amp;lt;= n; ++i) { val[i] = val[i-1] + val[i-2]; } return val[n-1]; } } 在这个数组 val 中保存了中间结果。如果要计算的斐波那契数是 1 或者 2，那么 if 语 句会返回 1。否则，数值 1 和 2 将被保存在 val 数组中 1 和 2 的位置。循环将会从 3 到输 入的参数之间进行遍历，将数组的每个元素赋值为前两个元素之和，循环结束，数组的最 后一个元素值即为最终计算得到的斐波那契数值，这个数值也将作为函数的返回值。 斐波那契数列在数组 val 中的排列顺序如下: val[0] = 0 val[1] = 1 val[2] = 2 val[3] = 3 val[4] = 5 val[5] = 8 val[6] = 13 寻找最长公共子串 用动态规划去寻找两个字符串的最长公共子串。例如，在单词 “raven”和“havoc”中，最长的公共子串是“av”。 原理： 使用一个二维数组存储两个字符串相同 位置的字符比较结果。初始化时，该数组的每一个元素被设置为 0。每次在这两个数组的 相同位置发现了匹配，就将数组对应行和列的元素加 1，否则保持为 0。按照这种方式，一个变量会持续记录下找到了多少个匹配项。当算法执行完毕时，这个变 量会结合一个索引变量来获得最长公共子串。 function lcs(word1, word2) { var max = 0; var index = 0; var lcsarr = new Array(word1.length + 1); for (var i = 0; i &amp;lt;= word1.length + 1; ++i) { lcsarr[i] = new Array(word2.length + 1); for (var j = 0; j &amp;lt;= word2.length + 1; ++j) { lcsarr[i][j] = 0; } } //上面这一部分初始化了两个变量以及一个二维数组。多数语言对二维数组的声明都很 简单，但在 JavaScript 中需要很费劲地在一个数组中定义另一个数组，这样才能声明一个 二维数组。以下代码片段中的最后一个 for 循环会对这个数组进行初始化， for (var i = 0; i &amp;lt;= word1.length; ++i) { for (var j = 0; j &amp;lt;= word2.length; ++j) { if (i == 0 || j == 0) { lcsarr[i][j] = 0; } else { if (word1[i - 1] == word2[j - 1]) { lcsarr[i][j] = lcsarr[i - 1][j - 1] + 1; } else { lcsarr[i][j] = 0; } } if (max &amp;lt; lcsarr[i][j]) { max = lcsarr[i][j]; index = i; } } } //这一部分构建了用于保存字符匹配记录的表。数组的第一个元素总是被设置为 0。如果两 个字符串相应位置的字符进行了匹配，当前数组元素的值将被设置为前一次循环中数组元 素保存的值加 1。比如，如果两个字符串 &quot;back&quot; 和 &quot;cace&quot;，当算法运行到第二个字符处 时，那么数值 1 将被保存到当前元素中，因为前一个元素并不匹配，0 被保存在那个元素 中(0+1)。接下来算法移动到下一个位置，由于此时两个字符仍被匹配，当前数组元素将 被设置为 2(1+1)。由于两个字符串的最后一个字符不匹配，所以最长公共子串的长度是 2。最后，如果变量 max 的值比现在存储在数组中的当前元素要小，max 的值将被赋值给这 个元素，变量 index 的值将被设置为 i 的当前值。这两个变量将在函数的最后一部分用于 确定从哪里开始获取最长公共子串。 var str = &quot;&quot;; if (max == 0) { return &quot;&quot;; } else { for (var i = index - max; i &amp;lt;= max; ++i) { str += word2[i]; } return str; } //这一部分代码用于确认从哪里开始构建这个最长公共子串。以变量 index 减去变量 max 的差值作为起始点，以变量 max 的值作为终点: } 背包问题:递归解决方案 function max(a, b) { return (a &amp;gt; b) ? a : b; } function knapsack(capacity, size, value, n) { if (n == 0 || capacity == 0) { return 0; } if (size[n - 1] &amp;gt; capacity) { return knapsack(capacity, size, value, n - 1); } else { return max(value[n - 1] + knapsack(capacity - size[n - 1], size, value, n - 1), knapsack(capacity, size, value, n - 1)); } } var value = [4, 5, 10, 11, 13]; var size = [3, 4, 7, 8, 9]; var capacity = 16; var n = 5; document.write(knapsack(capacity, size, value, n)); //结果：23 背包问题:动态规划方案 function max(a, b) { return (a &amp;gt; b) ? a : b; } function dKnapsack(capacity, size, value, n) { var K = []; for (var i = 0; i &amp;lt;= capacity + 1; i++) { K[i] = []; } for (var i = 0; i &amp;lt;= n; i++) { for (var w = 0; w &amp;lt;= capacity; w++) { if (i == 0 || w == 0) { K[i][w] = 0; } else if (size[i - 1] &amp;lt;= w) { K[i][w] = max(value[i - 1] + K[i-1][w-size[i-1]], K[i-1][w]); } else { K[i][w] = K[i - 1][w]; } document.write(K[i][w] + &quot; &quot;); } } return K[n][capacity]; } var value = [4, 5, 10, 11, 13]; var size = [3, 4, 7, 8, 9]; var capacity = 16; var n = 5; document.write(dKnapsack(capacity, size, value, n)); 结果： 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 4 4 4 4 4 4 4 4 4 4 4 4 4 0 0 0 4 5 5 5 9 9 9 9 9 9 9 9 9 9 0 0 0 4 5 5 5 10 10 10 14 15 15 15 19 19 19 0 0 0 4 5 5 5 10 11 11 14 15 16 16 19 21 21 0 0 0 4 5 5 5 10 11 13 14 15 17 18 19 21 23 23</summary></entry><entry><title type="html">JS基础–检索算法</title><link href="http://localhost:4000/js/2018/03/02/jiansuo-1.html" rel="alternate" type="text/html" title="JS基础--检索算法" /><published>2018-03-02T00:00:00+08:00</published><updated>2018-03-02T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/03/02/jiansuo-1</id><content type="html" xml:base="http://localhost:4000/js/2018/03/02/jiansuo-1.html">&lt;h1 id=&quot;检索算法&quot;&gt;检索算法&lt;/h1&gt;

&lt;p&gt;本章介绍了数据检索的一个方面: 如何在列表中查找特定的值。&lt;/p&gt;

&lt;p&gt;在列表中查找数据有两种方式: &lt;strong&gt;顺序查找&lt;/strong&gt;和&lt;strong&gt;二分查找&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;顺序查找适用于元素随机排列的列表;&lt;/li&gt;
  &lt;li&gt;二分查找适用于元素已排序的列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;二分查找效率更高，但是你必须在进行查找之前 花费额外的时间将列表中的元素排序。&lt;/p&gt;

&lt;h2 id=&quot;顺序查找&quot;&gt;顺序查找&lt;/h2&gt;

&lt;p&gt;对于查找数据来说，最简单的方法就是从列表的第一个元素开始对列表元素逐个进行判 断，直到找到了想要的结果，或者直到列表结尾也没有找到。这种方法称为顺序查找，有 时也被称为线性查找。它属于暴力查找技巧的一种，在执行查找时可能会访问到数据结构 里的所有元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;顺序查找的实现：&lt;/strong&gt;
只要从列表的第一个元素开始循环，然后逐个与要查找的数据进 行比较。如果匹配到了，则结束查找。如果到了列表的结尾也没有匹配到，那么这个数据 就不存在于这个列表中。&lt;/p&gt;

&lt;p&gt;代码实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function seqSearch(arr, data) {
    for (var i = 0; i &amp;lt; arr.length; ++i) {
        if (arr[i] == data) {
            return i;
        }
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果在数组中找到了参数 data，返回所在的位置，如果没有找到要查找的数据，函数返回-1。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;seqSearch() 函数的执行速度比内置的 Array.indexof() 方法慢，这里仅用来演示 顺序查找是如何运行的。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;查找最小值和最大值&quot;&gt;查找最小值和最大值&lt;/h3&gt;

&lt;h4 id=&quot;查找最小值&quot;&gt;查找最小值&lt;/h4&gt;

&lt;p&gt;首先看看如何在数组中查找最小值，算法如下。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将数组第一个元素赋值给一个变量，把这个变量作为最小值。&lt;/li&gt;
  &lt;li&gt;开始遍历数组，从第二个元素开始依次同当前最小值进行比较。&lt;/li&gt;
  &lt;li&gt;如果当前元素数值小于当前最小值，则将当前元素设为新的最小值。&lt;/li&gt;
  &lt;li&gt;移动到下一个元素，并且重复步骤 3。&lt;/li&gt;
  &lt;li&gt;当程序结束时，这个变量中存储的就是最小值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码实现如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function findMin(arr) {
  var min = arr[0];
  for (var i = 1; i &amp;lt; arr.length; ++i) {
     if (arr[i] &amp;lt; min) {
        min = arr[i];
     } 
  }
  return min; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的关键部分，由于我们假设数组的第一个元素就是当前的最小值，所以这个函数 会从数组的第二个元素开始进行处理。&lt;/p&gt;

&lt;h4 id=&quot;查找最大值&quot;&gt;查找最大值&lt;/h4&gt;

&lt;p&gt;查找最大值和查找最小值的原理是一样的，只不过是先把数组的第一个元素设置为最大值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function findMax(arr) {
    var max = arr[0];
    for (var i = 1; i &amp;lt; arr.length; ++i) {
       if (arr[i] &amp;gt; max) {
          max = arr[i];
       } 
    }
    return max; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实例化个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var nums = [];
for (var i = 0; i &amp;lt; 100; ++i) {
  nums[i] = Math.floor(Math.random() * 101);
}

document.getElementById('box').innerHTML = nums;

var minValue = this.findMin(nums); 
var maxValue = this.findMax(nums); 

document.write(&quot;最小值是:&quot; + minValue + '&amp;lt;br /&amp;gt;');
document.write(&quot;最小值是:&quot; + maxValue);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://127.0.0.1:4000/img/20180222/20180222-1.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用自组织数据&quot;&gt;使用自组织数据&lt;/h3&gt;

&lt;p&gt;对于未排序的数据集来说，当被查找的数据位于数据集的起始位置时，查找是最快、最成功的。通过将成功找到的元素置于数据集的起始位置，可以保证在以后的操作中该元素能被更快地查找到。&lt;/p&gt;

&lt;p&gt;通过将频繁查找到的元素置于数据集的起始位置来最小化查找次数，这就叫做自组织数据。&lt;/p&gt;

&lt;p&gt;由于对数据的查找遵循“80-20 原则”，因此将你的数据转化为自组织的形式是很有意义 的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“80-20 原则”是指对某一数据集执行的 80% 的查找操作都是对其中 20% 的数据元素 进行查找。自组织的方式最终会把这 20% 的数据置于数据集的起始位置，这样便可以通过 一个简单的顺序查找快速找到它们。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举个例子，理解对 seqSearch() 函数进行改动以加入自组织方式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numbers = [5,1,7,4,2,10,9,3,6,8];

//改动后的seqSearch() 函数
function seqSearch(arr,data) {
    for(var i = 0; i &amp;lt; arr.length; ++i) {
        if(arr[i] === data) {
            if( i &amp;gt; 0) {
                swap(arr,i,i-1);
            }
            return true;
        }
    }
    return false;
}
 
//swap() 函数来对这次找到的数据与当前存储在上一个位置的数据进行互换。
function swap(arr,index,index1) {
    temp = arr[index];
    arr[index] = arr[index1];
    arr[index1] = temp;
}

for (var i = 0; i &amp;lt;= 5; i++) {
  seqSearch(numbers, 4);
  console.log(numbers);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://127.0.0.1:4000/img/20180222/20180222-2.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种写法同时可以保证已经在数据集前面的元素不会被越移越远。&lt;/p&gt;

&lt;h2 id=&quot;二分查找&quot;&gt;二分查找&lt;/h2&gt;

&lt;p&gt;如果你要查找的数据是有序的，二分查找算法比顺序查找算法更高效。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var nums = [0,5,46,85,102,212,503];  //必须先排序好
 
function binSearch(arr,data) {
    var upperBound = arr.length - 1;
        lowerBound = 0;
    while(lowerBound &amp;lt;= upperBound) {
        var mid = Math.floor((upperBound + lowerBound) / 2);
        console.log('此时的中点：' + mid);
        if(arr[mid] &amp;lt; data) {
            lowerBound = mid + 1;
        } else if(arr[mid] &amp;gt; data) {
            upperBound = mid - 1;
        } else {
            return mid;
        }
    }
    return -1;
}

console.log(binSearch(nums,46));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://127.0.0.1:4000/img/20180222/20180222-3.jpg&quot; alt=&quot;image01&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;计算重复次数&quot;&gt;计算重复次数&lt;/h3&gt;

&lt;p&gt;count函数一开始调用 binSearch() 函数来查找指定的值。如果在数据集中能找到这个值， 那么这个函数将开始通过两个循环来统计这个值出现的次数。第一个循环向下遍历数组， 统计找到的值出现的次数，当下一个值与要查找的值不匹配时则停止计数。第二个循环向 上遍历数组，统计找到的值出现的次数，当下一个值与要查找的值不匹配时则停止计数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function count(arr,data) {
    var count = 0,
        position = binSearch(arr,data);
        if(position &amp;gt; -1) {
            ++count;
            for(var i = position-1; i &amp;gt; 0; --i) {
                if(arr[i] === data) {
                    ++count;
                } else {
                    break;
                }
            }
            for(var i = position + 1; i &amp;lt; arr.length; ++i) {
                if(arr[i] === data) {
                    ++count;
                } else {
                    break;
                }
            }
        }
        return count;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">检索算法 本章介绍了数据检索的一个方面: 如何在列表中查找特定的值。 在列表中查找数据有两种方式: 顺序查找和二分查找。 顺序查找适用于元素随机排列的列表; 二分查找适用于元素已排序的列表。 二分查找效率更高，但是你必须在进行查找之前 花费额外的时间将列表中的元素排序。 顺序查找 对于查找数据来说，最简单的方法就是从列表的第一个元素开始对列表元素逐个进行判 断，直到找到了想要的结果，或者直到列表结尾也没有找到。这种方法称为顺序查找，有 时也被称为线性查找。它属于暴力查找技巧的一种，在执行查找时可能会访问到数据结构 里的所有元素。 顺序查找的实现： 只要从列表的第一个元素开始循环，然后逐个与要查找的数据进 行比较。如果匹配到了，则结束查找。如果到了列表的结尾也没有匹配到，那么这个数据 就不存在于这个列表中。 代码实现： function seqSearch(arr, data) { for (var i = 0; i &amp;lt; arr.length; ++i) { if (arr[i] == data) { return i; } } return -1; } 如果在数组中找到了参数 data，返回所在的位置，如果没有找到要查找的数据，函数返回-1。 seqSearch() 函数的执行速度比内置的 Array.indexof() 方法慢，这里仅用来演示 顺序查找是如何运行的。 查找最小值和最大值 查找最小值 首先看看如何在数组中查找最小值，算法如下。 将数组第一个元素赋值给一个变量，把这个变量作为最小值。 开始遍历数组，从第二个元素开始依次同当前最小值进行比较。 如果当前元素数值小于当前最小值，则将当前元素设为新的最小值。 移动到下一个元素，并且重复步骤 3。 当程序结束时，这个变量中存储的就是最小值。 代码实现如下： function findMin(arr) { var min = arr[0]; for (var i = 1; i &amp;lt; arr.length; ++i) { if (arr[i] &amp;lt; min) { min = arr[i]; } } return min; } 需要注意的关键部分，由于我们假设数组的第一个元素就是当前的最小值，所以这个函数 会从数组的第二个元素开始进行处理。 查找最大值 查找最大值和查找最小值的原理是一样的，只不过是先把数组的第一个元素设置为最大值。 function findMax(arr) { var max = arr[0]; for (var i = 1; i &amp;lt; arr.length; ++i) { if (arr[i] &amp;gt; max) { max = arr[i]; } } return max; } 实例化个例子： var nums = []; for (var i = 0; i &amp;lt; 100; ++i) { nums[i] = Math.floor(Math.random() * 101); } document.getElementById('box').innerHTML = nums; var minValue = this.findMin(nums); var maxValue = this.findMax(nums); document.write(&quot;最小值是:&quot; + minValue + '&amp;lt;br /&amp;gt;'); document.write(&quot;最小值是:&quot; + maxValue); 使用自组织数据 对于未排序的数据集来说，当被查找的数据位于数据集的起始位置时，查找是最快、最成功的。通过将成功找到的元素置于数据集的起始位置，可以保证在以后的操作中该元素能被更快地查找到。 通过将频繁查找到的元素置于数据集的起始位置来最小化查找次数，这就叫做自组织数据。 由于对数据的查找遵循“80-20 原则”，因此将你的数据转化为自组织的形式是很有意义 的。 “80-20 原则”是指对某一数据集执行的 80% 的查找操作都是对其中 20% 的数据元素 进行查找。自组织的方式最终会把这 20% 的数据置于数据集的起始位置，这样便可以通过 一个简单的顺序查找快速找到它们。 举个例子，理解对 seqSearch() 函数进行改动以加入自组织方式 var numbers = [5,1,7,4,2,10,9,3,6,8]; //改动后的seqSearch() 函数 function seqSearch(arr,data) { for(var i = 0; i &amp;lt; arr.length; ++i) { if(arr[i] === data) { if( i &amp;gt; 0) { swap(arr,i,i-1); } return true; } } return false; } //swap() 函数来对这次找到的数据与当前存储在上一个位置的数据进行互换。 function swap(arr,index,index1) { temp = arr[index]; arr[index] = arr[index1]; arr[index1] = temp; } for (var i = 0; i &amp;lt;= 5; i++) { seqSearch(numbers, 4); console.log(numbers); } 这种写法同时可以保证已经在数据集前面的元素不会被越移越远。 二分查找 如果你要查找的数据是有序的，二分查找算法比顺序查找算法更高效。 var nums = [0,5,46,85,102,212,503]; //必须先排序好 function binSearch(arr,data) { var upperBound = arr.length - 1; lowerBound = 0; while(lowerBound &amp;lt;= upperBound) { var mid = Math.floor((upperBound + lowerBound) / 2); console.log('此时的中点：' + mid); if(arr[mid] &amp;lt; data) { lowerBound = mid + 1; } else if(arr[mid] &amp;gt; data) { upperBound = mid - 1; } else { return mid; } } return -1; } console.log(binSearch(nums,46)); 计算重复次数 count函数一开始调用 binSearch() 函数来查找指定的值。如果在数据集中能找到这个值， 那么这个函数将开始通过两个循环来统计这个值出现的次数。第一个循环向下遍历数组， 统计找到的值出现的次数，当下一个值与要查找的值不匹配时则停止计数。第二个循环向 上遍历数组，统计找到的值出现的次数，当下一个值与要查找的值不匹配时则停止计数。 function count(arr,data) { var count = 0, position = binSearch(arr,data); if(position &amp;gt; -1) { ++count; for(var i = position-1; i &amp;gt; 0; --i) { if(arr[i] === data) { ++count; } else { break; } } for(var i = position + 1; i &amp;lt; arr.length; ++i) { if(arr[i] === data) { ++count; } else { break; } } } return count; }</summary></entry><entry><title type="html">JS基础–高级排序(三)</title><link href="http://localhost:4000/js/2018/02/11/senior_Sort_3.html" rel="alternate" type="text/html" title="JS基础--高级排序(三)" /><published>2018-02-11T00:00:00+08:00</published><updated>2018-02-11T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/02/11/senior_Sort_3</id><content type="html" xml:base="http://localhost:4000/js/2018/02/11/senior_Sort_3.html">&lt;h1 id=&quot;高级排序快速排序&quot;&gt;高级排序—快速排序&lt;/h1&gt;

&lt;p&gt;快速排序是处理大数据集最快的排序算法之一。&lt;/p&gt;

&lt;p&gt;它是一种分而治之的算法，通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。&lt;/p&gt;

&lt;h3 id=&quot;快速排序&quot;&gt;快速排序&lt;/h3&gt;

&lt;p&gt;这个算法首先要在列表中选择一个元素作为基准值(pivot)。数据排序围绕基准值进行， 将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。&lt;/p&gt;

&lt;h4 id=&quot;自底向上的归并排序&quot;&gt;自底向上的归并排序&lt;/h4&gt;

&lt;p&gt;采用非递归或者迭代版本的归并排序是一个自底向上的过程。这个算法首先将数据集分解 为一组只有一个元素的数组。然后通过创建一组左右子数组将它们慢慢合并起来，每次合 并都保存一部分排好序的数据，直到最后剩下的这个数组所有的数据都已完美排序。&lt;/p&gt;

&lt;p&gt;下图演示了自底向上的归并排序算法是如何运行的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://0.0.0.0:4000/img/20180201/20180201-1.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JavaScript 实现的自底向上归并排序算法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function mergeSort() {
    if (this.dataStore.length &amp;lt; 2) {
        return; 
    }
    var step = 1;
    var left, right;
    while (step &amp;lt; this.dataStore.length) {
       left = 0;
       right = step;
       while (right + step &amp;lt;= this.dataStore.length) {
          mergeArrays(this.dataStore, left, left+step, right, right+step);
          left = right + step;
          right = left + step;
       }
       if (right &amp;lt; this.dataStore.length) {
            mergeArrays(this.dataStore, left, left+step, right, this.dataStore.length); 
        }
        step *= 2;
    }
}

function mergeArrays(arr,startLeft, stopLeft, startRight, stopRight) {
   var rightArr = new Array(stopRight - startRight + 1);
   var leftArr = new Array(stopLeft - startLeft + 1);
   k = startRight;
   for (var i = 0; i &amp;lt; (rightArr.length-1); ++i) {
      rightArr[i] = arr[k];
      ++k;
   } 
   k = startLeft;
   for (var i = 0; i &amp;lt; (leftArr.length-1); ++i) {
        leftArr[i] = arr[k];
        ++k; 
   }

    rightArr[rightArr.length-1] = Infinity; // 哨兵值 
    leftArr[leftArr.length-1] = Infinity; // 哨兵值 
    var m = 0;
    var n = 0;
   for (var k = startLeft; k &amp;lt; stopRight; ++k) {
        if (leftArr[m] &amp;lt;= rightArr[n]) {
            arr[k] = leftArr[m];
            m++; 
        } else {
            arr[k] = rightArr[n];
            n++;
        } 
    }
    document.write(&quot;left array - &quot;, leftArr + '&amp;lt;br /&amp;gt;');
    document.write(&quot;right array - &quot;, rightArr + '&amp;lt;br /&amp;gt;');
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;mergeSort() 函数中的关键点就是 step 这个变量，它用来控制 mergeArrays() 函数生成的 leftArr 和 rightArr 这两个子序列的大小。通过控制子序列的大小，处理排序是比较高效 的，因为它在对小数组进行排序时不需要花费太多时间。合并之所以高效，还有一个原 因，由于未合并的数据已经是排好序的，将它们合并到一个有序数组的过程非常容易。&lt;/p&gt;

&lt;p&gt;初始化10数的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var nums = new CArray(10);
nums.setData();
document.write(nums.toString() + '&amp;lt;br /&amp;gt;');
nums.mergeSort();
document.write(nums.toString() + '&amp;lt;br /&amp;gt;');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://0.0.0.0:4000/img/20180201/20180201-2.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一开始每个元素都在左子序列或右子序列中。然后将左右子序列合并，首先每次合并成两 个元素的子序列，然后合并成四个元素的子序列，3 和 5 除外，它们会一直保留到最后一次 迭代，那时会把它们合并成右子序列，然后再与最后的左子序列合并成最终的有序数组。&lt;/p&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">高级排序—快速排序 快速排序是处理大数据集最快的排序算法之一。 它是一种分而治之的算法，通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。 快速排序 这个算法首先要在列表中选择一个元素作为基准值(pivot)。数据排序围绕基准值进行， 将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。 自底向上的归并排序 采用非递归或者迭代版本的归并排序是一个自底向上的过程。这个算法首先将数据集分解 为一组只有一个元素的数组。然后通过创建一组左右子数组将它们慢慢合并起来，每次合 并都保存一部分排好序的数据，直到最后剩下的这个数组所有的数据都已完美排序。 下图演示了自底向上的归并排序算法是如何运行的 JavaScript 实现的自底向上归并排序算法: function mergeSort() { if (this.dataStore.length &amp;lt; 2) { return; } var step = 1; var left, right; while (step &amp;lt; this.dataStore.length) { left = 0; right = step; while (right + step &amp;lt;= this.dataStore.length) { mergeArrays(this.dataStore, left, left+step, right, right+step); left = right + step; right = left + step; } if (right &amp;lt; this.dataStore.length) { mergeArrays(this.dataStore, left, left+step, right, this.dataStore.length); } step *= 2; } } function mergeArrays(arr,startLeft, stopLeft, startRight, stopRight) { var rightArr = new Array(stopRight - startRight + 1); var leftArr = new Array(stopLeft - startLeft + 1); k = startRight; for (var i = 0; i &amp;lt; (rightArr.length-1); ++i) { rightArr[i] = arr[k]; ++k; } k = startLeft; for (var i = 0; i &amp;lt; (leftArr.length-1); ++i) { leftArr[i] = arr[k]; ++k; } rightArr[rightArr.length-1] = Infinity; // 哨兵值 leftArr[leftArr.length-1] = Infinity; // 哨兵值 var m = 0; var n = 0; for (var k = startLeft; k &amp;lt; stopRight; ++k) { if (leftArr[m] &amp;lt;= rightArr[n]) { arr[k] = leftArr[m]; m++; } else { arr[k] = rightArr[n]; n++; } } document.write(&quot;left array - &quot;, leftArr + '&amp;lt;br /&amp;gt;'); document.write(&quot;right array - &quot;, rightArr + '&amp;lt;br /&amp;gt;'); } mergeSort() 函数中的关键点就是 step 这个变量，它用来控制 mergeArrays() 函数生成的 leftArr 和 rightArr 这两个子序列的大小。通过控制子序列的大小，处理排序是比较高效 的，因为它在对小数组进行排序时不需要花费太多时间。合并之所以高效，还有一个原 因，由于未合并的数据已经是排好序的，将它们合并到一个有序数组的过程非常容易。 初始化10数的结果： var nums = new CArray(10); nums.setData(); document.write(nums.toString() + '&amp;lt;br /&amp;gt;'); nums.mergeSort(); document.write(nums.toString() + '&amp;lt;br /&amp;gt;'); 一开始每个元素都在左子序列或右子序列中。然后将左右子序列合并，首先每次合并成两 个元素的子序列，然后合并成四个元素的子序列，3 和 5 除外，它们会一直保留到最后一次 迭代，那时会把它们合并成右子序列，然后再与最后的左子序列合并成最终的有序数组。</summary></entry><entry><title type="html">JS基础–高级排序(二)</title><link href="http://localhost:4000/js/2018/02/01/senior_Sort_2.html" rel="alternate" type="text/html" title="JS基础--高级排序(二)" /><published>2018-02-01T00:00:00+08:00</published><updated>2018-02-01T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/02/01/senior_Sort_2</id><content type="html" xml:base="http://localhost:4000/js/2018/02/01/senior_Sort_2.html">&lt;h1 id=&quot;高级排序归并排序&quot;&gt;高级排序—归并排序&lt;/h1&gt;

&lt;p&gt;实现原理:把一系列排好序的子序列合并成一个大的完整有序序列。&lt;/p&gt;

&lt;h3 id=&quot;归并排序&quot;&gt;归并排序&lt;/h3&gt;

&lt;p&gt;从理论上讲，这个算法很容易实现。我们需要两个排好序的子数组，然后通过比较数据大小，先从最小的数据开始插入，最后合并得到第三个数组。&lt;/p&gt;

&lt;p&gt;然而，在实际情况中，归并排序还有一些问题，当用这个算法对一个很大的数据集进行排序时，需要相当大的空间来合并存储两个子数组。就现在来讲，内存不那么昂贵，空间不是问题，因此值得我们去实现一下归并排序，比较它和其他排序算法的执行效率。&lt;/p&gt;

&lt;h4 id=&quot;自底向上的归并排序&quot;&gt;自底向上的归并排序&lt;/h4&gt;

&lt;p&gt;采用非递归或者迭代版本的归并排序是一个自底向上的过程。这个算法首先将数据集分解 为一组只有一个元素的数组。然后通过创建一组左右子数组将它们慢慢合并起来，每次合 并都保存一部分排好序的数据，直到最后剩下的这个数组所有的数据都已完美排序。&lt;/p&gt;

&lt;p&gt;下图演示了自底向上的归并排序算法是如何运行的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://0.0.0.0:4000/img/20180201/20180201-1.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JavaScript 实现的自底向上归并排序算法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function mergeSort() {
    if (this.dataStore.length &amp;lt; 2) {
        return; 
    }
    var step = 1;
    var left, right;
    while (step &amp;lt; this.dataStore.length) {
       left = 0;
       right = step;
       while (right + step &amp;lt;= this.dataStore.length) {
          mergeArrays(this.dataStore, left, left+step, right, right+step);
          left = right + step;
          right = left + step;
       }
       if (right &amp;lt; this.dataStore.length) {
            mergeArrays(this.dataStore, left, left+step, right, this.dataStore.length); 
        }
        step *= 2;
    }
}

function mergeArrays(arr,startLeft, stopLeft, startRight, stopRight) {
   var rightArr = new Array(stopRight - startRight + 1);
   var leftArr = new Array(stopLeft - startLeft + 1);
   k = startRight;
   for (var i = 0; i &amp;lt; (rightArr.length-1); ++i) {
      rightArr[i] = arr[k];
      ++k;
   } 
   k = startLeft;
   for (var i = 0; i &amp;lt; (leftArr.length-1); ++i) {
        leftArr[i] = arr[k];
        ++k; 
   }

    rightArr[rightArr.length-1] = Infinity; // 哨兵值 
    leftArr[leftArr.length-1] = Infinity; // 哨兵值 
    var m = 0;
    var n = 0;
   for (var k = startLeft; k &amp;lt; stopRight; ++k) {
        if (leftArr[m] &amp;lt;= rightArr[n]) {
            arr[k] = leftArr[m];
            m++; 
        } else {
            arr[k] = rightArr[n];
            n++;
        } 
    }
    document.write(&quot;left array - &quot;, leftArr + '&amp;lt;br /&amp;gt;');
    document.write(&quot;right array - &quot;, rightArr + '&amp;lt;br /&amp;gt;');
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;mergeSort() 函数中的关键点就是 step 这个变量，它用来控制 mergeArrays() 函数生成的 leftArr 和 rightArr 这两个子序列的大小。通过控制子序列的大小，处理排序是比较高效 的，因为它在对小数组进行排序时不需要花费太多时间。合并之所以高效，还有一个原 因，由于未合并的数据已经是排好序的，将它们合并到一个有序数组的过程非常容易。&lt;/p&gt;

&lt;p&gt;初始化10数的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var nums = new CArray(10);
nums.setData();
document.write(nums.toString() + '&amp;lt;br /&amp;gt;');
nums.mergeSort();
document.write(nums.toString() + '&amp;lt;br /&amp;gt;');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://0.0.0.0:4000/img/20180201/20180201-2.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一开始每个元素都在左子序列或右子序列中。然后将左右子序列合并，首先每次合并成两 个元素的子序列，然后合并成四个元素的子序列，3 和 5 除外，它们会一直保留到最后一次 迭代，那时会把它们合并成右子序列，然后再与最后的左子序列合并成最终的有序数组。&lt;/p&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">高级排序—归并排序 实现原理:把一系列排好序的子序列合并成一个大的完整有序序列。 归并排序 从理论上讲，这个算法很容易实现。我们需要两个排好序的子数组，然后通过比较数据大小，先从最小的数据开始插入，最后合并得到第三个数组。 然而，在实际情况中，归并排序还有一些问题，当用这个算法对一个很大的数据集进行排序时，需要相当大的空间来合并存储两个子数组。就现在来讲，内存不那么昂贵，空间不是问题，因此值得我们去实现一下归并排序，比较它和其他排序算法的执行效率。 自底向上的归并排序 采用非递归或者迭代版本的归并排序是一个自底向上的过程。这个算法首先将数据集分解 为一组只有一个元素的数组。然后通过创建一组左右子数组将它们慢慢合并起来，每次合 并都保存一部分排好序的数据，直到最后剩下的这个数组所有的数据都已完美排序。 下图演示了自底向上的归并排序算法是如何运行的 JavaScript 实现的自底向上归并排序算法: function mergeSort() { if (this.dataStore.length &amp;lt; 2) { return; } var step = 1; var left, right; while (step &amp;lt; this.dataStore.length) { left = 0; right = step; while (right + step &amp;lt;= this.dataStore.length) { mergeArrays(this.dataStore, left, left+step, right, right+step); left = right + step; right = left + step; } if (right &amp;lt; this.dataStore.length) { mergeArrays(this.dataStore, left, left+step, right, this.dataStore.length); } step *= 2; } } function mergeArrays(arr,startLeft, stopLeft, startRight, stopRight) { var rightArr = new Array(stopRight - startRight + 1); var leftArr = new Array(stopLeft - startLeft + 1); k = startRight; for (var i = 0; i &amp;lt; (rightArr.length-1); ++i) { rightArr[i] = arr[k]; ++k; } k = startLeft; for (var i = 0; i &amp;lt; (leftArr.length-1); ++i) { leftArr[i] = arr[k]; ++k; } rightArr[rightArr.length-1] = Infinity; // 哨兵值 leftArr[leftArr.length-1] = Infinity; // 哨兵值 var m = 0; var n = 0; for (var k = startLeft; k &amp;lt; stopRight; ++k) { if (leftArr[m] &amp;lt;= rightArr[n]) { arr[k] = leftArr[m]; m++; } else { arr[k] = rightArr[n]; n++; } } document.write(&quot;left array - &quot;, leftArr + '&amp;lt;br /&amp;gt;'); document.write(&quot;right array - &quot;, rightArr + '&amp;lt;br /&amp;gt;'); } mergeSort() 函数中的关键点就是 step 这个变量，它用来控制 mergeArrays() 函数生成的 leftArr 和 rightArr 这两个子序列的大小。通过控制子序列的大小，处理排序是比较高效 的，因为它在对小数组进行排序时不需要花费太多时间。合并之所以高效，还有一个原 因，由于未合并的数据已经是排好序的，将它们合并到一个有序数组的过程非常容易。 初始化10数的结果： var nums = new CArray(10); nums.setData(); document.write(nums.toString() + '&amp;lt;br /&amp;gt;'); nums.mergeSort(); document.write(nums.toString() + '&amp;lt;br /&amp;gt;'); 一开始每个元素都在左子序列或右子序列中。然后将左右子序列合并，首先每次合并成两 个元素的子序列，然后合并成四个元素的子序列，3 和 5 除外，它们会一直保留到最后一次 迭代，那时会把它们合并成右子序列，然后再与最后的左子序列合并成最终的有序数组。</summary></entry><entry><title type="html">JS基础–高级排序(一)</title><link href="http://localhost:4000/js/2018/01/25/senior_Sort_1.html" rel="alternate" type="text/html" title="JS基础--高级排序(一)" /><published>2018-01-25T00:00:00+08:00</published><updated>2018-01-25T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/01/25/senior_Sort_1</id><content type="html" xml:base="http://localhost:4000/js/2018/01/25/senior_Sort_1.html">&lt;h1 id=&quot;高级排序-希尔排序&quot;&gt;高级排序— 希尔排序&lt;/h1&gt;

&lt;p&gt;本章讲解的高级排序算法，通常被认为是处理大型数据集的最高效排序算法，它们处理的数据集可以达到上百万个元素，而不仅仅是几百个或者几千个。&lt;/p&gt;

&lt;h3 id=&quot;希尔排序&quot;&gt;希尔排序&lt;/h3&gt;

&lt;p&gt;这个算法在插入排序的基础上做了很大的改善。希尔排序的核心理念与插入排序 不同，它会首先比较距离较远的元素，而非相邻的元素。和简单地比较相邻元素相比，使 用这种方案可以使离正确位置很远的元素更快地回到合适的位置。当开始用这个算法遍历 数据集时，所有元素之间的距离会不断减小，直到处理到数据集的末尾，这时算法比较的 就是相邻元素了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//希尔排序
function shellsort() {
    for (var g = 0; g &amp;lt; this.gaps.length; ++g) {
       for (var i = this.gaps[g]; i &amp;lt; this.dataStore.length; ++i) {
          var temp = this.dataStore[i];
          for (var j = i; j &amp;gt;= this.gaps[g] &amp;amp;&amp;amp;
                this.dataStore[j-this.gaps[g]] &amp;gt; temp;
               j -= this.gaps[g]) {
             this.dataStore[j] = this.dataStore[j - this.gaps[g]];
          }
          this.dataStore[j] = temp;
       }
        document.write('&amp;lt;br /&amp;gt;');
        document.write(this.toString());
        document.write('&amp;lt;br /&amp;gt;');
    } 
}

function setGaps(arr) {
    this.gaps = arr;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了能让这个程序在 CArray 类测试平台中运行，我们需要在这个类的定义里增加一个对间 隔序列的定义。请将下面代码添加到 CArray 的构造函数中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;this.gaps = [5,3,1];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;外循环控制间隔序列的移动。也就是说，算法在第一次处理数据集时，会检查所有间隔为 5 的元素。下一次遍历会检查所有间隔为 3 的元素。最后一次则会对间隔为 1 的元素，也 就是相邻元素执行标准插入排序。在开始做最后一次处理时，大部分元素都将在正确的位 置，算法就不必对很多元素进行交换。这就是希尔排序比插入排序更高效的地方。下图演示了如何使用间隔序列为5, 3, 1的希尔排序算法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;希尔排序原理图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180125/20180125-1.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;初始化一个例子，对10个数字进行希尔排序，跟踪这个算法的执行过程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    var nums = new CArray(100);
    nums.setData();
    document.write(&quot;希尔排序前:&amp;lt;br /&amp;gt;&quot;); 
    document.write(nums.toString()); 
    document.write(&quot;&amp;lt;br /&amp;gt;希尔排序中:&amp;lt;br /&amp;gt;&quot;); 
    nums.shellsort();
    document.write(&quot;&amp;lt;br /&amp;gt;希尔排序后:&amp;lt;br /&amp;gt;&quot;); 
    document.write(nums.toString());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180125/20180125-2.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;要理解希尔排序是如何运行的，可以对比数组的初始状态和执行完间隔序列为 5 的排序后的状态。初始状态时的第一个元素 6，和它后面的第 5 个元素 5，进行了互换，因为 5 &amp;lt; 6。&lt;/p&gt;

&lt;p&gt;再来比较 gap 5 和 gap 3 这两行。在 gap 5 这行中的数字 3 和数字 2 进行了互换， 因为 2 &amp;lt; 3，并且 2 是 3 后面的第 3 个元素。从循环中当前元素所在位置往后数，简单地数到第 gap 个数的位置，然后比较这个位置和当前元素所在位置上的两个数字，就可以对希 尔排序过程中的任何步骤进行跟踪。&lt;/p&gt;

&lt;h3 id=&quot;动态计算间隔序列的希尔排序&quot;&gt;动态计算间隔序列的希尔排序&lt;/h3&gt;

&lt;p&gt;《算法(第4版)》(人民邮电出版社)的合著者Robert Sedgewick定义了一个shellsort() 函数，在这个函数中可以通过一个公式来对希尔排序用到的间隔序列进行动态计算。 Sedgewick 的算法是通过下面的代码片段来决定初始间隔值的:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    var N = this.dataStore.length;
    var h = 1;
    while (h &amp;lt; N/3) {
        h = 3 * h + 1; 
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;间隔值确定好后，这个函数就可以像之前定义的 shellsort() 函数一样运行了，唯一的区 别是，回到外循环之前的最后一条语句会计算一个新的间隔值:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;h = (h-1)/3;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;修改后的shellsort1函数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function shellsort1() {
    var N = this.dataStore.length;
    var h = 1;
    while (h &amp;lt; N/3) {
      h = 3 * h + 1; 
    }
    while (h &amp;gt;= 1) {
       for (var i = h; i &amp;lt; N; i++) {
          for (var j = i; j &amp;gt;= h &amp;amp;&amp;amp; this.dataStore[j] &amp;lt; this.dataStore[j-h];
               j -= h) {
             swap(this.dataStore, j, j-h);
          }
      }
      h = (h-1)/3; 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样初始化10个数，shellsort1后的结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180125/20180125-3.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;比较-shellsort-算法&quot;&gt;比较 shellsort() 算法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    var nums = new CArray(100000);
    nums.setData();
    var start = new Date().getTime();
    nums.shellsort();
    var stop = new Date().getTime();
    var elapsed = stop - start;
    document.write(&quot; 硬编码间隔序列的希尔排序消耗的时间为:&quot; + elapsed + &quot; 毫秒。&quot;); 
    nums.clear();

    nums.setData();
    start = new Date().getTime();
    nums.shellsort1();
    stop = new Date().getTime();
    document.write(&quot; 动态间隔序列的希尔排序消耗的时间为:&quot; + elapsed + &quot; 毫秒。&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://lilywei739.github.io/img/20180125/20180125-4.jpg&quot; alt=&quot;图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很明显，这两个希尔排序算法的效率是一样的，因此你可以根据需要随意使用&lt;/p&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">高级排序— 希尔排序 本章讲解的高级排序算法，通常被认为是处理大型数据集的最高效排序算法，它们处理的数据集可以达到上百万个元素，而不仅仅是几百个或者几千个。 希尔排序 这个算法在插入排序的基础上做了很大的改善。希尔排序的核心理念与插入排序 不同，它会首先比较距离较远的元素，而非相邻的元素。和简单地比较相邻元素相比，使 用这种方案可以使离正确位置很远的元素更快地回到合适的位置。当开始用这个算法遍历 数据集时，所有元素之间的距离会不断减小，直到处理到数据集的末尾，这时算法比较的 就是相邻元素了。 //希尔排序 function shellsort() { for (var g = 0; g &amp;lt; this.gaps.length; ++g) { for (var i = this.gaps[g]; i &amp;lt; this.dataStore.length; ++i) { var temp = this.dataStore[i]; for (var j = i; j &amp;gt;= this.gaps[g] &amp;amp;&amp;amp; this.dataStore[j-this.gaps[g]] &amp;gt; temp; j -= this.gaps[g]) { this.dataStore[j] = this.dataStore[j - this.gaps[g]]; } this.dataStore[j] = temp; } document.write('&amp;lt;br /&amp;gt;'); document.write(this.toString()); document.write('&amp;lt;br /&amp;gt;'); } } function setGaps(arr) { this.gaps = arr; } 为了能让这个程序在 CArray 类测试平台中运行，我们需要在这个类的定义里增加一个对间 隔序列的定义。请将下面代码添加到 CArray 的构造函数中 this.gaps = [5,3,1]; 外循环控制间隔序列的移动。也就是说，算法在第一次处理数据集时，会检查所有间隔为 5 的元素。下一次遍历会检查所有间隔为 3 的元素。最后一次则会对间隔为 1 的元素，也 就是相邻元素执行标准插入排序。在开始做最后一次处理时，大部分元素都将在正确的位 置，算法就不必对很多元素进行交换。这就是希尔排序比插入排序更高效的地方。下图演示了如何使用间隔序列为5, 3, 1的希尔排序算法。 希尔排序原理图： 初始化一个例子，对10个数字进行希尔排序，跟踪这个算法的执行过程 var nums = new CArray(100); nums.setData(); document.write(&quot;希尔排序前:&amp;lt;br /&amp;gt;&quot;); document.write(nums.toString()); document.write(&quot;&amp;lt;br /&amp;gt;希尔排序中:&amp;lt;br /&amp;gt;&quot;); nums.shellsort(); document.write(&quot;&amp;lt;br /&amp;gt;希尔排序后:&amp;lt;br /&amp;gt;&quot;); document.write(nums.toString()); 要理解希尔排序是如何运行的，可以对比数组的初始状态和执行完间隔序列为 5 的排序后的状态。初始状态时的第一个元素 6，和它后面的第 5 个元素 5，进行了互换，因为 5 &amp;lt; 6。 再来比较 gap 5 和 gap 3 这两行。在 gap 5 这行中的数字 3 和数字 2 进行了互换， 因为 2 &amp;lt; 3，并且 2 是 3 后面的第 3 个元素。从循环中当前元素所在位置往后数，简单地数到第 gap 个数的位置，然后比较这个位置和当前元素所在位置上的两个数字，就可以对希 尔排序过程中的任何步骤进行跟踪。 动态计算间隔序列的希尔排序 《算法(第4版)》(人民邮电出版社)的合著者Robert Sedgewick定义了一个shellsort() 函数，在这个函数中可以通过一个公式来对希尔排序用到的间隔序列进行动态计算。 Sedgewick 的算法是通过下面的代码片段来决定初始间隔值的: var N = this.dataStore.length; var h = 1; while (h &amp;lt; N/3) { h = 3 * h + 1; } 间隔值确定好后，这个函数就可以像之前定义的 shellsort() 函数一样运行了，唯一的区 别是，回到外循环之前的最后一条语句会计算一个新的间隔值: h = (h-1)/3; 修改后的shellsort1函数如下： function shellsort1() { var N = this.dataStore.length; var h = 1; while (h &amp;lt; N/3) { h = 3 * h + 1; } while (h &amp;gt;= 1) { for (var i = h; i &amp;lt; N; i++) { for (var j = i; j &amp;gt;= h &amp;amp;&amp;amp; this.dataStore[j] &amp;lt; this.dataStore[j-h]; j -= h) { swap(this.dataStore, j, j-h); } } h = (h-1)/3; } } 同样初始化10个数，shellsort1后的结果： 比较 shellsort() 算法 var nums = new CArray(100000); nums.setData(); var start = new Date().getTime(); nums.shellsort(); var stop = new Date().getTime(); var elapsed = stop - start; document.write(&quot; 硬编码间隔序列的希尔排序消耗的时间为:&quot; + elapsed + &quot; 毫秒。&quot;); nums.clear(); nums.setData(); start = new Date().getTime(); nums.shellsort1(); stop = new Date().getTime(); document.write(&quot; 动态间隔序列的希尔排序消耗的时间为:&quot; + elapsed + &quot; 毫秒。&quot;); 很明显，这两个希尔排序算法的效率是一样的，因此你可以根据需要随意使用</summary></entry><entry><title type="html">JS基础– 基本排序</title><link href="http://localhost:4000/js/2018/01/11/basic_Sort.html" rel="alternate" type="text/html" title="JS基础-- 基本排序" /><published>2018-01-11T00:00:00+08:00</published><updated>2018-01-11T00:00:00+08:00</updated><id>http://localhost:4000/js/2018/01/11/basic_Sort</id><content type="html" xml:base="http://localhost:4000/js/2018/01/11/basic_Sort.html">&lt;h1 id=&quot;基本排序算法&quot;&gt;基本排序算法&lt;/h1&gt;

&lt;p&gt;这里介绍的基本排序算法其核心思想是指对一组数据按照一定的顺序重新排列。重新排列时用到的技术是一组嵌套的 for 循环。其中外循环会遍历数组的每一项，内循环则用于比较元素。&lt;/p&gt;

&lt;p&gt;在讲这几个基本排序之前，先初始化一个类，因为下面所有的排序都是基于这个类实现的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function CArray(numElements) {
    this.dataStore = [];
    this.pos = 0;
    this.numElements = numElements;
    this.insert = insert;
    this.toString = toString;
    this.clear = clear;
    this.setData = setData;
    this.bubbleSort = bubbleSort;
    this.swap = swap;
	for ( var i = 0; i &amp;lt; numElements; ++i ) {
		this.dataStore[i] = i;
	} 
}

function setData() {
    for ( var i = 0; i &amp;lt; this.numElements; ++i ) {
       this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1));
    }
}

function clear() {
	for ( var i = 0; i &amp;lt; this.dataStore.length; ++i ) {
	   this.dataStore[i] = 0;
	}
}


function insert(element) {
    this.dataStore[this.pos++] = element;
}


function toString() {
	var retstr = &quot;&quot;;
	for ( var i = 0; i &amp;lt; this.dataStore.length; ++i ) {
	   retstr += this.dataStore[i] + &quot; &quot;;
	   if (i &amp;gt; 0 &amp;amp; i % 10 == 0) {
	      retstr += &quot;\n&quot;;
	   }
	}
	return retstr;
}


function swap(arr, index1, index2) {
	var temp = arr[index1];
	arr[index1] = arr[index2];
	arr[index2] = temp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的类包含下面几个功能&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;插入新数据&lt;/li&gt;
  &lt;li&gt;显示数组数据&lt;/li&gt;
  &lt;li&gt;调用不同的排序算法&lt;/li&gt;
  &lt;li&gt;交换数组元素&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h4&gt;

&lt;p&gt;冒泡排序算法，它是最慢的排序算法之一，但也是一种最容易实现的排序算法&lt;/p&gt;

&lt;p&gt;之所以叫冒泡排序是因为使用这种排序算法排序时，数据值会像气泡一样从数组的一端漂 浮到另一端。假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，而较小 的值则会浮动到数组的左侧。之所以会产生这种现象是因为算法会多次在数组中移动，比 较相邻的数据，当左侧值大于右侧值时将它们进行互换&lt;/p&gt;

&lt;p&gt;如下图演示了如何对一个大的数字数据集合进行冒泡排序的过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-1.jpg&quot; alt=&quot;冒泡排序的过程&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function bubbleSort() {
        var numElements = this.dataStore.length;
        var temp;
        for ( var outer = numElements; outer &amp;gt;= 2; --outer) {
           for ( var inner = 0; inner &amp;lt;= outer - 1; ++inner ) {
              if (this.dataStore[inner] &amp;gt; this.dataStore[inner + 1]) {
                 swap(this.dataStore, inner, inner + 1);
              }
 	   } 
 	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;初始化个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numElements = 10;
var mynums = new CArray(numElements);
mynums.setData();
document.write(mynums.toString());
mynums.bubbleSort();
document.write('&amp;lt;br /&amp;gt;');
document.write(mynums.toString());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;排序结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;增加一行代码，就可看到这个数组在排序过程中的当前状态&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function bubbleSort() {
    var numElements = this.dataStore.length;
    var temp;
    for (var outer = numElements; outer &amp;gt;= 2; --outer) {
       for (var inner = 0; inner &amp;lt;= outer - 1; ++inner) {

          if (this.dataStore[inner] &amp;gt; this.dataStore[inner + 1]) {
             swap(this.dataStore, inner, inner + 1);
          }
		}
        document.write('&amp;lt;br /&amp;gt;');
        document.write(this.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;排序结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过这个输出结果，我们可以更加容易地看出小的值是如何移到数组开头的，大的值又是 如何移到数组末尾的。&lt;/p&gt;

&lt;h4 id=&quot;选择排序&quot;&gt;选择排序&lt;/h4&gt;

&lt;p&gt;选择排序从数组的开头开始，将第一个元素和其他元 素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从 第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便 完成了排序。&lt;/p&gt;

&lt;p&gt;选择排序会用到嵌套循环。外循环从数组的第一个元素移动到倒数第二个元素;内循环从第 二个数组元素移动到最后一个元素，查找比当前外循环所指向的元素小的元素。每次内循环 迭代后，数组中最小的值都会被赋值到合适的位置。&lt;/p&gt;

&lt;p&gt;选择排序算法的原理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function selectionSort() {
    var min, temp;
    for (var outer = 0; outer &amp;lt;= this.dataStore.length-2; ++outer) {
       min = outer;
       for (var inner = outer + 1;
           inner &amp;lt;= this.dataStore.length-1; ++inner) {
          if (this.dataStore[inner] &amp;lt; this.dataStore[min]) {
			  min = inner; 
		  }
          swap(this.dataStore, outer, min);
          document.write('&amp;lt;br /&amp;gt;');
          document.write(this.toString());
       }
    } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numElements = 10;
var mynums = new CArray(numElements);
mynums.setData();
mynums.selectionSort();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;排序结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;插入排序&quot;&gt;插入排序&lt;/h4&gt;

&lt;p&gt;插入排序类似于人类按数字或字母顺序对数据进行排序&lt;/p&gt;

&lt;p&gt;举个例子，将卡片带回办公室，清理好书桌，然后拿起第一张卡片。卡片上的姓氏是 Smith。我把 它放到桌子的左上角，然后再拿起第二张卡片。这张卡片上的姓氏是 Brown。我把 Smith 移右，把 Brown 放到 Smith 的前面。下一张卡片是 Williams，可以把它放到桌面最右边， 而不用移动其他任何卡片。下一张卡片是 Acklin。这张卡片必须放在这些卡片的最前面， 因此其他所有卡片必须向右移动一个位置来为 Acklin 这张卡片腾出位置。这就是插入排序 的排序原理。&lt;/p&gt;

&lt;p&gt;插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及 它后面的那个元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数 组元素会向右移动，为内循环中的这个元素腾出位置，就像之前介绍的姓氏卡片一样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function insertionSort() {
        var temp, inner;
        for (var outer = 1; outer &amp;lt;= this.dataStore.length - 1; ++outer) {
           temp = this.dataStore[outer];
           inner = outer;
           while (inner &amp;gt; 0 &amp;amp;&amp;amp; (this.dataStore[inner - 1] &amp;gt;= temp)) {
              this.dataStore[inner] = this.dataStore[inner - 1];
--inner; }
           this.dataStore[inner] = temp;
           document.write('&amp;lt;br /&amp;gt;');
       	   document.write(this.toString());
        }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numElements = 10;
var mynums = new CArray(numElements);
mynums.setData();
mynums.insertionSort();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;排序结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这段输出结果清楚地显示了插入排序的运行并非通过数据交换，而是通过将较大的数组元 素移动到右侧，为数组左侧的较小元素腾出位置。&lt;/p&gt;

&lt;h4 id=&quot;基本排序算法的计时比较&quot;&gt;基本排序算法的计时比较&lt;/h4&gt;

&lt;p&gt;这三种排序算法的复杂度非常相似，从理论上来说，它们的执行效率也应该差不多。要确 定这三种算法的性能差异，我们可以使用一个非正式的计时系统来比较它们对数据集合进 行排序所花费的时间。能够对算法进行计时非常重要，因为，对 100 个或 1000 个元素进 行排序时，你看不出这些排序算法的差异。但是如果对上百万个元素进行排序，这些排序 算法之间可能存在巨大的不同。&lt;/p&gt;

&lt;p&gt;这个函数的运行方式如下所示:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var start = new Date().getTime();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要记录代码执行的时间，首先启动计时器，执行代码，然后在代码执行结束时停止计时 器。计时器停止时记录的时间与计时器启动时记录的时间之差就是排序所花费的时间。&lt;/p&gt;

&lt;p&gt;有了度量排序算法效率的工具，那我们就来做一些测试，对它们进行比较&lt;/p&gt;

&lt;p&gt;为了比较基本排序算法，我们将在数组大小分别为100、1000和10 000时对这三种排序算 法计时。我们预期在数据大小为 100 和 1000 的情况下看不出这些算法的差异，但是在数 据大小为 10000时可以看到。&lt;/p&gt;

&lt;p&gt;测试代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numElements = 100;    //测试数据100、1000、10000
var nums = new CArray(numElements);
nums.setData();
var start = new Date().getTime();
nums.bubbleSort();
var stop = new Date().getTime();
var elapsed = stop - start;
document.write(&quot;对&quot; + numElements + &quot;个元素执行冒泡排序消耗的时间为:&quot; +
elapsed + &quot;毫秒。&amp;lt;br /&amp;gt;&quot;);
start = new Date().getTime();
nums.selectionSort();
stop = new Date().getTime();
elapsed = stop - start;
document.write(&quot;对&quot; + numElements + &quot;个元素执行选择排序消耗的时间为:&quot; +
elapsed + &quot;毫秒。&amp;lt;br /&amp;gt;&quot;);
start = new Date().getTime();
nums.insertionSort();
stop = new Date().getTime();
elapsed = stop - start;
document.write(&quot;对&quot; + numElements + &quot;个元素执行插入排序消耗的时间为:&quot; +
elapsed + &quot;毫秒。&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;测试数据100结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;测试数据1000结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;测试数据10000结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lilywei739.github.io/img/20180112/20180112-9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过上面的结果，可得出选择排序和插入排序要比冒泡排序快，插入排序是这三种算法中最快的。不过要记住，这些测试必须经过多次的运行， 最后得到的结果才可被视为是有效的统计。&lt;/p&gt;</content><author><name>weili</name></author><category term="[&quot;JS&quot;]" /><summary type="html">基本排序算法 这里介绍的基本排序算法其核心思想是指对一组数据按照一定的顺序重新排列。重新排列时用到的技术是一组嵌套的 for 循环。其中外循环会遍历数组的每一项，内循环则用于比较元素。 在讲这几个基本排序之前，先初始化一个类，因为下面所有的排序都是基于这个类实现的。 function CArray(numElements) { this.dataStore = []; this.pos = 0; this.numElements = numElements; this.insert = insert; this.toString = toString; this.clear = clear; this.setData = setData; this.bubbleSort = bubbleSort; this.swap = swap; for ( var i = 0; i &amp;lt; numElements; ++i ) { this.dataStore[i] = i; } } function setData() { for ( var i = 0; i &amp;lt; this.numElements; ++i ) { this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1)); } } function clear() { for ( var i = 0; i &amp;lt; this.dataStore.length; ++i ) { this.dataStore[i] = 0; } } function insert(element) { this.dataStore[this.pos++] = element; } function toString() { var retstr = &quot;&quot;; for ( var i = 0; i &amp;lt; this.dataStore.length; ++i ) { retstr += this.dataStore[i] + &quot; &quot;; if (i &amp;gt; 0 &amp;amp; i % 10 == 0) { retstr += &quot;\n&quot;; } } return retstr; } function swap(arr, index1, index2) { var temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; } 上面的类包含下面几个功能 插入新数据 显示数组数据 调用不同的排序算法 交换数组元素 冒泡排序 冒泡排序算法，它是最慢的排序算法之一，但也是一种最容易实现的排序算法 之所以叫冒泡排序是因为使用这种排序算法排序时，数据值会像气泡一样从数组的一端漂 浮到另一端。假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，而较小 的值则会浮动到数组的左侧。之所以会产生这种现象是因为算法会多次在数组中移动，比 较相邻的数据，当左侧值大于右侧值时将它们进行互换 如下图演示了如何对一个大的数字数据集合进行冒泡排序的过程 function bubbleSort() { var numElements = this.dataStore.length; var temp; for ( var outer = numElements; outer &amp;gt;= 2; --outer) { for ( var inner = 0; inner &amp;lt;= outer - 1; ++inner ) { if (this.dataStore[inner] &amp;gt; this.dataStore[inner + 1]) { swap(this.dataStore, inner, inner + 1); } } } } 初始化个例子： var numElements = 10; var mynums = new CArray(numElements); mynums.setData(); document.write(mynums.toString()); mynums.bubbleSort(); document.write('&amp;lt;br /&amp;gt;'); document.write(mynums.toString()); 排序结果如下： 增加一行代码，就可看到这个数组在排序过程中的当前状态 function bubbleSort() { var numElements = this.dataStore.length; var temp; for (var outer = numElements; outer &amp;gt;= 2; --outer) { for (var inner = 0; inner &amp;lt;= outer - 1; ++inner) { if (this.dataStore[inner] &amp;gt; this.dataStore[inner + 1]) { swap(this.dataStore, inner, inner + 1); } } document.write('&amp;lt;br /&amp;gt;'); document.write(this.toString()); } } 排序结果如下： 通过这个输出结果，我们可以更加容易地看出小的值是如何移到数组开头的，大的值又是 如何移到数组末尾的。 选择排序 选择排序从数组的开头开始，将第一个元素和其他元 素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从 第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便 完成了排序。 选择排序会用到嵌套循环。外循环从数组的第一个元素移动到倒数第二个元素;内循环从第 二个数组元素移动到最后一个元素，查找比当前外循环所指向的元素小的元素。每次内循环 迭代后，数组中最小的值都会被赋值到合适的位置。 选择排序算法的原理： function selectionSort() { var min, temp; for (var outer = 0; outer &amp;lt;= this.dataStore.length-2; ++outer) { min = outer; for (var inner = outer + 1; inner &amp;lt;= this.dataStore.length-1; ++inner) { if (this.dataStore[inner] &amp;lt; this.dataStore[min]) { min = inner; } swap(this.dataStore, outer, min); document.write('&amp;lt;br /&amp;gt;'); document.write(this.toString()); } } } var numElements = 10; var mynums = new CArray(numElements); mynums.setData(); mynums.selectionSort(); 排序结果如下： 插入排序 插入排序类似于人类按数字或字母顺序对数据进行排序 举个例子，将卡片带回办公室，清理好书桌，然后拿起第一张卡片。卡片上的姓氏是 Smith。我把 它放到桌子的左上角，然后再拿起第二张卡片。这张卡片上的姓氏是 Brown。我把 Smith 移右，把 Brown 放到 Smith 的前面。下一张卡片是 Williams，可以把它放到桌面最右边， 而不用移动其他任何卡片。下一张卡片是 Acklin。这张卡片必须放在这些卡片的最前面， 因此其他所有卡片必须向右移动一个位置来为 Acklin 这张卡片腾出位置。这就是插入排序 的排序原理。 插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及 它后面的那个元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数 组元素会向右移动，为内循环中的这个元素腾出位置，就像之前介绍的姓氏卡片一样。 function insertionSort() { var temp, inner; for (var outer = 1; outer &amp;lt;= this.dataStore.length - 1; ++outer) { temp = this.dataStore[outer]; inner = outer; while (inner &amp;gt; 0 &amp;amp;&amp;amp; (this.dataStore[inner - 1] &amp;gt;= temp)) { this.dataStore[inner] = this.dataStore[inner - 1]; --inner; } this.dataStore[inner] = temp; document.write('&amp;lt;br /&amp;gt;'); document.write(this.toString()); } } var numElements = 10; var mynums = new CArray(numElements); mynums.setData(); mynums.insertionSort(); 排序结果如下： 这段输出结果清楚地显示了插入排序的运行并非通过数据交换，而是通过将较大的数组元 素移动到右侧，为数组左侧的较小元素腾出位置。 基本排序算法的计时比较 这三种排序算法的复杂度非常相似，从理论上来说，它们的执行效率也应该差不多。要确 定这三种算法的性能差异，我们可以使用一个非正式的计时系统来比较它们对数据集合进 行排序所花费的时间。能够对算法进行计时非常重要，因为，对 100 个或 1000 个元素进 行排序时，你看不出这些排序算法的差异。但是如果对上百万个元素进行排序，这些排序 算法之间可能存在巨大的不同。 这个函数的运行方式如下所示: var start = new Date().getTime(); 要记录代码执行的时间，首先启动计时器，执行代码，然后在代码执行结束时停止计时 器。计时器停止时记录的时间与计时器启动时记录的时间之差就是排序所花费的时间。 有了度量排序算法效率的工具，那我们就来做一些测试，对它们进行比较 为了比较基本排序算法，我们将在数组大小分别为100、1000和10 000时对这三种排序算 法计时。我们预期在数据大小为 100 和 1000 的情况下看不出这些算法的差异，但是在数 据大小为 10000时可以看到。 测试代码如下： var numElements = 100; //测试数据100、1000、10000 var nums = new CArray(numElements); nums.setData(); var start = new Date().getTime(); nums.bubbleSort(); var stop = new Date().getTime(); var elapsed = stop - start; document.write(&quot;对&quot; + numElements + &quot;个元素执行冒泡排序消耗的时间为:&quot; + elapsed + &quot;毫秒。&amp;lt;br /&amp;gt;&quot;); start = new Date().getTime(); nums.selectionSort(); stop = new Date().getTime(); elapsed = stop - start; document.write(&quot;对&quot; + numElements + &quot;个元素执行选择排序消耗的时间为:&quot; + elapsed + &quot;毫秒。&amp;lt;br /&amp;gt;&quot;); start = new Date().getTime(); nums.insertionSort(); stop = new Date().getTime(); elapsed = stop - start; document.write(&quot;对&quot; + numElements + &quot;个元素执行插入排序消耗的时间为:&quot; + elapsed + &quot;毫秒。&quot;); 测试数据100结果： 测试数据1000结果： 测试数据10000结果： 通过上面的结果，可得出选择排序和插入排序要比冒泡排序快，插入排序是这三种算法中最快的。不过要记住，这些测试必须经过多次的运行， 最后得到的结果才可被视为是有效的统计。</summary></entry></feed>