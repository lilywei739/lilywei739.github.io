---
layout: post
title:  React（二）
---



# React（二）


### React 组件

创建一个组件

```
var HelloMessage = React.createClass({
  render: function() {
    return <h1>Hello World！</h1>;
  }
});
 
ReactDOM.render(
  <HelloMessage />,
  document.getElementById('example')
);
```
React.createClass 方法用于生成一个组件类 HelloMessage。<HelloMessage /> 实例组件类并输出信息。

> 注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。

#### 向组件中传参，props

```
var HelloMessage = React.createClass({
  render: function() {
    return <h1>Hello {this.props.name}</h1>;
  }
});
 
ReactDOM.render(
  <HelloMessage name="Runoob" />,
  document.getElementById('example')
);
```

给组件传参数，通过props 属性，与传的参数名字一一对应，实例中 name 属性通过 this.props.name 来获取, **在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字**


#### 组合组件

```
var WebSite = React.createClass({        //组件WebSite 包含两个小的组件
  render: function() {
    return (
      <div>
        <Name name={this.props.name} />  //组件 Name，因为 name 值是在父组件中传过来的，这里用 this.props 去取
        <Link site={this.props.site} />  //组件 Link，同理，用 this.props 去取传过来的属性
      </div>
    );
  }
});
 
var Name = React.createClass({
  render: function() {
    return (
      <h1>{this.props.name}</h1>
    );
  }
});
 
var Link = React.createClass({
  render: function() {
    return (
      <a href={this.props.site}>
        {this.props.site}
      </a>
    );
  }
});
 
ReactDOM.render(
  <WebSite name="宝宝树" site="http://www.babytree.com" />,
  document.getElementById('example')
);
```


#### React State(状态)

React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。

React 里，只需**更新组件的 state，**然后根据**新的 state** 重新**渲染用户界面**（不要操作 DOM）。

**getInitialState**方法用于定义初始状态

```
var LikeButton = React.createClass({
getInitialState: function() {                //getInitialState 方法用于定义初始状态，用了一个对象，这个对象只能用 this.state 来读取属性
  return {liked: false};
}, 

handleClick: function(event) {
  this.setState({liked: !this.state.liked}); //当用户点击组件，导致状态变化，this.setState 方法就修改状态值
},

render: function() {                        //每次修改以后，自动调用 this.render 方法，再次渲染组件
  var text = this.state.liked ? '喜欢' : '不喜欢';
  return (
    <p onClick={this.handleClick}>
      你<b>{text}</b>我。点我切换状态。
    </p>
  );
}
});

ReactDOM.render(
  <LikeButton />,
  document.getElementById('example')
);
```


####  props


state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据。

props举个简单的例子，实例中 name 属性通过 this.props.name 来获取

```
var HelloMessage = React.createClass({
  render: function() {
    return <h1>Hello {this.props.name}</h1>;
  }
});

ReactDOM.render(
  <HelloMessage name="Runoob" />,
  document.getElementById('example')
);
```


#### 默认 Props

**getDefaultProps()** 方法为 props 设置默认值

```
var HelloMessage = React.createClass({
    getDefaultProps: function () {
    	return {name: 'Runoob'}
    },
    render: function () {
        return <h1>Hello {this.props.name}</h1>;
    }
})

ReactDOM.render(<HelloMessage />, document.getElementById('example'));
```

这个例子和上面的例子完全一样，区别是参数一个直接写在组件里面，另一个用 getDefaultProps 方法来设置。



#### State 和 Props

还是以上面组合组件的示例，更改一下

```
var WebSite = React.createClass({
    getInitialState: function () {
        return {
            name: "宝宝树",            //设置了 name 属性，只能用 this.state 来取
            src: "www.babytree.com"    //同理
        }
    },
    render: function () {
        return (
            <div>
                <Name name={this.state.name} />   //Name组件，用this.name取初始化中的name值，但是这处也是一个参数,会在初始化 Name 组件时用 this.props 取值
                <Link src={this.state.src} />
            </div>
        );
    }
});

var Name = React.createClass({
    render: function () {
        return <h1>{this.props.name}</h1>
    }
});

var Link = React.createClass({
    render: function () {
        return <p><a href={this.props.src}>{this.props.src}</a></p>
    }
});


ReactDOM.render(<WebSite />, document.getElementById('box'));      //WebSite 父组件
```


#### Props 验证


Props 验证使用 **propTypes**，它可以保证我们的应用组件被正确使用，**React.PropTypes** 提供很多验证器 (validator) 来验证传入数据是否有效。当向 props 传入无效数据时，JavaScript 控制台会抛出警告。

```
    var title = "宝宝树";
    //var title = 123;
    var MyTitle = React.createClass({
      propTypes: {
        title: React.PropTypes.string.isRequired,
      },

      render: function() {
         return <h1> {this.props.title} </h1>;
       }
    });
    ReactDOM.render(
        <MyTitle title={title} />,
        document.getElementById('example')
    );

```

React.PropTypes.string.isRequired  必须是字符串，如果是数字会报错。



更多的检验器：


```
React.createClass({
  propTypes: {
    // 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的
   optionalArray: React.PropTypes.array,
    optionalBool: React.PropTypes.bool,
    optionalFunc: React.PropTypes.func,
    optionalNumber: React.PropTypes.number,
    optionalObject: React.PropTypes.object,
    optionalString: React.PropTypes.string,
 
    // 可以被渲染的对象 numbers, strings, elements 或 array
    optionalNode: React.PropTypes.node,
 
    //  React 元素
    optionalElement: React.PropTypes.element,
 
    // 用 JS 的 instanceof 操作符声明 prop 为类的实例。
    optionalMessage: React.PropTypes.instanceOf(Message),
 
    // 用 enum 来限制 prop 只接受指定的值。
    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),
 
    // 可以是多个对象类型中的一个
    optionalUnion: React.PropTypes.oneOfType([
      React.PropTypes.string,
      React.PropTypes.number,
      React.PropTypes.instanceOf(Message)
    ]),
 
    // 指定类型组成的数组
    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),
 
    // 指定类型的属性构成的对象
    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),
 
    // 特定 shape 参数的对象
    optionalObjectWithShape: React.PropTypes.shape({
      color: React.PropTypes.string,
      fontSize: React.PropTypes.number
    }),
 
    // 任意类型加上 `isRequired` 来使 prop 不可空。
    requiredFunc: React.PropTypes.func.isRequired,
 
    // 不可空的任意类型
    requiredAny: React.PropTypes.any.isRequired,
 
    // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。
    customProp: function(props, propName, componentName) {
      if (!/matchme/.test(props[propName])) {
        return new Error('Validation failed!');
      }
    }
  },
  /* ... */
});

```
