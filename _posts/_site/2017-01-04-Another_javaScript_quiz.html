<h1 id="another-javascript-quiz">Another JavaScript quiz试题解析</h1>

<p><strong>转载于 <a href="http://www.zhangxinxu.com/wordpress/2013/05/%E7%90%86%E8%A7%A3another-javascript-quiz-%E9%A2%98%E7%9B%AE/">鑫空间，鑫生活</a></strong></p>

<p>这里要介绍的”<a href="http://james.padolsey.com/javascript/another-javascript-quiz/">Another JavaScript quiz“</a>(by james)中的题目不是属于变态题目，而是确实属于变态题目，不过是表面上的，很多内容确实可能会遇到的。综合评价下就是：面试价值不及格，学习价值是很赞的，因此，探讨分享很有意义。</p>

<h2 id="section">1、1 &amp;&amp; 3</h2>

<p>结果是3</p>

<p>从左往右，如果”1”通过，继续“3”；否则直接返回“1”。因为“3”后面没有其他值了，因此直接返回“3”。</p>

<p>因此，实际上，平时的if (1 &amp;&amp; 3) {} 等同于 if (3) {}.</p>

<p>再看看</p>

<div class="highlighter-rouge"><pre class="highlight"><code>0 &amp;&amp; 3  //==&gt; 0
</code></pre>
</div>

<p>因为0 == false, 因此走不到“3”这一关，直接返回了0。</p>

<p>也就是if (0 &amp;&amp; 3) {} 等同于 if (0) { /* 不会执行 */ }.</p>

<p><strong>应用场景：</strong></p>

<p>可以避免if嵌套。例如，要问页面上某个dom绑定点击事件，我们需要先判断这个dom元素存不存在，会这样做：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var dom = document.querySelector("#dom");
if (dom) { dom.addEventListener("click", function() {});  }
</code></pre>
</div>

<p>实际上，可以使用&amp;&amp;做一些简化：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var dom = document.querySelector("#dom");
dom &amp;&amp; dom.addEventListener("click", function() {});
</code></pre>
</div>

<h2 id="foo--0">2、1 &amp;&amp; “foo” || 0</h2>

<p>结果是 foo</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1 &amp;&amp; 'foo' ==&gt; 'foo', 'foo' || 0, 因为'foo' 弱等于true，最后返回foo
</code></pre>
</div>

<blockquote>
  <p>&amp;&amp; 和 ||，在 JS 运算过程中，都会将它们两边的值转为布尔值，然后再算值，&amp;&amp; 运算如果返回true，则取后面的值，如果|| 返回true,则取前面的值</p>
</blockquote>

<p><strong>应用场景：</strong></p>

<p>|| 可以让我们使用一种更快捷简易的方式为参数添加默认值。例如，写jQuery插件的时候，可选参数是可以缺省的，此时实际上值为undefined，会让后面的参数extend产生困扰。因此，我们会经常见到类似这样的代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$.fn.plugin = function(options) {
    options = options || {};
    // ...
};
</code></pre>
</div>

<h2 id="foo--0-1">3、1 || “foo” &amp;&amp; 0</h2>

<p>结果是1</p>

<blockquote>
  <p>逻辑与运算符(&amp;&amp;)优先级要大于逻辑或(||)。</p>
</blockquote>

<h2 id="section-1">4、(1, 2, 3)</h2>

<p>结果是3</p>

<blockquote>
  <p>逗号表达式的一般形式是：表达式1，表达式2，表达式3……表达式n <br /> 
逗号表达式的求解过程是：先计算表达式1的值，再计算表达式2的值，……一直计算到表达式n的值。最后<strong>整个逗号表达式的值</strong>是<strong>表达式n的值</strong>。</p>
</blockquote>

<p>延伸一下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>alert(1,2,3) 结果会是多少？
</code></pre>
</div>

<p>结果会返回1</p>

<p>因为alert()后面的这个括号是一个函数执行，所以会返回传入的第一个参数1。</p>

<p>如果这样写</p>

<div class="highlighter-rouge"><pre class="highlight"><code>alert((1,2,3))
</code></pre>
</div>

<p>它的返回值就是3。</p>

<h2 id="shift">5、 shift</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>x = { shift: [].shift };
x.shift();
x.length;	//返回的是？
</code></pre>
</div>

<p>返回0</p>

<p>额外补充一下数组中的几个方法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>pop 和 push：一个是尾部移除，一个是尾部添加
shift 和 unshift：一个是头部移除，一个是头部添加

pop 和 shift 都是做删除工作的  //字母少的都是做删除工作的，不要记混了
</code></pre>
</div>

<blockquote>
  <p>from MDN <br />
1. shift 方法移除索引为 0 的元素(即第一个元素)，并返回被移除的元素，其他元素的索引值随之减 1。如果 length 属性的值为 0 (长度为 0)，则返回 undefined。 <br />
2. shift 方法并不局限于数组：该方法亦可通过<strong>call或apply</strong>作用于对象上。<strong>对于不包含length属性的对象，将添加一个值为0的length属性。</strong></p>
</blockquote>

<p>因为shift 删除第一个元素后，也会改变使其它元素的索引值，所以比pop方法要慢。</p>

<p>现在来看一下这道题</p>

<p>根据上面查到的资料，x 本来没有 length，在被数组方法call后，添加了一个值为0的length属性。此为数组shift方法的泛化性，专业术语为泛型(generic)。其基友方法，例如pop, push等都是如此。</p>

<p>x.shift() 就等同于[].shift.call(x)，一步步来解析一下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var x = {
    shift: function() {
        console.log(this === x); // true
    }
};
x.shift();
</code></pre>
</div>

<p>因此，x.shift()就等同于[].shift 的执行，只不过，[].shift()函数中的this上下文就是x(因为this===x)，就等同于直接的[].shift.call(x)调用。</p>

<p>这条题目中x对象的shift属性名实际上是用来干扰，提高解答难度的刻意命名。我们使用其他命名，结果也是一样的。</p>

<h2 id="foo10">6、{foo:1}[0]</h2>

<p>结果是[0], 或者这种表现形式0 { 0 : 0 } – 来自IE控制台.</p>

<p>不要试图使用alert或者控制台console.log输出，这只会返回不一样的结果undefined，哦？为何会有这等差异？</p>

<p>出题者james在”Labelled blocks, useful?“中有这样的解释：</p>

<blockquote>
  <p>Since JavaScript doesn’t have block scope, using a block anywhere other than in the conventional places (if/while etc.) is almost totally pointless. However, as I mentioned, we could use them to annotate and contain logically related pieces of code…</p>
</blockquote>

<p>意思是说：</p>

<blockquote>
  <p>因为JavaScript没有块作用域，所以，如果语句块不是常规使用，如if/while等，其几乎就是打酱油的。甚至，我们可以利用这个特性注释或者包含相关的逻辑片段代码…</p>
</blockquote>

<p>我们有必要好好理解这里“打酱油的”意思，这里的“打酱油”并不是指{}块中语句是打酱油，而是其本身就是个酱油。嘛意思，实例说明一切：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>2 // 返回值为2
{2} // 返回值为2
str = "string" // 返回值为string
{ str = "string" } // 返回值为string
foo: 1 // 返回值为1
{ foo: 1 } // 返回值为1
</code></pre>
</div>

<p>因此，这里的答案就不难理解了，{foo:1}[0]实际上就是foo:1; [0]. 返回的就是[0]本身。</p>

<h2 id="true-falsetrue-false">7、[true, false][+true, +false]</h2>

<p>结果是true</p>

<p>true == 1, false == 0，[+true, +false] == [+1, +0]</p>

<p>[true, false]为数组，后面的[+true, +false]实际为索引，然而索引只需要一个值，因此，[+true, +false]返回的实际是我们上面提到的逗号运算——返回最后一个值，也就是+0, 也就是0，所以答案为 true。</p>

<h2 id="split0">8、++’52’.split(‘’)[0]</h2>

<p>结果是6</p>

<p>此题难点在于运算符的优先级</p>

<p><img src="http://0.0.0.0:4000/img/20170105/20170105-1.jpg" alt="image01" /></p>

<h2 id="a-b-c-d-e-f-g-1-2-3-4-5">9、a: b: c: d: e: f: g: 1, 2, 3, 4, 5;</h2>

<p>结果是：5</p>

<p>根据规范，a: b: c: … g:在语句执行之前会归到一个标签集中，为一个集合。因此，走个极端的话，我们可以这么理解：
abcdefg: 1, 2, 3, 4, 5. 1, 2, 3, 4, 5一开始有说明的逗号多重运算啦——返回最后一个值，因此，本题就类似于提问：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>abcdefg: 5
</code></pre>
</div>

<h2 id="a-1-b-2b">9、{a: 1, b: 2}[[“b”]]</h2>

<p>第6题中，我们已经讲过，JavaScript没有块作用域，块本身几乎是个酱油，因此这里的测试题实际等同于：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a: 1, b: 2;[["b"]]
</code></pre>
</div>

<p>但是竟然报错,</p>

<p>现在的疑问是，为何a: 1, b: 2会报错？微博提问……</p>

<p>30分钟后，@紫云妃给出了这样的解释：</p>

<blockquote>
  <p>逗号运算符右侧必须是个表达式,不能是非表达式的语句,这个例子中a: 1, b: 2的右侧的b: 2是一个LabelledStatement, 不是表达式。</p>
</blockquote>

<h2 id="b--45">10、”b” + 45</h2>

<p>结果是：”b45”</p>

<blockquote>
  <p>字符串+数值=字符串</p>
</blockquote>

<h2 id="ab2">12、{a:{b:2}}</h2>

<p>结果是：2</p>

<p>{a:{b:2}}近乎于a:b:2, 想起a,b,c,…g的例子没有，显然，这里返回值是2.</p>

<h2 id="function">13、(function(){}())</h2>

<p>结果是：undefined.</p>

<h2 id="tostringlength">14、[1,2$,3,4,5][0..toString.length]??????????</h2>

<p>结果还是：2</p>

<h2 id="b----a">15、({} + ‘b’ &gt; {} + ‘a’)</h2>

<p>结果是：true.</p>

<p>需要注意最外面的括号。如果没有最外面的括号，则{}则几乎无意义，但是这里，作为常规用法，{}表示原生对象。因此，这里的比较实际上就是比较(“[object Object]b” &gt; “[object Object]a”), 因此返回的是true.</p>

<p>说点题外的，如果最外部没有括号，{} + ‘b’返回的是NaN. 于是{} + ‘b’ &gt; {} + ‘a’变成了比较NaN &gt; NaN, 结果为false.</p>

<h2 id="numberprototypex--function-return-this--123---123x">16、Number.prototype.x = function(){ return this === 123; };  (123).x();</h2>

<p>结果是：false.</p>

<p>我们这里使用了严格相等。实际上this和123属于不同的类型。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>typeof this === “object”
typeof 123 === “number”
</code></pre>
</div>

<p>因此，结果为false. 如果我们把题目修改成弱等于，则返回结果就是true了，</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Number.prototype.x = function(){ return this == 123; };
(123).x(); //==&gt;true
</code></pre>
</div>

<h2 id="array2join">17、Array(2).join()</h2>

<p>结果是”,”</p>

<p>Array(2)的返回值是[undefined, undefined]，因此，其使用join连接之后，就是个逗号”,”（数组join为指定连接符时候使用默认的逗号”,”）。</p>

<h2 id="vars-var-vars--vars">18、vars: var vars = vars;</h2>

<p>结果是：undefined.</p>

<p>现在看此题就简单多了，标记语句，返回值就是var vars = vars的返回值undefined.</p>

<p>var vars = vars并不会报vars为定义的错误是在于JS的置顶解析，其实var vars = vars的运作是这样子的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var vars;
vars = vars;
</code></pre>
</div>

<h2 id="foo--123-">19、{ foo = 123 }</h2>

<p>结果是：123.</p>

<h2 id="x--1-functionreturn-x-var-x--2">20、x = 1; (function(){return x; var x = 2;}())</h2>

<p>结果是：undefined</p>

<p>涉及到作用域的问题。</p>

<h2 id="delete-length">21、delete [].length;</h2>

<p>结果为false.</p>

<p>delete用来删除对象属性，成功删除返回true, 如果对方防御很强删不动则返回false.</p>

<p>数组中的length属性是不可删除的，因此这里返回的是false.</p>

<p>delete相关的知识点是很多的，比说法window.x = 1这里的x可以被delete. var x =1这里的x就不能被delete. 图灵社区有篇不错的译文：“理解delete”，推荐阅读。</p>
