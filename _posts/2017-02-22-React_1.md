---
layout: post
title:  React（一）
---



# React（一）

React是Facebook开源的一个用于构建用户界面的Javascript库，已经 应用于Facebook及旗下Instagram。

和庞大的AngularJS不同，React专注于MVC架构中的V，即视图。 这使得React很容易和开发者已有的开发栈进行融合。

React顺应了Web开发组件化的趋势。应用React时，你总是应该从UI出发抽象出不同的组件，然后像搭积木一样把它们拼装起来：



![网页请求过程](http://0.0.0.0:4000/img/20170222/20170222-1.jpg)

不过，React定义组件的方式和AngularJS截然不同。如果说HTML是一个轮子，AngularJS 的指令/Directive则是给这个轮子镶了个金边，而React，重新造了个轮子： JSX。


React抛弃HTML另起炉灶的原因之一是性能的考虑：DOM操作非常之慢。React引入了 虚拟DOM的概念：开发者操作虚拟DOM，React在必要的时候将它们渲染到真正的 DOM上 —— 有点像游戏开发中的双缓冲区/Double Buffer帧重绘。

引入虚拟DOM的另一个好处是，容易引入不同的渲染引擎。比如将你的应用代码渲染 到真实的DOM，或者nodejs服务端的无头DOM，或者，iOS/Android平台组件 —— 这就是 React Native ：


![网页请求过程](http://0.0.0.0:4000/img/20170222/20170222-2.jpg)


### 使用

在引入React库之后，开发API就通过React对象暴露出来了。我们要做的、能做的，就是：

**在虚拟DOM上创建元素，然后将它们渲染到真实DOM上**





```
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Hello React!</title>
	<!--1.引入React库-->
	<script src="build/react.js"></script>
	<script src="build/react-dom.js"></script>
	<script src="build/browser.min.js"></script>
	<style>
		p{font:italic bold 50px verdana;}
	</style>
</head>
<body>
	<!--2.在真实DOM上定义容器-->
	<div id="content"></div>
	<script>
	
		//3.在虚拟DOM上创建p元素
		var el = React.createElement("p",null,"Hello React!");
	
		//4.将虚拟DOM上的p元素渲染到真实DOM上的#content容器
		ReactDOM.render(el,document.querySelector("#content"));
	</script>
</body>
</html>
```


上面代码一共用了三个库： react.js 、react-dom.js 和 Browser.js ，它们必须首先加载。

* react.js 是 React 的核心库，
* react-dom.js 是提供与 DOM 相关的功能，
* Browser.js 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。



#### createElement

```
createElement(type,[props],[children...]) - 在虚拟DOM上创建指定的React元素

type: 用来指定要创建的元素类型，可以是一个字符串或一个React组件类型。当使用 字符串时，这个参数应当是标准的HTML标签名称，比如：p、div、canvas等等。
props: 是可选的JSON对象，用来指定元素的附加属性，比如样式、CSS类等等。 我们在示例中简单的设置为null。
从第三个参数children开始的所有参数，都被认为是这个元素的子元素。
```

#### render

```
render(element,container,[callback]) - 将虚拟DOM上的对象渲染到真实DOM上

element: 使用createElement()方法创建的React元素，注意，不是HTML元素！
container: 是真实DOM中的HTML元素，作为渲染的目标容器，它的内容将被render()方法 的执行改变。
callback: 参数是可选的函数，当渲染完成或更新后被执行，通常不用它。



var el = React.createElement(
    "ul",
    null,
    React.createElement("li",null,"China"),
    React.createElement("li",null,"Japan"),
    React.createElement("li",null,"Korea")
);

render(el, document.querySelector('box')) - 将虚拟DOM上的对象渲染到真实DOM上
```


#### 虚拟DOM

在React中，应用程序在虚拟DOM上操作，这让React有了优化的机会。简单说， React在每次需要渲染时，会先比较当前DOM内容和待渲染内容的差异， 然后再决定如何最优地更新DOM。这个过程被称为reconciliation。

除了性能的考虑，React引入虚拟DOM更重要的意义是提供了一种一致的开发方 式来开发服务端应用、Web应用和手机端应用：


![网页请求过程](http://0.0.0.0:4000/img/20170222/20170222-3.png)


因为有了虚拟DOM这一层，所以通过配备不同的渲染器，就可以将虚拟DOM的内容 渲染到不同的平台。而应用开发者，使用JavaScript就可以通吃各个平台了。



#### React组件

在React中定义一个组件也是相当的容易，组件就是一个 实现预定义接口的JavaScript类：**React.createClass(meta)**

在meta中，至少需要实现一个render()方法，而这个方法， 必须而且只能返回一个有效的React元素。

这意味着，如果你的组件是由多个元素构成的，那么你必须在外边包一个顶层 元素，然后返回这个顶层元素。比如创建一个布局组件：

```
//定义React组件
	var EzLedComp = React.createClass({
		//每个React组件都应该事先render()方法
		render : function(){
			var e = React.createElement(
				"div",
				{className : "ez-led"},
				"Hello, React!"
			);
			//render()方法应该返回一个React元素
			return e;
		}
	});
	//创建React元素
	var el = React.createElement(EzLedComp);
	//渲染
	React.render(el,document.querySelector("#content"));

```

* React组件名称的首字母应当大写
* 注意到div元素的样式类是用 className而不是class声明的，这是因为class 是JavaScript的保留字，渲染后，真实的DOM还会是：

```
<div class="ez-led">Hello, React!</div>
```

* 组件定义以后，和标准HTML标签一样，可以使用createElement()方法 创建元素，只是这时，第一个参数是我们定义的组件类，而不是标签名字符串：

```
React.createElement(EzLedComp);
```


#### JSX

React引入虚拟DOM以后，创建DOM树得在JavaScript里写代码，这使得界面定义 变得相当繁琐。比如我们创建两排的液晶组件得这么写：

```
render: function(){
    return React.createElement(
        "div",null,
        React.createElement("div",{className:"ez-led"},"Hello, React!"),
        React.createElement("div",{className:"ez-led"},"2015-04-15")
    );
}
```

而它们被渲染后对应的声明式HTML则简单明了：

```
<div>
    <div class="ez-led">Hello, React!</div>
    <div class="ez-led">2015-04-15</div>
</div>
```

这显然不是想要的，于是，JSX来了

JSX是对JavaScript语法的扩展，它让我们可以在JavaScript代码中以类似HTML 的方式创建React元素。简单的说，每当你需要使用createElement()时， 就把这个函数调用部分用渲染目标HTML替换（提醒下，不完全一致，比如class属性 要用className代替）：


```
//JavaScript
var e = React.createElement(
        "ul",null,
        React.createElement("li",null,"China"),
        React.createElement("li",null,"Japan"),
    );

//JSX = JavaScript + XML like extension
var e = 
*   China
*   Japan;
```


#### 使用JSX

* 指定脚本类型

在html文件中引入的JSX脚本，需要指定类型为text/jsx：


```
//内联脚本
<script type="text/jsx">...</script>
//外部脚本
<script src="a.js" type="text/jsx"></script>
```


* 引入JSX语法转换库

在html中使用JSX，还需要引入JSX语法转换库JSXTransform.js。 这个库加载后，将在DOM树构造完成后（通过监听DOMContentLoaded事件）处理 JSX脚本：

> 1. 搜索DOM树中的script节点，如果其类型为text/jsx则进行后续处理 <br />
> 2. 读取script节点的内容，将其转化为JavaScript代码 <br />
> 3. 构造一个新的script元素，设置其内容为转化结果代码，并追加到DOM树head元素中


JSXTransform.js引入后通过全局对象JSXTransformer提供了API接口， 我们可以使用transform()方法来模拟这个语法自动转换的过程。



#### props


组件应该提供一些属性供开发者在不同的场景下可以对组件实例元素的行为 外观进行调整，这样可以提高组件的利用效率。

在React中，使用props字段访问实例元素的属性。

例如，在下面的JSX片段中，EzLampComp组件的实例元素有一个属性onoff：

```
React.render(
    < EzLampComp onoff="off" /> ,
    document.querySelector("#content"));
```


那么在EzLampComp组件的实现中，我们可以通过props字段访问这个属性， 并根据属性值设置其样式类。

在JSX中，我们也可以将一个JavaScript表达式赋给React元素的属性，这时需要 使用一对大括号来代替引号：

```
var myOnoff = "on";
React.render(
    < EzLampComp onoff={myOnoff} />,
    document.querySelector("#content"));
```


把上面的JSX代码转换成JavaScript：

```
var myOnoff = "on";
React.render(
    React.createElement(
        EzLampComp,
        {
            onoff : myOnoff
        }),
    document.querySelector("#content"));
```


#### 内联样式

每当需要设定元素的样式，总是使用样式类。如果需要直接在元素上声明内联样式，就像在HTML中一样：

```
//HTML
<div style="width:200px;height:200px;"></div>
```

在React元素中声明样式，需要给出一个JSON对象，其字段对应样式名称，比如要渲染出 上面的HTML片段，需要这样：

```
var myStyle = {
    width:"200px",
    height:"200px"
};
//JSX
var e = <div style={myStyle} />;
//JavaScript
var e = React.createElement(
    "div",{
        style : myStyle
    });
//render
React.render(e,...);    
```
> 1. 对应样式名称的字段，需要使用驼峰式命名,比如：border-radius样式需要使用borderRadius来访问,background-image==>backgroundImage<br />
> 2. 样式名称中的供应商前缀，除ms外都需要大写首字母,对于供应商前缀（-webkit, -moz, -o, -ms），除了ms，其他都需要将首字母大写。 比如：-webkit-transition应当通过WebkitTransition来访问，然而-ms-transition 则需要通过msTransition来访问。 


上个例子：

```
//定义React组件
	var EzLampComp = React.createClass({
		render : function(){
			//取得属性值
			var color = this.props.color,
				onoff = this.props.onoff;
			//亮光颜色
			var lights = {
				"off":"#888",
				"on":"#fff"
			};
			//透明度
			var opacity ={
				"off":0.5,
				"on":1.0
			};
			//根据属性设置附加的样式
			var style = {
				borderRadius : "50%",  //对应样式：border-radius
				opacity : opacity[this.props.onoff], 
				background : "-webkit-radial-gradient(30% 30%," + lights[onoff] + " 5%," + color +" 95%)"
			};
			//返回React元素
			return <span className="ez-lamp" style={style}></span>;  //JSX
		}
	});
	//渲染React元素
	React.render(
		//JSX-->
		<div>
			<EzLampComp color="green" onoff="off"/> 
			<EzLampComp color="green" onoff="on"/> 
			<EzLampComp color="red" onoff="off"/> 
			<EzLampComp color="red" onoff="on"/> 
			<EzLampComp color="blue" onoff="off"/> 
			<EzLampComp color="blue" onoff="on"/> 
		</div>
		//<--JSX
		,document.querySelector("#content"));
```


